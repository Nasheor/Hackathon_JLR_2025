[
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdint.h>\n\ntypedef struct {\n    uint16_t messageId;\n    uint16_t payloadType;\n    uint16_t payloadLength; \n    uint8_t payload[512]; \n} DiagnosticMessage;\n\nchar* processDiagnosticReport(const DiagnosticMessage* msg) {\n    if (!msg || msg->payloadLength == 0) {\n        return NULL;\n    }\n\n    char* hex_payload_str = (char*)malloc(msg->payloadLength + 1);\n\n    if (hex_payload_str == NULL) {\n        return NULL;\n    }\n\n    for (uint16_t i = 0; i < msg->payloadLength; ++i) {\n        sprintf(&hex_payload_str[i * 2], \"%02X\", msg->payload[i]);\n    }\n    hex_payload_str[msg->payloadLength * 2] = '\\0';\n\n    return hex_payload_str;\n}",
    "fixed_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdint.h>\n\ntypedef struct {\n    uint16_t messageId;\n    uint16_t payloadType;\n    uint16_t payloadLength; \n    uint8_t payload[512]; \n} DiagnosticMessage;\n\nchar* processDiagnosticReport(const DiagnosticMessage* msg) {\n    if (!msg || msg->payloadLength == 0) {\n        char* empty_str = (char*)malloc(1);\n        if (empty_str) {\n            empty_str[0] = '\\0';\n        }\n        return empty_str;\n    }\n\n    size_t required_size = (size_t)msg->payloadLength * 2 + 1;\n\n    char* hex_payload_str = (char*)malloc(required_size);\n\n    if (hex_payload_str == NULL) {\n        return NULL;\n    }\n\n    for (uint16_t i = 0; i < msg->payloadLength; ++i) {\n        sprintf(&hex_payload_str[i * 2], \"%02X\", msg->payload[i]);\n    }\n    hex_payload_str[msg->payloadLength * 2] = '\\0';\n\n    return hex_payload_str;\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <stdlib.h>\n#include <stdint.h>\n\n#define MAX_ERROR_DESC_LEN 64\n\ntypedef struct {\n    uint32_t errorCode;\n    uint8_t severity;\n    char description[MAX_ERROR_DESC_LEN];\n} DiagnosticErrorEntry;\n\nclass ErrorLogManager {\npublic:\n    ErrorLogManager() : current_capacity(0), num_errors(0), error_entries(NULL) {\n        current_capacity = 4;\n        error_entries = (DiagnosticErrorEntry*)malloc(current_capacity * sizeof(DiagnosticErrorEntry));\n        if (!error_entries) {\n            // Handle allocation failure\n        }\n    }\n\n    ~ErrorLogManager() {\n        if (error_entries) {\n            free(error_entries);\n            error_entries = NULL;\n        }\n    }\n\n    bool addErrorEntryVulnerable(uint32_t code, uint8_t sev, const char* desc) {\n        if (!desc) {\n            return false;\n        }\n\n        if (num_errors >= current_capacity) {\n            size_t new_capacity = current_capacity * 2;\n            DiagnosticErrorEntry* new_entries = (DiagnosticErrorEntry*)realloc(error_entries, new_capacity * sizeof(DiagnosticErrorEntry));\n            if (!new_entries) {\n                return false;\n            }\n            error_entries = new_entries;\n            current_capacity = new_capacity;\n        }\n\n        error_entries[num_errors].errorCode = code;\n        error_entries[num_errors].severity = sev;\n\n        size_t desc_idx = 0;\n        // Vulnerable: No bounds check for 'desc_idx' against 'MAX_ERROR_DESC_LEN'\n        while (desc[desc_idx] != '\\0') {\n            error_entries[num_errors].description[desc_idx] = desc[desc_idx];\n            desc_idx++;\n        }\n        // If 'desc' is too long, 'desc_idx' can exceed 'MAX_ERROR_DESC_LEN - 1',\n        // leading to writing past the end of the 'description' array in heap-allocated memory.\n        // The null terminator write may also be out of bounds if desc_idx == MAX_ERROR_DESC_LEN.\n        error_entries[num_errors].description[desc_idx] = '\\0';\n\n        num_errors++;\n        return true;\n    }\n\nprivate:\n    size_t current_capacity;\n    size_t num_errors;\n    DiagnosticErrorEntry* error_entries;\n};\n",
    "fixed_code": "#include <stdlib.h>\n#include <stdint.h>\n\n#define MAX_ERROR_DESC_LEN 64\n\ntypedef struct {\n    uint32_t errorCode;\n    uint8_t severity;\n    char description[MAX_ERROR_DESC_LEN];\n} DiagnosticErrorEntry;\n\nclass ErrorLogManager {\npublic:\n    ErrorLogManager() : current_capacity(0), num_errors(0), error_entries(NULL) {\n        current_capacity = 4;\n        error_entries = (DiagnosticErrorEntry*)malloc(current_capacity * sizeof(DiagnosticErrorEntry));\n        if (!error_entries) {\n            // Handle allocation failure\n        }\n    }\n\n    ~ErrorLogManager() {\n        if (error_entries) {\n            free(error_entries);\n            error_entries = NULL;\n        }\n    }\n\n    bool addErrorEntryFixed(uint32_t code, uint8_t sev, const char* desc) {\n        if (!desc) {\n            return false;\n        }\n\n        if (num_errors >= current_capacity) {\n            size_t new_capacity = current_capacity * 2;\n            // Defensive check for potential integer overflow in 'new_capacity' calculation\n            if (new_capacity <= current_capacity) { \n                return false; \n            }\n            DiagnosticErrorEntry* new_entries = (DiagnosticErrorEntry*)realloc(error_entries, new_capacity * sizeof(DiagnosticErrorEntry));\n            if (!new_entries) {\n                return false;\n            }\n            error_entries = new_entries;\n            current_capacity = new_capacity;\n        }\n\n        error_entries[num_errors].errorCode = code;\n        error_entries[num_errors].severity = sev;\n\n        size_t desc_idx = 0;\n        // Fixed: Added bounds check for 'desc_idx' to ensure it doesn't exceed 'MAX_ERROR_DESC_LEN - 1'\n        // This ensures space for the null terminator and prevents heap overflow.\n        while (desc[desc_idx] != '\\0' && desc_idx < MAX_ERROR_DESC_LEN - 1) {\n            error_entries[num_errors].description[desc_idx] = desc[desc_idx];\n            desc_idx++;\n        }\n        // Always null-terminate within bounds, potentially truncating the string\n        error_entries[num_errors].description[desc_idx] = '\\0';\n\n        num_errors++;\n        return true;\n    }\n\nprivate:\n    size_t current_capacity;\n    size_t num_errors;\n    DiagnosticErrorEntry* error_entries;\n};\n",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct {\n    uint16_t packet_id;\n    uint16_t num_sensor_readings;\n} SensorDataPacketHeader;\n\nclass SensorDataProcessor {\npublic:\n    SensorDataProcessor() : processed_readings(nullptr), current_reading_count(0) {}\n\n    ~SensorDataProcessor() {\n        if (processed_readings) {\n            free(processed_readings);\n            processed_readings = nullptr;\n        }\n    }\n\n    bool processRawSensorDataVulnerable(const uint8_t* packet_data, size_t packet_length) {\n        if (!packet_data || packet_length < sizeof(SensorDataPacketHeader)) {\n            return false;\n        }\n\n        const SensorDataPacketHeader* header = reinterpret_cast<const SensorDataPacketHeader*>(packet_data);\n        uint16_t num_samples = header->num_sensor_readings;\n\n        size_t data_offset = sizeof(SensorDataPacketHeader);\n        size_t expected_data_bytes = num_samples * sizeof(uint16_t);\n\n        if (packet_length < (data_offset + expected_data_bytes)) {\n            return false;\n        }\n\n        if (processed_readings) {\n            free(processed_readings);\n            processed_readings = nullptr;\n        }\n\n        processed_readings = (uint16_t*)malloc(num_samples);\n\n        if (!processed_readings) {\n            return false;\n        }\n\n        memcpy(processed_readings, packet_data + data_offset, expected_data_bytes);\n\n        current_reading_count = num_samples;\n        return true;\n    }\n\n    uint16_t* getProcessedReadings() const { return processed_readings; }\n    uint16_t getReadingCount() const { return current_reading_count; }\n\nprivate:\n    uint16_t* processed_readings;\n    uint16_t current_reading_count;\n};\n",
    "fixed_code": "#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct {\n    uint16_t packet_id;\n    uint16_t num_sensor_readings;\n} SensorDataPacketHeader;\n\nclass SensorDataProcessor {\npublic:\n    SensorDataProcessor() : processed_readings(nullptr), current_reading_count(0) {}\n\n    ~SensorDataProcessor() {\n        if (processed_readings) {\n            free(processed_readings);\n            processed_readings = nullptr;\n        }\n    }\n\n    bool processRawSensorDataFixed(const uint8_t* packet_data, size_t packet_length) {\n        if (!packet_data || packet_length < sizeof(SensorDataPacketHeader)) {\n            return false;\n        }\n\n        const SensorDataPacketHeader* header = reinterpret_cast<const SensorDataPacketHeader*>(packet_data);\n        uint16_t num_samples = header->num_sensor_readings;\n\n        size_t data_offset = sizeof(SensorDataPacketHeader);\n        size_t expected_data_bytes = num_samples * sizeof(uint16_t);\n\n        if (num_samples > (SIZE_MAX / sizeof(uint16_t))) {\n             return false;\n        }\n\n        if (packet_length < (data_offset + expected_data_bytes)) {\n            return false;\n        }\n\n        if (processed_readings) {\n            free(processed_readings);\n            processed_readings = nullptr;\n        }\n\n        processed_readings = (uint16_t*)malloc(expected_data_bytes);\n\n        if (!processed_readings) {\n            return false;\n        }\n\n        memcpy(processed_readings, packet_data + data_offset, expected_data_bytes);\n\n        current_reading_count = num_samples;\n        return true;\n    }\n\n    uint16_t* getProcessedReadings() const { return processed_readings; }\n    uint16_t getReadingCount() const { return current_reading_count; }\n\nprivate:\n    uint16_t* processed_readings;\n    uint16_t current_reading_count;\n};\n",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstddef>\n#include <new>\n\ntypedef struct {\n    uint32_t config_id;\n    uint32_t data_length;\n} ConfigBlockHeader;\n\nclass VehicleConfigUpdater {\npublic:\n    VehicleConfigUpdater() : current_config_data(nullptr), current_config_size(0) {}\n\n    ~VehicleConfigUpdater() {\n        if (current_config_data) {\n            delete[] current_config_data;\n            current_config_data = nullptr;\n        }\n    }\n\n    const uint8_t* getCurrentConfigData() const {\n        return current_config_data;\n    }\n\n    uint32_t getCurrentConfigSize() const {\n        return current_config_size;\n    }\n\n    bool processConfigBlockVulnerable(const uint8_t* block_data, size_t block_len) {\n        if (!block_data || block_len < sizeof(ConfigBlockHeader)) {\n            return false;\n        }\n\n        const ConfigBlockHeader* header = reinterpret_cast<const ConfigBlockHeader*>(block_data);\n        uint32_t advertised_data_len = header->data_length;\n\n        uint8_t* temp_buffer = new (std::nothrow) uint8_t[advertised_data_len];\n        if (!temp_buffer) {\n            return false;\n        }\n\n        size_t actual_payload_bytes_in_block = block_len - sizeof(ConfigBlockHeader);\n\n        for (size_t i = 0; i < actual_payload_bytes_in_block; ++i) {\n            temp_buffer[i] = block_data[sizeof(ConfigBlockHeader) + i];\n        }\n\n        if (current_config_data) {\n            delete[] current_config_data;\n        }\n\n        current_config_data = temp_buffer;\n        current_config_size = advertised_data_len;\n\n        return true;\n    }\n\nprivate:\n    uint8_t* current_config_data;\n    uint32_t current_config_size;\n};\n",
    "fixed_code": "#include <cstdint>\n#include <cstddef>\n#include <new>\n#include <algorithm>\n\ntypedef struct {\n    uint32_t config_id;\n    uint32_t data_length;\n} ConfigBlockHeader;\n\nclass VehicleConfigUpdater {\npublic:\n    VehicleConfigUpdater() : current_config_data(nullptr), current_config_size(0) {}\n\n    ~VehicleConfigUpdater() {\n        if (current_config_data) {\n            delete[] current_config_data;\n            current_config_data = nullptr;\n        }\n    }\n\n    const uint8_t* getCurrentConfigData() const {\n        return current_config_data;\n    }\n\n    uint32_t getCurrentConfigSize() const {\n        return current_config_size;\n    }\n\n    bool processConfigBlockFixed(const uint8_t* block_data, size_t block_len) {\n        if (!block_data || block_len < sizeof(ConfigBlockHeader)) {\n            return false;\n        }\n\n        const ConfigBlockHeader* header = reinterpret_cast<const ConfigBlockHeader*>(block_data);\n        uint32_t advertised_data_len = header->data_length;\n\n        size_t actual_payload_bytes_in_block = block_len - sizeof(ConfigBlockHeader);\n\n        static const uint32_t MAX_ALLOWED_CONFIG_DATA_SIZE = 4096;\n        if (advertised_data_len > MAX_ALLOWED_CONFIG_DATA_SIZE) {\n            return false;\n        }\n\n        size_t bytes_to_copy = std::min((size_t)advertised_data_len, actual_payload_bytes_in_block);\n\n        uint8_t* temp_buffer = new (std::nothrow) uint8_t[advertised_data_len];\n        if (!temp_buffer) {\n            return false;\n        }\n\n        for (size_t i = 0; i < bytes_to_copy; ++i) {\n            temp_buffer[i] = block_data[sizeof(ConfigBlockHeader) + i];\n        }\n\n        if (current_config_data) {\n            delete[] current_config_data;\n        }\n\n        current_config_data = temp_buffer;\n        current_config_size = advertised_data_len;\n\n        return true;\n    }\n\nprivate:\n    uint8_t* current_config_data;\n    uint32_t current_config_size;\n};\n",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n\ntypedef struct {\n    uint16_t message_type;\n    uint16_t total_data_size;\n    uint16_t fragment_offset;\n    uint8_t  fragment_length;\n    uint8_t  payload[64];\n} TelemetryDataFragment;\n\nclass TelemetryDataAssembler {\nprivate:\n    uint8_t* assembled_data_buffer;\n    uint32_t current_assembled_length;\n    uint32_t expected_total_data_size;\n    bool     assembly_active;\n    uint16_t current_message_type;\n\npublic:\n    TelemetryDataAssembler() : assembled_data_buffer(nullptr), current_assembled_length(0),\n                               expected_total_data_size(0), assembly_active(false), current_message_type(0) {}\n\n    ~TelemetryDataAssembler() {\n        if (assembled_data_buffer) {\n            free(assembled_data_buffer);\n            assembled_data_buffer = nullptr;\n        }\n    }\n\n    void resetAssembly() {\n        if (assembled_data_buffer) {\n            free(assembled_data_buffer);\n        }\n        assembled_data_buffer = nullptr;\n        current_assembled_length = 0;\n        expected_total_data_size = 0;\n        assembly_active = false;\n        current_message_type = 0;\n    }\n\n    bool processFragmentVulnerable(const TelemetryDataFragment* fragment) {\n        if (!fragment || fragment->fragment_length > sizeof(fragment->payload)) {\n            return false;\n        }\n\n        if (!assembly_active) {\n            expected_total_data_size = fragment->total_data_size;\n            current_message_type = fragment->message_type;\n\n            if (expected_total_data_size == 0 || expected_total_data_size > 65535) {\n                return false;\n            }\n\n            assembled_data_buffer = (uint8_t*)malloc(expected_total_data_size);\n            if (!assembled_data_buffer) {\n                return false;\n            }\n            current_assembled_length = 0;\n            assembly_active = true;\n        } else {\n            if (fragment->message_type != current_message_type) {\n                return false;\n            }\n        }\n\n        for (uint8_t i = 0; i < fragment->fragment_length; ++i) {\n            assembled_data_buffer[fragment->fragment_offset + i] = fragment->payload[i];\n        }\n\n        uint32_t end_offset = fragment->fragment_offset + fragment->fragment_length;\n        if (end_offset > current_assembled_length) {\n            current_assembled_length = end_offset;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getAssembledData() const {\n        if (current_assembled_length == expected_total_data_size) {\n            return assembled_data_buffer;\n        }\n        return nullptr;\n    }\n\n    uint32_t getAssembledLength() const {\n        return current_assembled_length;\n    }\n\n    uint32_t getExpectedTotalSize() const {\n        return expected_total_data_size;\n    }\n};",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <algorithm>\n\ntypedef struct {\n    uint16_t message_type;\n    uint16_t total_data_size;\n    uint16_t fragment_offset;\n    uint8_t  fragment_length;\n    uint8_t  payload[64];\n} TelemetryDataFragment;\n\nclass TelemetryDataAssembler {\nprivate:\n    uint8_t* assembled_data_buffer;\n    uint32_t current_assembled_length;\n    uint32_t expected_total_data_size;\n    bool     assembly_active;\n    uint16_t current_message_type;\n\npublic:\n    TelemetryDataAssembler() : assembled_data_buffer(nullptr), current_assembled_length(0),\n                               expected_total_data_size(0), assembly_active(false), current_message_type(0) {}\n\n    ~TelemetryDataAssembler() {\n        if (assembled_data_buffer) {\n            free(assembled_data_buffer);\n            assembled_data_buffer = nullptr;\n        }\n    }\n\n    void resetAssembly() {\n        if (assembled_data_buffer) {\n            free(assembled_data_buffer);\n        }\n        assembled_data_buffer = nullptr;\n        current_assembled_length = 0;\n        expected_total_data_size = 0;\n        assembly_active = false;\n        current_message_type = 0;\n    }\n\n    bool processFragmentFixed(const TelemetryDataFragment* fragment) {\n        if (!fragment || fragment->fragment_length > sizeof(fragment->payload)) {\n            return false;\n        }\n\n        if (!assembly_active) {\n            expected_total_data_size = fragment->total_data_size;\n            current_message_type = fragment->message_type;\n\n            if (expected_total_data_size == 0 || expected_total_data_size > 65535) {\n                return false;\n            }\n\n            assembled_data_buffer = (uint8_t*)malloc(expected_total_data_size);\n            if (!assembled_data_buffer) {\n                return false;\n            }\n            current_assembled_length = 0;\n            assembly_active = true;\n        } else {\n            if (fragment->message_type != current_message_type) {\n                return false;\n            }\n        }\n\n        if (fragment->fragment_offset >= expected_total_data_size ||\n            (uint32_t)fragment->fragment_offset + fragment->fragment_length > expected_total_data_size) {\n            return false;\n        }\n\n        for (uint8_t i = 0; i < fragment->fragment_length; ++i) {\n            assembled_data_buffer[fragment->fragment_offset + i] = fragment->payload[i];\n        }\n\n        uint32_t end_offset = fragment->fragment_offset + fragment->fragment_length;\n        if (end_offset > current_assembled_length) {\n            current_assembled_length = end_offset;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getAssembledData() const {\n        if (current_assembled_length == expected_total_data_size) {\n            return assembled_data_buffer;\n        }\n        return nullptr;\n    }\n\n    uint32_t getAssembledLength() const {\n        return current_assembled_length;\n    }\n\n    uint32_t getExpectedTotalSize() const {\n        return expected_total_data_size;\n    }\n};",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_LOG_ENTRY_DESCRIPTION_LEN 256\n#define INITIAL_LOG_BUFFER_CAPACITY 1024\n\ntypedef struct {\n    uint32_t timestamp;\n    uint16_t event_id;\n    uint16_t desc_length; \n} LogEntryHeader;\n\nclass DiagnosticLogBufferVulnerable {\npublic:\n    DiagnosticLogBufferVulnerable() :\n        log_buffer(nullptr),\n        current_data_size(0),\n        allocated_capacity(0)\n    {\n        log_buffer = (uint8_t*)malloc(INITIAL_LOG_BUFFER_CAPACITY);\n        if (log_buffer) {\n            allocated_capacity = INITIAL_LOG_BUFFER_CAPACITY;\n        }\n    }\n\n    ~DiagnosticLogBufferVulnerable() {\n        if (log_buffer) {\n            free(log_buffer);\n            log_buffer = nullptr;\n        }\n    }\n\n    bool addLogEntryVulnerable(uint32_t timestamp, uint16_t event_id, const char* description) {\n        if (!description) {\n            return false;\n        }\n\n        size_t actual_desc_len = strlen(description);\n        if (actual_desc_len >= MAX_LOG_ENTRY_DESCRIPTION_LEN) {\n            return false;\n        }\n\n        size_t required_entry_data_space = sizeof(LogEntryHeader) + actual_desc_len;\n\n        if (current_data_size + required_entry_data_space > allocated_capacity) {\n            size_t new_capacity = allocated_capacity * 2;\n            if (new_capacity <= allocated_capacity || new_capacity < current_data_size + required_entry_data_space) {\n                new_capacity = current_data_size + required_entry_data_space + INITIAL_LOG_BUFFER_CAPACITY;\n            }\n            \n            uint8_t* new_log_buffer = (uint8_t*)realloc(log_buffer, new_capacity);\n            if (!new_log_buffer) {\n                return false;\n            }\n            log_buffer = new_log_buffer;\n            allocated_capacity = new_capacity;\n        }\n\n        LogEntryHeader header;\n        header.timestamp = timestamp;\n        header.event_id = event_id;\n        header.desc_length = (uint16_t)actual_desc_len;\n\n        memcpy(log_buffer + current_data_size, &header, sizeof(LogEntryHeader));\n        \n        uint8_t* desc_dest_ptr = log_buffer + current_data_size + sizeof(LogEntryHeader);\n\n        for (size_t i = 0; i <= actual_desc_len; ++i) {\n            desc_dest_ptr[i] = description[i];\n        }\n\n        current_data_size += sizeof(LogEntryHeader) + actual_desc_len + 1;\n\n        return true;\n    }\n\n    const uint8_t* getRawLogBuffer() const {\n        return log_buffer;\n    n}\n\n    size_t getContainedDataSize() const {\n        return current_data_size;\n    }\n\nprivate:\n    uint8_t* log_buffer;\n    size_t current_data_size;\n    size_t allocated_capacity;\n};\n",
    "fixed_code": "#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_LOG_ENTRY_DESCRIPTION_LEN 256\n#define INITIAL_LOG_BUFFER_CAPACITY 1024\n\ntypedef struct {\n    uint32_t timestamp;\n    uint16_t event_id;\n    uint16_t desc_length;\n} LogEntryHeader;\n\nclass DiagnosticLogBufferFixed {\npublic:\n    DiagnosticLogBufferFixed() :\n        log_buffer(nullptr),\n        current_data_size(0),\n        allocated_capacity(0)\n    {\n        log_buffer = (uint8_t*)malloc(INITIAL_LOG_BUFFER_CAPACITY);\n        if (log_buffer) {\n            allocated_capacity = INITIAL_LOG_BUFFER_CAPACITY;\n        }\n    }\n\n    ~DiagnosticLogBufferFixed() {\n        if (log_buffer) {\n            free(log_buffer);\n            log_buffer = nullptr;\n        }\n    }\n\n    bool addLogEntryFixed(uint32_t timestamp, uint16_t event_id, const char* description) {\n        if (!description) {\n            return false;\n        }\n\n        size_t actual_desc_len = strlen(description);\n        if (actual_desc_len >= MAX_LOG_ENTRY_DESCRIPTION_LEN) {\n            return false;\n        }\n\n        size_t required_entry_data_space = sizeof(LogEntryHeader) + actual_desc_len + 1; \n\n        if (current_data_size + required_entry_data_space > allocated_capacity) {\n            size_t new_capacity = allocated_capacity * 2;\n            if (new_capacity <= allocated_capacity || new_capacity < current_data_size + required_entry_data_space) {\n                new_capacity = current_data_size + required_entry_data_space + INITIAL_LOG_BUFFER_CAPACITY;\n            }\n            \n            uint8_t* new_log_buffer = (uint8_t*)realloc(log_buffer, new_capacity);\n            if (!new_log_buffer) {\n                return false;\n            }\n            log_buffer = new_log_buffer;\n            allocated_capacity = new_capacity;\n        }\n\n        LogEntryHeader header;\n        header.timestamp = timestamp;\n        header.event_id = event_id;\n        header.desc_length = (uint16_t)actual_desc_len;\n\n        memcpy(log_buffer + current_data_size, &header, sizeof(LogEntryHeader));\n        \n        uint8_t* desc_dest_ptr = log_buffer + current_data_size + sizeof(LogEntryHeader);\n\n        for (size_t i = 0; i <= actual_desc_len; ++i) {\n            desc_dest_ptr[i] = description[i];\n        }\n\n        current_data_size += sizeof(LogEntryHeader) + actual_desc_len + 1;\n\n        return true;\n    }\n\n    const uint8_t* getRawLogBuffer() const {\n        return log_buffer;\n    }\n\n    size_t getContainedDataSize() const {\n        return current_data_size;\n    }\n\nprivate:\n    uint8_t* log_buffer;\n    size_t current_data_size;\n    size_t allocated_capacity;\n};\n",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstddef>\n#include <new>\n\nstruct ProcessedTelemetryData {\n    uint32_t timestamp;\n    int32_t  engine_rpm;\n    int16_t  vehicle_speed;\n    uint8_t  gear_position;\n    bool     is_engine_on;\n};\n\nstruct RawTelemetryPacketHeader {\n    uint16_t packet_type;\n    uint16_t num_readings;\n    uint32_t total_payload_bytes;\n};\n\nclass TelemetryDataManager {\npublic:\n    TelemetryDataManager() : data_buffer(nullptr), buffer_capacity(0), current_data_count(0) {}\n\n    ~TelemetryDataManager() {\n        if (data_buffer) {\n            delete[] data_buffer;\n            data_buffer = nullptr;\n        }\n    }\n\n    bool processRawTelemetryPacketVulnerable(const uint8_t* raw_packet, size_t raw_packet_len) {\n        if (!raw_packet || raw_packet_len < sizeof(RawTelemetryPacketHeader)) {\n            return false;\n        }\n\n        const RawTelemetryPacketHeader* header = reinterpret_cast<const RawTelemetryPacketHeader*>(raw_packet);\n\n        if (static_cast<size_t>(header->total_payload_bytes) > (raw_packet_len - sizeof(RawTelemetryPacketHeader))) {\n            return false;\n        }\n\n        if (data_buffer) {\n            delete[] data_buffer;\n            data_buffer = nullptr;\n        }\n\n        buffer_capacity = header->num_readings;\n        data_buffer = new (std::nothrow) ProcessedTelemetryData[buffer_capacity];\n        if (!data_buffer) {\n            return false;\n        }\n\n        const uint8_t* payload_start = raw_packet + sizeof(RawTelemetryPacketHeader);\n        size_t bytes_to_copy = static_cast<size_t>(header->total_payload_bytes);\n\n        for (size_t i = 0; i < bytes_to_copy; ++i) {\n            reinterpret_cast<uint8_t*>(data_buffer)[i] = payload_start[i];\n        }\n\n        current_data_count = header->num_readings;\n\n        return true;\n    }\n\n    const ProcessedTelemetryData* getTelemetryData() const { return data_buffer; }\n    uint16_t getTelemetryCount() const { return current_data_count; }\n\nprivate:\n    ProcessedTelemetryData* data_buffer;\n    uint16_t                buffer_capacity;\n    uint16_t                current_data_count;\n};",
    "fixed_code": "#include <cstdint>\n#include <cstddef>\n#include <new>\n#include <algorithm>\n\nstruct ProcessedTelemetryData {\n    uint32_t timestamp;\n    int32_t  engine_rpm;\n    int16_t  vehicle_speed;\n    uint8_t  gear_position;\n    bool     is_engine_on;\n};\n\nstruct RawTelemetryPacketHeader {\n    uint16_t packet_type;\n    uint16_t num_readings;\n    uint32_t total_payload_bytes;\n};\n\nclass TelemetryDataManager {\npublic:\n    TelemetryDataManager() : data_buffer(nullptr), buffer_capacity(0), current_data_count(0) {}\n\n    ~TelemetryDataManager() {\n        if (data_buffer) {\n            delete[] data_buffer;\n            data_buffer = nullptr;\n        }\n    }\n\n    bool processRawTelemetryPacketFixed(const uint8_t* raw_packet, size_t raw_packet_len) {\n        if (!raw_packet || raw_packet_len < sizeof(RawTelemetryPacketHeader)) {\n            return false;\n        }\n\n        const RawTelemetryPacketHeader* header = reinterpret_cast<const RawTelemetryPacketHeader*>(raw_packet);\n\n        size_t max_actual_payload_in_packet = raw_packet_len - sizeof(RawTelemetryPacketHeader);\n\n        if (static_cast<size_t>(header->total_payload_bytes) > max_actual_payload_in_packet) {\n            return false;\n        }\n\n        size_t requested_num_readings = header->num_readings;\n        \n        if (requested_num_readings > (SIZE_MAX / sizeof(ProcessedTelemetryData))) {\n             return false;\n        }\n        size_t required_allocation_bytes = requested_num_readings * sizeof(ProcessedTelemetryData);\n\n        if (data_buffer) {\n            delete[] data_buffer;\n            data_buffer = nullptr;\n        }\n\n        data_buffer = new (std::nothrow) ProcessedTelemetryData[requested_num_readings];\n        if (!data_buffer) {\n            return false;\n        }\n        buffer_capacity = requested_num_readings;\n\n        size_t bytes_to_copy = std::min({\n            static_cast<size_t>(header->total_payload_bytes),\n            max_actual_payload_in_packet,\n            required_allocation_bytes\n        });\n\n        const uint8_t* payload_start = raw_packet + sizeof(RawTelemetryPacketHeader);\n        for (size_t i = 0; i < bytes_to_copy; ++i) {\n            reinterpret_cast<uint8_t*>(data_buffer)[i] = payload_start[i];\n        }\n\n        current_data_count = bytes_to_copy / sizeof(ProcessedTelemetryData);\n\n        return true;\n    }\n\n    const ProcessedTelemetryData* getTelemetryData() const { return data_buffer; }\n    uint16_t getTelemetryCount() const { return current_data_count; }\n\nprivate:\n    ProcessedTelemetryData* data_buffer;\n    uint16_t                buffer_capacity;\n    uint16_t                current_data_count;\n};",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n\ntypedef struct {\n    uint16_t packet_id;\n    uint16_t num_sensor_readings; \n} TelemetryPacketHeader;\n\nclass TelemetryProcessor {\npublic:\n    TelemetryProcessor() : sensor_data_buffer(nullptr), buffer_size(0) {}\n\n    ~TelemetryProcessor() {\n        if (sensor_data_buffer) {\n            free(sensor_data_buffer);\n            sensor_data_buffer = nullptr;\n        }\n    }\n\n    bool processTelemetryPacketVulnerable(const uint8_t* packet_data, size_t packet_length) {\n        if (!packet_data || packet_length < sizeof(TelemetryPacketHeader)) {\n            return false;\n        }\n\n        const TelemetryPacketHeader* header = reinterpret_cast<const TelemetryPacketHeader*>(packet_data);\n        uint16_t num_readings = header->num_sensor_readings;\n\n        size_t expected_payload_size = (size_t)num_readings * sizeof(uint16_t);\n        size_t expected_total_packet_size = sizeof(TelemetryPacketHeader) + expected_payload_size;\n\n        if (packet_length < expected_total_packet_size) {\n            return false;\n        }\n\n        if (sensor_data_buffer) {\n            free(sensor_data_buffer);\n            sensor_data_buffer = nullptr;\n            buffer_size = 0;\n        }\n\n        sensor_data_buffer = (uint16_t*)malloc(expected_payload_size);\n        if (!sensor_data_buffer) {\n            return false;\n        }\n        buffer_size = expected_payload_size;\n\n        const uint8_t* data_ptr = packet_data + sizeof(TelemetryPacketHeader);\n\n        for (uint16_t i = 0; i <= num_readings; ++i) {\n            sensor_data_buffer[i] = (uint16_t)(data_ptr[i * 2] | (data_ptr[i * 2 + 1] << 8));\n        }\n\n        return true;\n    }\n\n    const uint16_t* getSensorData() const { return sensor_data_buffer; }\n    size_t getBufferSize() const { return buffer_size; }\n\nprivate:\n    uint16_t* sensor_data_buffer;\n    size_t buffer_size;\n}",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n\ntypedef struct {\n    uint16_t packet_id;\n    uint16_t num_sensor_readings; \n} TelemetryPacketHeader;\n\nclass TelemetryProcessor {\npublic:\n    TelemetryProcessor() : sensor_data_buffer(nullptr), buffer_size(0) {}\n\n    ~TelemetryProcessor() {\n        if (sensor_data_buffer) {\n            free(sensor_data_buffer);\n            sensor_data_buffer = nullptr;\n        }\n    }\n\n    bool processTelemetryPacketFixed(const uint8_t* packet_data, size_t packet_length) {\n        if (!packet_data || packet_length < sizeof(TelemetryPacketHeader)) {\n            return false;\n        }\n\n        const TelemetryPacketHeader* header = reinterpret_cast<const TelemetryPacketHeader*>(packet_data);\n        uint16_t num_readings = header->num_sensor_readings;\n\n        static const uint16_t MAX_SENSOR_READINGS = 1024;\n        if (num_readings > MAX_SENSOR_READINGS) {\n            return false;\n        }\n\n        size_t expected_payload_size = (size_t)num_readings * sizeof(uint16_t);\n        size_t expected_total_packet_size = sizeof(TelemetryPacketHeader) + expected_payload_size;\n\n        if (num_readings > 0 && expected_payload_size / sizeof(uint16_t) != num_readings) {\n             return false;\n        }\n\n        if (packet_length < expected_total_packet_size) {\n            return false;\n        }\n\n        if (sensor_data_buffer) {\n            free(sensor_data_buffer);\n            sensor_data_buffer = nullptr;\n            buffer_size = 0;\n        }\n\n        sensor_data_buffer = (uint16_t*)malloc(expected_payload_size);\n        if (!sensor_data_buffer) {\n            return false;\n        }\n        buffer_size = expected_payload_size;\n\n        const uint8_t* data_ptr = packet_data + sizeof(TelemetryPacketHeader);\n\n        for (uint16_t i = 0; i < num_readings; ++i) {\n            sensor_data_buffer[i] = (uint16_t)(data_ptr[i * 2] | (data_ptr[i * 2 + 1] << 8));\n        }\n\n        return true;\n    }\n\n    const uint16_t* getSensorData() const { return sensor_data_buffer; }\n    size_t getBufferSize() const { return buffer_size; }\n\nprivate:\n    uint16_t* sensor_data_buffer;\n    size_t buffer_size;\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstddef>\n#include <new>\n\ntypedef struct {\n    uint16_t record_id;\n    uint16_t data_size; \n} LogRecordHeader;\n\ntypedef struct {\n    uint32_t total_expected_payload_bytes; \n    uint16_t num_records;       \n} LogPacketHeader;\n\nclass VehicleLogProcessor {\npublic:\n    VehicleLogProcessor() :\n        internal_log_buffer(nullptr),\n        allocated_buffer_size(0) {}\n\n    ~VehicleLogProcessor() {\n        if (internal_log_buffer) {\n            delete[] internal_log_buffer;\n            internal_log_buffer = nullptr;\n        }\n    }\n\n    bool processLogPacketVulnerable(const uint8_t* raw_packet, size_t raw_packet_len) {\n        if (!raw_packet || raw_packet_len < sizeof(LogPacketHeader)) {\n            return false;\n        }\n\n        const LogPacketHeader* packet_header = reinterpret_cast<const LogPacketHeader*>(raw_packet);\n\n        if (raw_packet_len < (sizeof(LogPacketHeader) + packet_header->total_expected_payload_bytes)) {\n            return false;\n        }\n\n        if (internal_log_buffer) {\n            delete[] internal_log_buffer;\n        }\n        internal_log_buffer = new (std::nothrow) uint8_t[packet_header->total_expected_payload_bytes];\n        if (!internal_log_buffer) {\n            return false;\n        }\n        allocated_buffer_size = packet_header->total_expected_payload_bytes;\n\n        size_t current_raw_read_offset = sizeof(LogPacketHeader);\n        size_t current_internal_write_offset = 0;\n\n        for (uint16_t i = 0; i < packet_header->num_records; ++i) {\n            if (current_raw_read_offset + sizeof(LogRecordHeader) > raw_packet_len) {\n                return false;\n            }\n            const LogRecordHeader* record_header = reinterpret_cast<const LogRecordHeader*>(raw_packet + current_raw_read_offset);\n\n            uint16_t record_data_len = record_header->data_size;\n\n            for (uint16_t j = 0; j < record_data_len; ++j) {\n                internal_log_buffer[current_internal_write_offset + j] = raw_packet[current_raw_read_offset + sizeof(LogRecordHeader) + j];\n            }\n\n            current_raw_read_offset += sizeof(LogRecordHeader) + record_data_len;\n            current_internal_write_offset += record_data_len;\n\n            if (current_raw_read_offset > raw_packet_len) {\n                return false;\n            }\n        }\n\n        if (current_internal_write_offset > allocated_buffer_size) {\n            return false;\n        }\n        \n        if (current_internal_write_offset != packet_header->total_expected_payload_bytes) {\n            return false;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getLogBuffer() const {\n        return internal_log_buffer;\n    }\n\n    size_t getAllocatedSize() const {\n        return allocated_buffer_size;\n    }\n\nprivate:\n    uint8_t* internal_log_buffer;\n    size_t allocated_buffer_size;\n};\n",
    "fixed_code": "#include <cstdint>\n#include <cstddef>\n#include <new>\n#include <algorithm>\n\ntypedef struct {\n    uint16_t record_id;\n    uint16_t data_size; \n} LogRecordHeader;\n\ntypedef struct {\n    uint32_t total_expected_payload_bytes; \n    uint16_t num_records;       \n} LogPacketHeader;\n\nclass VehicleLogProcessorFixed {\npublic:\n    VehicleLogProcessorFixed() :\n        internal_log_buffer(nullptr),\n        allocated_buffer_size(0) {}\n\n    ~VehicleLogProcessorFixed() {\n        if (internal_log_buffer) {\n            delete[] internal_log_buffer;\n            internal_log_buffer = nullptr;\n        }\n    }\n\n    bool processLogPacketFixed(const uint8_t* raw_packet, size_t raw_packet_len) {\n        if (!raw_packet || raw_packet_len < sizeof(LogPacketHeader)) {\n            return false;\n        }\n\n        const LogPacketHeader* packet_header = reinterpret_cast<const LogPacketHeader*>(raw_packet);\n\n        static const uint32_t MAX_EXPECTED_PAYLOAD_SIZE = 16 * 1024; \n        if (packet_header->total_expected_payload_bytes == 0 || packet_header->total_expected_payload_bytes > MAX_EXPECTED_PAYLOAD_SIZE) {\n            return false;\n        }\n\n        if (raw_packet_len < (sizeof(LogPacketHeader) + packet_header->total_expected_payload_bytes)) {\n            return false;\n        }\n\n        if (internal_log_buffer) {\n            delete[] internal_log_buffer;\n        }\n        internal_log_buffer = new (std::nothrow) uint8_t[packet_header->total_expected_payload_bytes];\n        if (!internal_log_buffer) {\n            return false;\n        }\n        allocated_buffer_size = packet_header->total_expected_payload_bytes;\n\n        size_t current_raw_read_offset = sizeof(LogPacketHeader);\n        size_t current_internal_write_offset = 0;\n\n        for (uint16_t i = 0; i < packet_header->num_records; ++i) {\n            if (current_raw_read_offset + sizeof(LogRecordHeader) > raw_packet_len) {\n                return false;\n            }\n            const LogRecordHeader* record_header = reinterpret_cast<const LogRecordHeader*>(raw_packet + current_raw_read_offset);\n\n            uint16_t record_data_len = record_header->data_size;\n\n            if (current_raw_read_offset + sizeof(LogRecordHeader) + record_data_len > raw_packet_len) {\n                return false;\n            }\n\n            if (current_internal_write_offset + record_data_len > allocated_buffer_size) {\n                return false;\n            }\n\n            for (uint16_t j = 0; j < record_data_len; ++j) {\n                internal_log_buffer[current_internal_write_offset + j] = raw_packet[current_raw_read_offset + sizeof(LogRecordHeader) + j];\n            }\n\n            current_raw_read_offset += sizeof(LogRecordHeader) + record_data_len;\n            current_internal_write_offset += record_data_len;\n        }\n\n        if (current_internal_write_offset != packet_header->total_expected_payload_bytes) {\n            return false;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getLogBuffer() const {\n        return internal_log_buffer;\n    }\n\n    size_t getAllocatedSize() const {\n        return allocated_buffer_size;\n    }\n\nprivate:\n    uint8_t* internal_log_buffer;\n    size_t allocated_buffer_size;\n};\n",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstddef>\n#include <new>\n#include <cstring>\n\ntypedef struct {\n    uint16_t param_id;\n    uint32_t payload_len;\n} ParameterHeader;\n\nclass VehicleDataAggregator {\npublic:\n    VehicleDataAggregator() : m_aggregated_data(nullptr), m_current_total_bytes(0), m_allocated_capacity_bytes(0) {}\n\n    ~VehicleDataAggregator() {\n        clear();\n    }\n\n    void clear() {\n        if (m_aggregated_data) {\n            delete[] m_aggregated_data;\n            m_aggregated_data = nullptr;\n        }\n        m_current_total_bytes = 0;\n        m_allocated_capacity_bytes = 0;\n    }\n\n    bool appendParameterBlockVulnerable(const uint8_t* raw_param_block, size_t block_length) {\n        if (!raw_param_block || block_length < sizeof(ParameterHeader)) {\n            return false;\n        }\n\n        const ParameterHeader* header = reinterpret_cast<const ParameterHeader*>(raw_param_block);\n        uint32_t incoming_payload_len = header->payload_len;\n\n        uint32_t required_new_total_size = m_current_total_bytes + incoming_payload_len; \n\n        if (block_length < sizeof(ParameterHeader) + incoming_payload_len) {\n            return false;\n        }\n        \n        if (required_new_total_size > m_allocated_capacity_bytes) {\n            uint8_t* new_buffer = new (std::nothrow) uint8_t[required_new_total_size];\n            if (!new_buffer) {\n                return false;\n            }\n            if (m_aggregated_data) {\n                memcpy(new_buffer, m_aggregated_data, m_current_total_bytes);\n                delete[] m_aggregated_data;\n            }\n            m_aggregated_data = new_buffer;\n            m_allocated_capacity_bytes = required_new_total_size;\n        }\n\n        memcpy(m_aggregated_data + m_current_total_bytes, raw_param_block + sizeof(ParameterHeader), incoming_payload_len);\n\n        m_current_total_bytes = required_new_total_size;\n\n        return true;\n    }\n\n    const uint8_t* getAggregatedData() const {\n        return m_aggregated_data;\n    }\n\n    uint32_t getTotalAggregatedBytes() const {\n        return m_current_total_bytes;\n    }\n\nprivate:\n    uint8_t* m_aggregated_data;\n    uint32_t m_current_total_bytes;\n    uint32_t m_allocated_capacity_bytes;\n};",
    "fixed_code": "#include <cstdint>\n#include <cstddef>\n#include <new>\n#include <cstring>\n#include <limits>\n\ntypedef struct {\n    uint16_t param_id;\n    uint32_t payload_len;\n} ParameterHeader;\n\nclass VehicleDataAggregator {\npublic:\n    VehicleDataAggregator() : m_aggregated_data(nullptr), m_current_total_bytes(0), m_allocated_capacity_bytes(0) {}\n\n    ~VehicleDataAggregator() {\n        clear();\n    }\n\n    void clear() {\n        if (m_aggregated_data) {\n            delete[] m_aggregated_data;\n            m_aggregated_data = nullptr;\n        }\n        m_current_total_bytes = 0;\n        m_allocated_capacity_bytes = 0;\n    }\n\n    bool appendParameterBlockFixed(const uint8_t* raw_param_block, size_t block_length) {\n        if (!raw_param_block || block_length < sizeof(ParameterHeader)) {\n            return false;\n        }\n\n        const ParameterHeader* header = reinterpret_cast<const ParameterHeader*>(raw_param_block);\n        uint32_t incoming_payload_len = header->payload_len;\n\n        if (std::numeric_limits<uint32_t>::max() - incoming_payload_len < m_current_total_bytes) {\n            return false;\n        }\n\n        uint32_t required_new_total_size = m_current_total_bytes + incoming_payload_len; \n\n        if (block_length < sizeof(ParameterHeader) + incoming_payload_len) {\n            return false;\n        }\n        \n        if (required_new_total_size > m_allocated_capacity_bytes) {\n            uint8_t* new_buffer = new (std::nothrow) uint8_t[required_new_total_size];\n            if (!new_buffer) {\n                return false;\n            }\n            if (m_aggregated_data) {\n                memcpy(new_buffer, m_aggregated_data, m_current_total_bytes);\n                delete[] m_aggregated_data;\n            }\n            m_aggregated_data = new_buffer;\n            m_allocated_capacity_bytes = required_new_total_size;\n        }\n\n        memcpy(m_aggregated_data + m_current_total_bytes, raw_param_block + sizeof(ParameterHeader), incoming_payload_len);\n\n        m_current_total_bytes = required_new_total_size;\n\n        return true;\n    }\n\n    const uint8_t* getAggregatedData() const {\n        return m_aggregated_data;\n    }\n\n    uint32_t getTotalAggregatedBytes() const {\n        return m_current_total_bytes;\n    }\n\nprivate:\n    uint8_t* m_aggregated_data;\n    uint32_t m_current_total_bytes;\n    uint32_t m_allocated_capacity_bytes;\n};",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <stdint.h>\n#include <stdlib.h>\n\n#define CHUNK_SIZE_BYTES 64\n\ntypedef struct {\n    uint32_t block_id;\n    uint32_t num_chunks; \n    uint32_t reserved; \n} DataBlockHeader;\n\nclass FirmwareUpdaterVulnerable {\npublic:\n    FirmwareUpdaterVulnerable() : firmware_buffer(nullptr), current_buffer_size(0) {}\n\n    ~FirmwareUpdaterVulnerable() {\n        if (firmware_buffer) {\n            free(firmware_buffer);\n            firmware_buffer = nullptr;\n        }\n    }\n\n    bool processFirmwareBlockVulnerable(const uint8_t* block_data, size_t data_len) {\n        if (!block_data || data_len < sizeof(DataBlockHeader)) {\n            return false;\n        }\n\n        const DataBlockHeader* header = reinterpret_cast<const DataBlockHeader*>(block_data);\n        uint32_t num_chunks = header->num_chunks;\n\n        uint32_t total_payload_size = num_chunks * CHUNK_SIZE_BYTES;\n\n        if (data_len < sizeof(DataBlockHeader) + total_payload_size) {\n            return false;\n        }\n\n        if (firmware_buffer) {\n            free(firmware_buffer);\n            firmware_buffer = nullptr;\n        }\n\n        firmware_buffer = (uint8_t*)malloc(total_payload_size);\n        if (!firmware_buffer) {\n            return false;\n        }\n        current_buffer_size = total_payload_size;\n\n        const uint8_t* source_data_ptr = block_data + sizeof(DataBlockHeader);\n        for (uint32_t i = 0; i < total_payload_size; ++i) {\n            firmware_buffer[i] = source_data_ptr[i];\n        }\n\n        return true;\n    }\n\n    const uint8_t* getFirmwareBuffer() const { return firmware_buffer; }\n    size_t getBufferSize() const { return current_buffer_size; }\n\nprivate:\n    uint8_t* firmware_buffer;\n    size_t current_buffer_size;\n};",
    "fixed_code": "#include <stdint.h>\n#include <stdlib.h>\n#include <limits> \n\n#define CHUNK_SIZE_BYTES 64\n\ntypedef struct {\n    uint32_t block_id;\n    uint32_t num_chunks; \n    uint32_t reserved; \n} DataBlockHeader;\n\nclass FirmwareUpdaterFixed {\npublic:\n    FirmwareUpdaterFixed() : firmware_buffer(nullptr), current_buffer_size(0) {}\n\n    ~FirmwareUpdaterFixed() {\n        if (firmware_buffer) {\n            free(firmware_buffer);\n            firmware_buffer = nullptr;\n        }\n    }\n\n    bool processFirmwareBlockFixed(const uint8_t* block_data, size_t data_len) {\n        if (!block_data || data_len < sizeof(DataBlockHeader)) {\n            return false;\n        }\n\n        const DataBlockHeader* header = reinterpret_cast<const DataBlockHeader*>(block_data);\n        uint32_t num_chunks = header->num_chunks;\n\n        if (CHUNK_SIZE_BYTES == 0 || num_chunks > (std::numeric_limits<uint32_t>::max() / CHUNK_SIZE_BYTES)) {\n            return false;\n        }\n\n        uint32_t total_payload_size = num_chunks * CHUNK_SIZE_BYTES;\n\n        if (data_len < sizeof(DataBlockHeader) + total_payload_size) {\n            return false;\n        }\n\n        if (firmware_buffer) {\n            free(firmware_buffer);\n            firmware_buffer = nullptr;\n        }\n\n        firmware_buffer = (uint8_t*)malloc(total_payload_size);\n        if (!firmware_buffer) {\n            return false;\n        }\n        current_buffer_size = total_payload_size;\n\n        const uint8_t* source_data_ptr = block_data + sizeof(DataBlockHeader);\n        for (uint32_t i = 0; i < total_payload_size; ++i) {\n            firmware_buffer[i] = source_data_ptr[i];\n        }\n\n        return true;\n    }\n\n    const uint8_t* getFirmwareBuffer() const { return firmware_buffer; }\n    size_t getBufferSize() const { return current_buffer_size; }\n\nprivate:\n    uint8_t* firmware_buffer;\n    size_t current_buffer_size;\n};",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstddef>\n#include <vector>\n#include <new>\n\nstruct DiagnosticLogEntry {\n    uint32_t timestamp;\n    uint16_t event_code;\n    char*    description;\n    size_t   description_buffer_capacity;\n};\n\nstruct LogBatchPacketHeader {\n    uint16_t num_messages;\n    uint16_t global_max_description_len;\n    uint32_t total_payload_bytes;\n};\n\nstruct IndividualMessageData {\n    uint32_t timestamp;\n    uint16_t event_code;\n    uint16_t actual_description_len;\n};\n\nclass DiagnosticLogger {\npublic:\n    DiagnosticLogger() = default;\n\n    ~DiagnosticLogger() {\n        clearLogEntries();\n    }\n\n    void clearLogEntries() {\n        for (auto& entry : m_log_entries) {\n            if (entry.description) {\n                delete[] entry.description;\n            }\n        }\n        m_log_entries.clear();\n    }\n\n    bool processLogBatchVulnerable(const uint8_t* packet_data, size_t packet_length) {\n        if (!packet_data || packet_length < sizeof(LogBatchPacketHeader)) {\n            return false;\n        }\n\n        const LogBatchPacketHeader* header = reinterpret_cast<const LogBatchPacketHeader*>(packet_data);\n\n        if (header->total_payload_bytes > (packet_length - sizeof(LogBatchPacketHeader))) {\n            return false;\n        }\n\n        clearLogEntries();\n\n        const uint8_t* current_payload_ptr = packet_data + sizeof(LogBatchPacketHeader);\n        size_t remaining_payload_data = header->total_payload_bytes;\n\n        for (uint16_t i = 0; i < header->num_messages; ++i) {\n            if (remaining_payload_data < sizeof(IndividualMessageData)) {\n                return false;\n            }\n\n            const IndividualMessageData* msg_header = reinterpret_cast<const IndividualMessageData*>(current_payload_ptr);\n            \n            size_t alloc_size_for_description = header->global_max_description_len + 1;\n            if (alloc_size_for_description == 0) {\n                 alloc_size_for_description = 1;\n            }\n            \n            DiagnosticLogEntry new_entry;\n            new_entry.timestamp = msg_header->timestamp;\n            new_entry.event_code = msg_header->event_code;\n            new_entry.description = new (std::nothrow) char[alloc_size_for_description];\n            new_entry.description_buffer_capacity = alloc_size_for_description;\n\n            if (!new_entry.description) {\n                clearLogEntries();\n                return false;\n            }\n\n            current_payload_ptr += sizeof(IndividualMessageData);\n            remaining_payload_data -= sizeof(IndividualMessageData);\n\n            if (remaining_payload_data < msg_header->actual_description_len) {\n                delete[] new_entry.description;\n                return false;\n            }\n            \n            for (uint16_t k = 0; k < msg_header->actual_description_len; ++k) {\n                new_entry.description[k] = static_cast<char>(current_payload_ptr[k]);\n            }\n            new_entry.description[msg_header->actual_description_len] = '\\0';\n\n            current_payload_ptr += msg_header->actual_description_len;\n            remaining_payload_data -= msg_header->actual_description_len;\n\n            m_log_entries.push_back(new_entry);\n        }\n\n        return true;\n    }\n\n    const std::vector<DiagnosticLogEntry>& getLogEntries() const {\n        return m_log_entries;\n    }\n\nprivate:\n    std::vector<DiagnosticLogEntry> m_log_entries;\n};",
    "fixed_code": "#include <cstdint>\n#include <cstddef>\n#include <vector>\n#include <new>\n#include <algorithm>\n\nstruct DiagnosticLogEntry {\n    uint32_t timestamp;\n    uint16_t event_code;\n    char*    description;\n    size_t   description_buffer_capacity;\n};\n\nstruct LogBatchPacketHeader {\n    uint16_t num_messages;\n    uint16_t global_max_description_len;\n    uint32_t total_payload_bytes;\n};\n\nstruct IndividualMessageData {\n    uint32_t timestamp;\n    uint16_t event_code;\n    uint16_t actual_description_len;\n};\n\nclass DiagnosticLogger {\npublic:\n    DiagnosticLogger() = default;\n\n    ~DiagnosticLogger() {\n        clearLogEntries();\n    }\n\n    void clearLogEntries() {\n        for (auto& entry : m_log_entries) {\n            if (entry.description) {\n                delete[] entry.description;\n            }\n        }\n        m_log_entries.clear();\n    }\n\n    bool processLogBatchFixed(const uint8_t* packet_data, size_t packet_length) {\n        if (!packet_data || packet_length < sizeof(LogBatchPacketHeader)) {\n            return false;\n        }\n\n        const LogBatchPacketHeader* header = reinterpret_cast<const LogBatchPacketHeader*>(packet_data);\n\n        if (header->total_payload_bytes > (packet_length - sizeof(LogBatchPacketHeader))) {\n            return false;\n        }\n\n        static const uint16_t MAX_SINGLE_DESCRIPTION_HARD_LIMIT = 511;\n        if (header->global_max_description_len > MAX_SINGLE_DESCRIPTION_HARD_LIMIT) {\n            return false;\n        }\n        \n        clearLogEntries();\n\n        const uint8_t* current_payload_ptr = packet_data + sizeof(LogBatchPacketHeader);\n        size_t remaining_payload_data = header->total_payload_bytes;\n\n        for (uint16_t i = 0; i < header->num_messages; ++i) {\n            if (remaining_payload_data < sizeof(IndividualMessageData)) {\n                return false;\n            }\n\n            const IndividualMessageData* msg_header = reinterpret_cast<const IndividualMessageData*>(current_payload_ptr);\n\n            if (msg_header->actual_description_len > MAX_SINGLE_DESCRIPTION_HARD_LIMIT) {\n                return false;\n            }\n\n            if (remaining_payload_data - sizeof(IndividualMessageData) < msg_header->actual_description_len) {\n                return false;\n            }\n\n            size_t alloc_size_for_description = header->global_max_description_len + 1;\n            if (alloc_size_for_description == 0) {\n                 alloc_size_for_description = 1;\n            }\n\n            DiagnosticLogEntry new_entry;\n            new_entry.timestamp = msg_header->timestamp;\n            new_entry.event_code = msg_header->event_code;\n            new_entry.description = new (std::nothrow) char[alloc_size_for_description];\n            new_entry.description_buffer_capacity = alloc_size_for_description;\n\n            if (!new_entry.description) {\n                clearLogEntries();\n                return false;\n            }\n\n            current_payload_ptr += sizeof(IndividualMessageData);\n            remaining_payload_data -= sizeof(IndividualMessageData);\n\n            size_t bytes_to_copy = std::min({\n                static_cast<size_t>(msg_header->actual_description_len),\n                static_cast<size_t>(alloc_size_for_description - 1),\n                remaining_payload_data\n            });\n            \n            for (size_t k = 0; k < bytes_to_copy; ++k) {\n                new_entry.description[k] = static_cast<char>(current_payload_ptr[k]);\n            }\n            new_entry.description[bytes_to_copy] = '\\0';\n\n            current_payload_ptr += msg_header->actual_description_len;\n            remaining_payload_data -= msg_header->actual_description_len;\n\n            m_log_entries.push_back(new_entry);\n        }\n\n        return true;\n    }\n\n    const std::vector<DiagnosticLogEntry>& getLogEntries() const {\n        return m_log_entries;\n    }\n\nprivate:\n    std::vector<DiagnosticLogEntry> m_log_entries;\n};",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n\n#define MAX_CONFIG_PAYLOAD_SIZE 4096\n\ntypedef struct {\n    uint16_t total_payload_size;\n    uint16_t num_entries;\n} PacketHeaderVulnerable;\n\ntypedef struct {\n    uint16_t entry_id;\n    uint16_t data_length;\n} ConfigEntryHeaderVulnerable;\n\nclass VehicleConfigProcessorVulnerable {\npublic:\n    VehicleConfigProcessorVulnerable() : processed_config_data(nullptr), current_data_offset(0) {}\n\n    ~VehicleConfigProcessorVulnerable() {\n        if (processed_config_data) {\n            free(processed_config_data);\n            processed_config_data = nullptr;\n        }\n    }\n\n    bool processConfigPacketVulnerable(const uint8_t* raw_packet, size_t raw_len) {\n        if (processed_config_data) {\n            free(processed_config_data);\n            processed_config_data = nullptr;\n        }\n\n        if (!raw_packet || raw_len < sizeof(PacketHeaderVulnerable)) {\n            return false;\n        }\n\n        const PacketHeaderVulnerable* pkt_header = reinterpret_cast<const PacketHeaderVulnerable*>(raw_packet);\n\n        if (pkt_header->total_payload_size > MAX_CONFIG_PAYLOAD_SIZE || pkt_header->total_payload_size == 0) {\n            return false;\n        }\n\n        size_t expected_min_raw_len = sizeof(PacketHeaderVulnerable) + (size_t)pkt_header->num_entries * sizeof(ConfigEntryHeaderVulnerable);\n        if (raw_len < expected_min_raw_len) {\n            return false;\n        }\n\n        processed_config_data = (uint8_t*)malloc(pkt_header->total_payload_size);\n        if (!processed_config_data) {\n            return false;\n        }\n        current_data_offset = 0;\n\n        size_t current_parse_offset = sizeof(PacketHeaderVulnerable);\n\n        for (uint16_t i = 0; i < pkt_header->num_entries; ++i) {\n            if (current_parse_offset + sizeof(ConfigEntryHeaderVulnerable) > raw_len) {\n                free(processed_config_data); processed_config_data = nullptr;\n                return false;\n            }\n\n            const ConfigEntryHeaderVulnerable* entry_header = \n                reinterpret_cast<const ConfigEntryHeaderVulnerable*>(raw_packet + current_parse_offset);\n            \n            if (current_parse_offset + sizeof(ConfigEntryHeaderVulnerable) + entry_header->data_length > raw_len) {\n                free(processed_config_data); processed_config_data = nullptr;\n                return false;\n            }\n\n            \n            for (uint16_t k = 0; k < entry_header->data_length; ++k) {\n                processed_config_data[current_data_offset + k] = \n                    raw_packet[current_parse_offset + sizeof(ConfigEntryHeaderVulnerable) + k];\n            }\n            current_data_offset += entry_header->data_length;\n            current_parse_offset += sizeof(ConfigEntryHeaderVulnerable) + entry_header->data_length;\n        }\n        \n        if (current_data_offset != pkt_header->total_payload_size) {\n            free(processed_config_data); processed_config_data = nullptr;\n            return false;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getProcessedConfigData() const { return processed_config_data; }\n    size_t getProcessedDataLength() const { return current_data_offset; }\n\nprivate:\n    uint8_t* processed_config_data;\n    size_t current_data_offset;\n};\n",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n\n#define MAX_CONFIG_PAYLOAD_SIZE 4096\n\ntypedef struct {\n    uint16_t total_payload_size;\n    uint16_t num_entries;\n} PacketHeaderFixed;\n\ntypedef struct {\n    uint16_t entry_id;\n    uint16_t data_length;\n} ConfigEntryHeaderFixed;\n\nclass VehicleConfigProcessorFixed {\npublic:\n    VehicleConfigProcessorFixed() : processed_config_data(nullptr), current_data_offset(0), allocated_payload_size(0) {}\n\n    ~VehicleConfigProcessorFixed() {\n        if (processed_config_data) {\n            free(processed_config_data);\n            processed_config_data = nullptr;\n        }\n    }\n\n    bool processConfigPacketFixed(const uint8_t* raw_packet, size_t raw_len) {\n        if (processed_config_data) {\n            free(processed_config_data);\n            processed_config_data = nullptr;\n            allocated_payload_size = 0;\n        }\n\n        if (!raw_packet || raw_len < sizeof(PacketHeaderFixed)) {\n            return false;\n        }\n\n        const PacketHeaderFixed* pkt_header = reinterpret_cast<const PacketHeaderFixed*>(raw_packet);\n\n        if (pkt_header->total_payload_size > MAX_CONFIG_PAYLOAD_SIZE || pkt_header->total_payload_size == 0) {\n            return false;\n        }\n        \n        size_t expected_min_raw_len = sizeof(PacketHeaderFixed) + (size_t)pkt_header->num_entries * sizeof(ConfigEntryHeaderFixed);\n        if (raw_len < expected_min_raw_len) {\n            return false;\n        }\n\n        processed_config_data = (uint8_t*)malloc(pkt_header->total_payload_size);\n        if (!processed_config_data) {\n            allocated_payload_size = 0;\n            return false;\n        }\n        allocated_payload_size = pkt_header->total_payload_size;\n        current_data_offset = 0;\n\n        size_t current_parse_offset = sizeof(PacketHeaderFixed);\n\n        for (uint16_t i = 0; i < pkt_header->num_entries; ++i) {\n            if (current_parse_offset + sizeof(ConfigEntryHeaderFixed) > raw_len) {\n                free(processed_config_data); processed_config_data = nullptr; allocated_payload_size = 0;\n                return false;\n            }\n\n            const ConfigEntryHeaderFixed* entry_header = \n                reinterpret_cast<const ConfigEntryHeaderFixed*>(raw_packet + current_parse_offset);\n            \n            if (entry_header->data_length > allocated_payload_size - current_data_offset) {\n                free(processed_config_data); processed_config_data = nullptr; allocated_payload_size = 0;\n                return false;\n            }\n\n            if (current_parse_offset + sizeof(ConfigEntryHeaderFixed) + entry_header->data_length > raw_len) {\n                free(processed_config_data); processed_config_data = nullptr; allocated_payload_size = 0;\n                return false;\n            }\n            \n            for (uint16_t k = 0; k < entry_header->data_length; ++k) {\n                processed_config_data[current_data_offset + k] = \n                    raw_packet[current_parse_offset + sizeof(ConfigEntryHeaderFixed) + k];\n            }\n            current_data_offset += entry_header->data_length;\n            current_parse_offset += sizeof(ConfigEntryHeaderFixed) + entry_header->data_length;\n        }\n        \n        if (current_data_offset != pkt_header->total_payload_size) {\n            free(processed_config_data); processed_config_data = nullptr; allocated_payload_size = 0;\n            return false;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getProcessedConfigData() const { return processed_config_data; }\n    size_t getProcessedDataLength() const { return current_data_offset; }\n\nprivate:\n    uint8_t* processed_config_data;\n    size_t current_data_offset;\n    size_t allocated_payload_size;\n};\n",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <string.h>\n\nstruct DiagnosticEvent {\n    uint32_t timestamp;\n    uint16_t event_code;\n    char*    details;\n};\n\nclass DiagnosticEventRecorderVulnerable {\nprivate:\n    DiagnosticEvent* m_events;\n    size_t m_event_count;\n    size_t m_capacity;\n\npublic:\n    DiagnosticEventRecorderVulnerable() : m_events(nullptr), m_event_count(0), m_capacity(0) {\n        m_capacity = 10; \n        m_events = (DiagnosticEvent*)malloc(m_capacity * sizeof(DiagnosticEvent));\n        if (!m_events) {\n            m_capacity = 0;\n        }\n    }\n\n    ~DiagnosticEventRecorderVulnerable() {\n        for (size_t i = 0; i < m_event_count; ++i) {\n            if (m_events[i].details) {\n                free(m_events[i].details);\n            }\n        }\n        if (m_events) {\n            free(m_events);\n        }\n    }\n\n    bool addEventVulnerable(uint32_t timestamp, uint16_t event_code, const char* details_str, uint16_t details_len_from_packet) {\n        if (!details_str || details_len_from_packet == 0) {\n            return false;\n        }\n        \n        if (details_len_from_packet > 255) { \n            return false;\n        }\n\n        if (m_event_count >= m_capacity) {\n            size_t new_capacity = m_capacity * 2;\n            if (new_capacity == 0) new_capacity = 1; \n            DiagnosticEvent* new_events = (DiagnosticEvent*)realloc(m_events, new_capacity * sizeof(DiagnosticEvent));\n            if (!new_events) {\n                return false;\n            }\n            m_events = new_events;\n            m_capacity = new_capacity;\n        }\n\n        DiagnosticEvent new_event;\n        new_event.timestamp = timestamp;\n        new_event.event_code = event_code;\n\n        new_event.details = (char*)malloc(details_len_from_packet);\n        if (!new_event.details) {\n            return false;\n        }\n\n        for (uint16_t i = 0; i < details_len_from_packet; ++i) {\n            new_event.details[i] = details_str[i];\n        }\n        new_event.details[details_len_from_packet] = '\\0';\n\n        m_events[m_event_count++] = new_event;\n        return true;\n    }\n\n    size_t getEventCount() const { return m_event_count; }\n    const DiagnosticEvent* getEvent(size_t index) const {\n        if (index < m_event_count) return &m_events[index];\n        return nullptr;\n    }\n}",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <string.h>\n\nstruct DiagnosticEvent {\n    uint32_t timestamp;\n    uint16_t event_code;\n    char*    details;\n};\n\nclass DiagnosticEventRecorderFixed {\nprivate:\n    DiagnosticEvent* m_events;\n    size_t m_event_count;\n    size_t m_capacity;\n\npublic:\n    DiagnosticEventRecorderFixed() : m_events(nullptr), m_event_count(0), m_capacity(0) {\n        m_capacity = 10; \n        m_events = (DiagnosticEvent*)malloc(m_capacity * sizeof(DiagnosticEvent));\n        if (!m_events) {\n            m_capacity = 0;\n        }\n    }\n\n    ~DiagnosticEventRecorderFixed() {\n        for (size_t i = 0; i < m_event_count; ++i) {\n            if (m_events[i].details) {\n                free(m_events[i].details);\n            }\n        }\n        if (m_events) {\n            free(m_events);\n        }\n    }\n\n    bool addEventFixed(uint32_t timestamp, uint16_t event_code, const char* details_str, uint16_t details_len_from_packet) {\n        if (!details_str || details_len_from_packet == 0) {\n            return false;\n        }\n        \n        if (details_len_from_packet > 255) {\n            return false;\n        }\n\n        if (m_event_count >= m_capacity) {\n            size_t new_capacity = m_capacity * 2;\n            if (new_capacity == 0) new_capacity = 1;\n            DiagnosticEvent* new_events = (DiagnosticEvent*)realloc(m_events, new_capacity * sizeof(DiagnosticEvent));\n            if (!new_events) {\n                return false;\n            }\n            m_events = new_events;\n            m_capacity = new_capacity;\n        }\n\n        DiagnosticEvent new_event;\n        new_event.timestamp = timestamp;\n        new_event.event_code = event_code;\n\n        new_event.details = (char*)malloc(details_len_from_packet + 1);\n        if (!new_event.details) {\n            return false;\n        }\n        \n        for (uint16_t i = 0; i < details_len_from_packet; ++i) {\n            new_event.details[i] = details_str[i];\n        }\n        new_event.details[details_len_from_packet] = '\\0';\n\n        m_events[m_event_count++] = new_event;\n        return true;\n    }\n\n    size_t getEventCount() const { return m_event_count; }\n    const DiagnosticEvent* getEvent(size_t index) const {\n        if (index < m_event_count) return &m_events[index];\n        return nullptr;\n    }\n};",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n\ntypedef struct {\n    uint32_t timestamp;\n    uint16_t event_id;\n    uint16_t details_length_bytes;\n} EventLogHeader;\n\nclass VehicleEventLogger {\npublic:\n    VehicleEventLogger() : m_log_buffer(nullptr), m_current_buffer_pos(0), m_allocated_capacity(0) {}\n\n    ~VehicleEventLogger() {\n        if (m_log_buffer) {\n            free(m_log_buffer);\n        }\n    }\n\n    void clearLogs() {\n        if (m_log_buffer) {\n            free(m_log_buffer);\n        }\n        m_log_buffer = nullptr;\n        m_current_buffer_pos = 0;\n        m_allocated_capacity = 0;\n    }\n\n    bool appendEventVulnerable(const uint8_t* raw_event_data, size_t data_packet_length) {\n        if (!raw_event_data || data_packet_length < sizeof(EventLogHeader)) {\n            return false;\n        }\n\n        const EventLogHeader* header = reinterpret_cast<const EventLogHeader*>(raw_event_data);\n        uint16_t details_len = header->details_length_bytes;\n\n        if (data_packet_length < sizeof(EventLogHeader) + details_len) {\n            return false;\n        }\n\n        size_t current_record_size_raw = sizeof(EventLogHeader) + details_len;\n        size_t padded_details_len = (details_len + 3) & ~3;\n        \n        size_t required_total_size = m_current_buffer_pos + current_record_size_raw;\n\n        if (required_total_size < m_current_buffer_pos) {\n            return false;\n        }\n        \n        if (required_total_size > m_allocated_capacity) {\n            size_t new_capacity = required_total_size;\n            if (new_capacity < 256) new_capacity = 256;\n            if (new_capacity < required_total_size) new_capacity = required_total_size;\n\n            uint8_t* temp_buffer = (uint8_t*)realloc(m_log_buffer, new_capacity);\n            if (!temp_buffer) {\n                if (m_log_buffer) {\n                    free(m_log_buffer);\n                    m_log_buffer = nullptr;\n                }\n                m_allocated_capacity = 0;\n                m_current_buffer_pos = 0;\n                return false;\n            }\n            m_log_buffer = temp_buffer;\n            m_allocated_capacity = new_capacity;\n        }\n\n        for (size_t i = 0; i < sizeof(EventLogHeader); ++i) {\n            m_log_buffer[m_current_buffer_pos + i] = raw_event_data[i];\n        }\n\n        const uint8_t* details_src_ptr = raw_event_data + sizeof(EventLogHeader);\n        uint8_t* details_dest_ptr = m_log_buffer + m_current_buffer_pos + sizeof(EventLogHeader);\n\n        for (uint16_t i = 0; i < details_len; ++i) {\n            details_dest_ptr[i] = details_src_ptr[i];\n        }\n\n        size_t padding_bytes = padded_details_len - details_len;\n        if (padding_bytes > 0) {\n            memset(details_dest_ptr + details_len, 0, padding_bytes);\n        }\n\n        m_current_buffer_pos += (sizeof(EventLogHeader) + padded_details_len);\n\n        return true;\n    }\n\n    size_t getTotalLoggedBytes() const {\n        return m_current_buffer_pos;\n    }\n\nprivate:\n    uint8_t* m_log_buffer;\n    size_t   m_current_buffer_pos;\n    size_t   m_allocated_capacity;\n}",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n\ntypedef struct {\n    uint32_t timestamp;\n    uint16_t event_id;\n    uint16_t details_length_bytes;\n} EventLogHeader;\n\nclass VehicleEventLogger {\npublic:\n    VehicleEventLogger() : m_log_buffer(nullptr), m_current_buffer_pos(0), m_allocated_capacity(0) {}\n\n    ~VehicleEventLogger() {\n        if (m_log_buffer) {\n            free(m_log_buffer);\n        }\n    }\n\n    void clearLogs() {\n        if (m_log_buffer) {\n            free(m_log_buffer);\n        }\n        m_log_buffer = nullptr;\n        m_current_buffer_pos = 0;\n        m_allocated_capacity = 0;\n    }\n\n    bool appendEventFixed(const uint8_t* raw_event_data, size_t data_packet_length) {\n        if (!raw_event_data || data_packet_length < sizeof(EventLogHeader)) {\n            return false;\n        }\n\n        const EventLogHeader* header = reinterpret_cast<const EventLogHeader*>(raw_event_data);\n        uint16_t details_len = header->details_length_bytes;\n\n        static const uint16_t MAX_DETAILS_LENGTH = 4096;\n        if (details_len > MAX_DETAILS_LENGTH) {\n            return false;\n        }\n\n        if (data_packet_length < sizeof(EventLogHeader) + details_len) {\n            return false;\n        }\n\n        size_t padded_details_len = (details_len + 3) & ~3;\n        size_t current_record_size_padded = sizeof(EventLogHeader) + padded_details_len;\n        \n        size_t required_total_size;\n        if (m_current_buffer_pos > (SIZE_MAX - current_record_size_padded)) { \n            return false; \n        }\n        required_total_size = m_current_buffer_pos + current_record_size_padded;\n        \n        if (required_total_size > m_allocated_capacity) {\n            size_t new_capacity = required_total_size;\n            if (new_capacity < 256) new_capacity = 256;\n            if (new_capacity < required_total_size) new_capacity = required_total_size;\n\n            uint8_t* temp_buffer = (uint8_t*)realloc(m_log_buffer, new_capacity);\n            if (!temp_buffer) {\n                if (m_log_buffer) {\n                    free(m_log_buffer);\n                    m_log_buffer = nullptr;\n                }\n                m_allocated_capacity = 0;\n                m_current_buffer_pos = 0;\n                return false;\n            }\n            m_log_buffer = temp_buffer;\n            m_allocated_capacity = new_capacity;\n        }\n\n        for (size_t i = 0; i < sizeof(EventLogHeader); ++i) {\n            m_log_buffer[m_current_buffer_pos + i] = raw_event_data[i];\n        }\n\n        const uint8_t* details_src_ptr = raw_event_data + sizeof(EventLogHeader);\n        uint8_t* details_dest_ptr = m_log_buffer + m_current_buffer_pos + sizeof(EventLogHeader);\n\n        for (uint16_t i = 0; i < details_len; ++i) {\n            details_dest_ptr[i] = details_src_ptr[i];\n        }\n\n        size_t padding_bytes = padded_details_len - details_len;\n        if (padding_bytes > 0) {\n            memset(details_dest_ptr + details_len, 0, padding_bytes);\n        }\n\n        m_current_buffer_pos += current_record_size_padded;\n\n        return true;\n    }\n\n    size_t getTotalLoggedBytes() const {\n        return m_current_buffer_pos;\n    }\n\nprivate:\n    uint8_t* m_log_buffer;\n    size_t   m_current_buffer_pos;\n    size_t   m_allocated_capacity;\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstddef>\n#include <new>\n#include <cstring>\n\n#pragma pack(push, 1)\n\nstruct VehicleCommandHeader {\n    uint16_t command_id;\n    uint16_t data_length;\n};\n\nstruct CommandBatchHeader {\n    uint32_t batch_id;\n    uint16_t num_commands;\n    uint32_t total_payload_bytes;\n};\n\n#pragma pack(pop)\n\nclass CommandBatchProcessor {\npublic:\n    CommandBatchProcessor() : m_processed_batch_data(nullptr), m_processed_data_size(0) {}\n\n    ~CommandBatchProcessor() {\n        if (m_processed_batch_data) {\n            delete[] m_processed_batch_data;\n            m_processed_batch_data = nullptr;\n        }\n    }\n\n    bool processCommandBatchVulnerable(const uint8_t* raw_batch_data, size_t raw_batch_data_len) {\n        if (!raw_batch_data || raw_batch_data_len < sizeof(CommandBatchHeader)) {\n            return false;\n        }\n\n        const CommandBatchHeader* batch_header = reinterpret_cast<const CommandBatchHeader*>(raw_batch_data);\n\n        if (batch_header->total_payload_bytes > (raw_batch_data_len - sizeof(CommandBatchHeader))) {\n            return false;\n        }\n\n        if (m_processed_batch_data) {\n            delete[] m_processed_batch_data;\n            m_processed_batch_data = nullptr;\n        }\n\n        m_processed_batch_data = new (std::nothrow) uint8_t[batch_header->total_payload_bytes];\n        if (!m_processed_batch_data) {\n            m_processed_data_size = 0;\n            return false;\n        }\n        m_processed_data_size = batch_header->total_payload_bytes;\n\n        size_t current_raw_offset = sizeof(CommandBatchHeader);\n        size_t current_processed_offset = 0;\n\n        for (uint16_t i = 0; i < batch_header->num_commands; ++i) {\n            if (current_raw_offset + sizeof(VehicleCommandHeader) > raw_batch_data_len) {\n                return false;\n            }\n\n            const VehicleCommandHeader* cmd_header = reinterpret_cast<const VehicleCommandHeader*>(raw_batch_data + current_raw_offset);\n            uint16_t current_cmd_data_len = cmd_header->data_length;\n\n            if (current_raw_offset + sizeof(VehicleCommandHeader) + current_cmd_data_len > raw_batch_data_len) {\n                return false;\n            }\n\n            memcpy(m_processed_batch_data + current_processed_offset, cmd_header, sizeof(VehicleCommandHeader));\n            current_processed_offset += sizeof(VehicleCommandHeader);\n\n            memcpy(m_processed_batch_data + current_processed_offset, raw_batch_data + current_raw_offset + sizeof(VehicleCommandHeader), current_cmd_data_len);\n            current_processed_offset += current_cmd_data_len;\n\n            current_raw_offset += sizeof(VehicleCommandHeader) + current_cmd_data_len;\n        }\n\n        if (current_processed_offset > m_processed_data_size) {\n            return false;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getProcessedBatchData() const {\n        return m_processed_batch_data;\n    }\n\n    size_t getProcessedDataSize() const {\n        return m_processed_data_size;\n    }\n\nprivate:\n    uint8_t* m_processed_batch_data;\n    size_t m_processed_data_size;\n};\n",
    "fixed_code": "#include <cstdint>\n#include <cstddef>\n#include <new>\n#include <cstring>\n#include <limits>\n#include <algorithm>\n\n#pragma pack(push, 1)\n\nstruct VehicleCommandHeader {\n    uint16_t command_id;\n    uint16_t data_length;\n};\n\nstruct CommandBatchHeader {\n    uint32_t batch_id;\n    uint16_t num_commands;\n    uint32_t total_payload_bytes;\n};\n\n#pragma pack(pop)\n\nclass CommandBatchProcessorFixed {\npublic:\n    CommandBatchProcessorFixed() : m_processed_batch_data(nullptr), m_processed_data_size(0) {}\n\n    ~CommandBatchProcessorFixed() {\n        if (m_processed_batch_data) {\n            delete[] m_processed_batch_data;\n            m_processed_batch_data = nullptr;\n        }\n    }\n\n    bool processCommandBatchFixed(const uint8_t* raw_batch_data, size_t raw_batch_data_len) {\n        if (!raw_batch_data || raw_batch_data_len < sizeof(CommandBatchHeader)) {\n            return false;\n        }\n\n        const CommandBatchHeader* batch_header = reinterpret_cast<const CommandBatchHeader*>(raw_batch_data);\n\n        static const uint16_t MAX_COMMANDS_IN_BATCH = 100;\n        if (batch_header->num_commands == 0 || batch_header->num_commands > MAX_COMMANDS_IN_BATCH) {\n            return false;\n        }\n\n        uint32_t calculated_total_required_size = 0;\n        size_t temp_raw_offset = sizeof(CommandBatchHeader);\n\n        for (uint16_t i = 0; i < batch_header->num_commands; ++i) {\n            if (temp_raw_offset + sizeof(VehicleCommandHeader) > raw_batch_data_len) {\n                return false;\n            }\n\n            const VehicleCommandHeader* cmd_header = reinterpret_cast<const VehicleCommandHeader*>(raw_batch_data + temp_raw_offset);\n            uint16_t current_cmd_data_len = cmd_header->data_length;\n\n            if (current_cmd_data_len > (std::numeric_limits<uint32_t>::max() - sizeof(VehicleCommandHeader) - calculated_total_required_size)) {\n                return false;\n            }\n\n            calculated_total_required_size += sizeof(VehicleCommandHeader) + current_cmd_data_len;\n\n            temp_raw_offset += sizeof(VehicleCommandHeader) + current_cmd_data_len;\n\n            if (temp_raw_offset > raw_batch_data_len) {\n                return false;\n            }\n        }\n\n        if (batch_header->total_payload_bytes != calculated_total_required_size) {\n            return false;\n        }\n\n        static const uint32_t MAX_BATCH_DATA_SIZE = 64 * 1024;\n        if (calculated_total_required_size == 0 || calculated_total_required_size > MAX_BATCH_DATA_SIZE) {\n            return false;\n        }\n\n        if (m_processed_batch_data) {\n            delete[] m_processed_batch_data;\n            m_processed_batch_data = nullptr;\n        }\n\n        m_processed_batch_data = new (std::nothrow) uint8_t[calculated_total_required_size];\n        if (!m_processed_batch_data) {\n            m_processed_data_size = 0;\n            return false;\n        }\n        m_processed_data_size = calculated_total_required_size;\n\n        size_t current_raw_offset = sizeof(CommandBatchHeader);\n        size_t current_processed_offset = 0;\n\n        for (uint16_t i = 0; i < batch_header->num_commands; ++i) {\n            if (current_raw_offset + sizeof(VehicleCommandHeader) > raw_batch_data_len) {\n                return false;\n            }\n\n            const VehicleCommandHeader* cmd_header = reinterpret_cast<const VehicleCommandHeader*>(raw_batch_data + current_raw_offset);\n            uint16_t current_cmd_data_len = cmd_header->data_length;\n\n            if (current_raw_offset + sizeof(VehicleCommandHeader) + current_cmd_data_len > raw_batch_data_len) {\n                return false;\n            }\n\n            size_t bytes_to_copy_this_command = sizeof(VehicleCommandHeader) + current_cmd_data_len;\n            if (current_processed_offset > (std::numeric_limits<size_t>::max() - bytes_to_copy_this_command) ||\n                current_processed_offset + bytes_to_copy_this_command > m_processed_data_size) {\n                return false;\n            }\n\n            memcpy(m_processed_batch_data + current_processed_offset, cmd_header, sizeof(VehicleCommandHeader));\n            current_processed_offset += sizeof(VehicleCommandHeader);\n\n            memcpy(m_processed_batch_data + current_processed_offset, raw_batch_data + current_raw_offset + sizeof(VehicleCommandHeader), current_cmd_data_len);\n            current_processed_offset += current_cmd_data_len;\n\n            current_raw_offset += sizeof(VehicleCommandHeader) + current_cmd_data_len;\n        }\n\n        if (current_processed_offset != m_processed_data_size) {\n            return false;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getProcessedBatchData() const {\n        return m_processed_batch_data;\n    }\n\n    size_t getProcessedDataSize() const {\n        return m_processed_data_size;\n    }\n\nprivate:\n    uint8_t* m_processed_batch_data;\n    size_t m_processed_data_size;\n};\n",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n\n// Represents a firmware update packet header\nstruct FirmwarePacketHeader {\n    uint32_t packet_magic;\n    uint32_t total_data_payload_size; \n    uint16_t num_modules;\n    uint8_t  _reserved[2];\n};\n\n// Represents a header for an individual firmware module within the payload\nstruct FirmwareModuleHeader {\n    uint16_t module_id;\n    uint16_t module_version;\n    uint32_t module_data_length;\n};\n\nclass FirmwareUpdater {\nprivate:\n    uint8_t* m_firmware_buffer;\n    size_t   m_allocated_size;\n\npublic:\n    FirmwareUpdater() : m_firmware_buffer(nullptr), m_allocated_size(0) {}\n\n    ~FirmwareUpdater() {\n        if (m_firmware_buffer) {\n            free(m_firmware_buffer);\n        }\n    }\n\n    void clearFirmwareBuffer() {\n        if (m_firmware_buffer) {\n            free(m_firmware_buffer);\n            m_firmware_buffer = nullptr;\n            m_allocated_size = 0;\n        }\n    }\n\n    bool processFirmwareUpdatePacketVulnerable(const uint8_t* packet_data, size_t packet_length) {\n        if (!packet_data || packet_length < sizeof(FirmwarePacketHeader)) {\n            return false;\n        }\n\n        const FirmwarePacketHeader* header = reinterpret_cast<const FirmwarePacketHeader*>(packet_data);\n\n        // Initial sanity check: Is the claimed total payload size within packet bounds?\n        // This check is insufficient for the heap overflow as the sum of module lengths might differ.\n        if (header->total_data_payload_size > (packet_length - sizeof(FirmwarePacketHeader))) {\n            return false;\n        }\n\n        clearFirmwareBuffer();\n\n        // Allocate buffer based on the total_data_payload_size from the packet header\n        m_firmware_buffer = (uint8_t*)malloc(header->total_data_payload_size);\n        if (!m_firmware_buffer) {\n            return false;\n        }\n        m_allocated_size = header->total_data_payload_size;\n\n        size_t current_packet_offset = sizeof(FirmwarePacketHeader);\n        size_t current_buffer_write_offset = 0;\n\n        for (uint16_t i = 0; i < header->num_modules; ++i) {\n            // Check if there's enough data in the raw packet for the module header\n            if (current_packet_offset + sizeof(FirmwareModuleHeader) > packet_length) {\n                clearFirmwareBuffer();\n                return false;\n            }\n\n            const FirmwareModuleHeader* module_hdr = reinterpret_cast<const FirmwareModuleHeader*>(packet_data + current_packet_offset);\n\n            // Advance packet offset past the module header\n            current_packet_offset += sizeof(FirmwareModuleHeader);\n            \n            // Check if there's enough data in the raw packet for the module's payload\n            if (current_packet_offset + module_hdr->module_data_length > packet_length) {\n                clearFirmwareBuffer();\n                return false;\n            }\n            \n            // Vulnerability: No check here that (current_buffer_write_offset + module_hdr->module_data_length)\n            // doesn't exceed m_allocated_size (which is header->total_data_payload_size).\n            // An attacker can craft a packet where the sum of module_hdr->module_data_length values\n            // for all modules exceeds header->total_data_payload_size, leading to a heap overflow\n            // during the memcpy, even if individual module_data_length values don't exceed\n            // the remaining packet length at that point.\n            memcpy(m_firmware_buffer + current_buffer_write_offset,\n                   packet_data + current_packet_offset,\n                   module_hdr->module_data_length);\n\n            current_packet_offset += module_hdr->module_data_length;\n            current_buffer_write_offset += module_hdr->module_data_length;\n        }\n        \n        // A check for current_buffer_write_offset > m_allocated_size here would be too late.\n\n        return true;\n    }\n\n    size_t getAllocatedFirmwareSize() const {\n        return m_allocated_size;\n    }\n\n    const uint8_t* getFirmwareBuffer() const {\n        return m_firmware_buffer;\n    }\n};",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n\n// Represents a firmware update packet header\nstruct FirmwarePacketHeader {\n    uint32_t packet_magic;\n    uint32_t total_data_payload_size;\n    uint16_t num_modules;\n    uint8_t  _reserved[2];\n};\n\n// Represents a header for an individual firmware module within the payload\nstruct FirmwareModuleHeader {\n    uint16_t module_id;\n    uint16_t module_version;\n    uint32_t module_data_length;\n};\n\nclass FirmwareUpdater {\nprivate:\n    uint8_t* m_firmware_buffer;\n    size_t   m_allocated_size;\n\npublic:\n    FirmwareUpdater() : m_firmware_buffer(nullptr), m_allocated_size(0) {}\n\n    ~FirmwareUpdater() {\n        if (m_firmware_buffer) {\n            free(m_firmware_buffer);\n        }\n    }\n\n    void clearFirmwareBuffer() {\n        if (m_firmware_buffer) {\n            free(m_firmware_buffer);\n            m_firmware_buffer = nullptr;\n            m_allocated_size = 0;\n        }\n    }\n\n    bool processFirmwareUpdatePacketFixed(const uint8_t* packet_data, size_t packet_length) {\n        if (!packet_data || packet_length < sizeof(FirmwarePacketHeader)) {\n            return false;\n        }\n\n        const FirmwarePacketHeader* header = reinterpret_cast<const FirmwarePacketHeader*>(packet_data);\n\n        // Basic sanity check: Is the claimed total payload size within packet bounds?\n        if (header->total_data_payload_size > (packet_length - sizeof(FirmwarePacketHeader))) {\n            return false;\n        }\n        \n        // Add a sanity check for number of modules to prevent excessive loops or unrealistic values\n        static const uint16_t MAX_ALLOWED_MODULES = 100; \n        if (header->num_modules > MAX_ALLOWED_MODULES) {\n            return false;\n        }\n\n        clearFirmwareBuffer();\n\n        // Allocate buffer based on the total_data_payload_size from the packet header\n        // Ensure total_data_payload_size is not zero if modules are expected (or handle empty case).\n        if (header->total_data_payload_size == 0 && header->num_modules > 0) {\n            return false; \n        }\n\n        m_firmware_buffer = (uint8_t*)malloc(header->total_data_payload_size);\n        if (!m_firmware_buffer) {\n            return false;\n        }\n        m_allocated_size = header->total_data_payload_size;\n\n        size_t current_packet_offset = sizeof(FirmwarePacketHeader);\n        size_t current_buffer_write_offset = 0;\n\n        for (uint16_t i = 0; i < header->num_modules; ++i) {\n            // Check if there's enough data in the raw packet for the module header\n            if (current_packet_offset + sizeof(FirmwareModuleHeader) > packet_length) {\n                clearFirmwareBuffer();\n                return false;\n            }\n\n            const FirmwareModuleHeader* module_hdr = reinterpret_cast<const FirmwareModuleHeader*>(packet_data + current_packet_offset);\n\n            // Advance packet offset past the module header\n            current_packet_offset += sizeof(FirmwareModuleHeader);\n            \n            // Check if there's enough data in the raw packet for the module's payload\n            if (current_packet_offset + module_hdr->module_data_length > packet_length) {\n                clearFirmwareBuffer();\n                return false;\n            }\n\n            // FIX: Crucial check to prevent heap buffer overflow.\n            // Ensure the current write operation, including the data to be copied,\n            // does not exceed the bounds of the allocated buffer (m_allocated_size).\n            // Also check for potential integer overflow during the sum before comparison.\n            if (current_buffer_write_offset > SIZE_MAX - module_hdr->module_data_length ||\n                current_buffer_write_offset + module_hdr->module_data_length > m_allocated_size) {\n                clearFirmwareBuffer();\n                return false; \n            }\n            \n            memcpy(m_firmware_buffer + current_buffer_write_offset,\n                   packet_data + current_packet_offset,\n                   module_hdr->module_data_length);\n\n            current_packet_offset += module_hdr->module_data_length;\n            current_buffer_write_offset += module_hdr->module_data_length;\n        }\n        \n        // Final consistency check: Ensure the total data actually copied matches\n        // the total_data_payload_size from the packet header.\n        if (current_buffer_write_offset != header->total_data_payload_size) {\n            clearFirmwareBuffer();\n            return false;\n        }\n\n        return true;\n    }\n\n    size_t getAllocatedFirmwareSize() const {\n        return m_allocated_size;\n    }\n\n    const uint8_t* getFirmwareBuffer() const {\n        return m_firmware_buffer;\n    }\n};",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <limits>\n\ntypedef struct {\n    uint16_t param_id;\n    uint16_t data_length;\n} ParameterEntryHeader;\n\nclass VehicleConfigurationManagerVulnerable {\npublic:\n    VehicleConfigurationManagerVulnerable() : m_config_buffer(nullptr), m_current_offset(0), m_allocated_capacity(0) {}\n\n    ~VehicleConfigurationManagerVulnerable() {\n        if (m_config_buffer) {\n            free(m_config_buffer);\n        }\n    }\n\n    bool addConfigurationParameterVulnerable(uint16_t param_id, const uint8_t* param_data, uint16_t data_len) {\n        if (!param_data || data_len == 0) {\n            return false;\n        }\n\n        size_t entry_total_size = sizeof(ParameterEntryHeader) + data_len;\n\n        size_t padded_data_len = (data_len + 3) & ~3;\n        size_t physical_entry_size = sizeof(ParameterEntryHeader) + padded_data_len;\n\n        if (m_current_offset > (SIZE_MAX - physical_entry_size)) {\n            return false;\n        }\n\n        if (m_config_buffer == nullptr) {\n            m_config_buffer = (uint8_t*)malloc(entry_total_size);\n            if (!m_config_buffer) return false;\n            m_allocated_capacity = entry_total_size;\n        } else if (m_current_offset + entry_total_size > m_allocated_capacity) {\n            uint8_t* temp_buffer = (uint8_t*)realloc(m_config_buffer, m_current_offset + entry_total_size);\n            if (!temp_buffer) {\n                free(m_config_buffer);\n                m_config_buffer = nullptr;\n                m_current_offset = 0;\n                m_allocated_capacity = 0;\n                return false;\n            }\n            m_config_buffer = temp_buffer;\n            m_allocated_capacity = m_current_offset + entry_total_size;\n        }\n\n        ParameterEntryHeader header_to_write = {param_id, data_len};\n        memcpy(m_config_buffer + m_current_offset, &header_to_write, sizeof(ParameterEntryHeader));\n        m_current_offset += sizeof(ParameterEntryHeader);\n\n        memcpy(m_config_buffer + m_current_offset, param_data, data_len);\n        m_current_offset += data_len;\n\n        size_t bytes_to_pad = padded_data_len - data_len;\n        if (bytes_to_pad > 0) {\n            memset(m_config_buffer + m_current_offset, 0, bytes_to_pad);\n            m_current_offset += bytes_to_pad;\n        }\n        \n        return true;\n    }\n\n    const uint8_t* getConfigurationBuffer() const { return m_config_buffer; }\n    size_t getCurrentOffset() const { return m_current_offset; }\n    size_t getAllocatedCapacity() const { return m_allocated_capacity; }\n\nprivate:\n    uint8_t* m_config_buffer;\n    size_t   m_current_offset;\n    size_t   m_allocated_capacity;\n}",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <limits>\n\ntypedef struct {\n    uint16_t param_id;\n    uint16_t data_length;\n} ParameterEntryHeader;\n\nclass VehicleConfigurationManagerFixed {\npublic:\n    VehicleConfigurationManagerFixed() : m_config_buffer(nullptr), m_current_offset(0), m_allocated_capacity(0) {}\n\n    ~VehicleConfigurationManagerFixed() {\n        if (m_config_buffer) {\n            free(m_config_buffer);\n        }\n    }\n\n    bool addConfigurationParameterFixed(uint16_t param_id, const uint8_t* param_data, uint16_t data_len) {\n        if (!param_data || data_len == 0) {\n            return false;\n        }\n\n        size_t padded_data_len = (data_len + 3) & ~3;\n        size_t physical_entry_size = sizeof(ParameterEntryHeader) + padded_data_len;\n\n        if (physical_entry_size == 0 || m_current_offset > (SIZE_MAX - physical_entry_size)) {\n            return false;\n        }\n\n        size_t required_total_capacity = m_current_offset + physical_entry_size;\n\n        if (m_config_buffer == nullptr) {\n            m_config_buffer = (uint8_t*)malloc(required_total_capacity);\n            if (!m_config_buffer) return false;\n            m_allocated_capacity = required_total_capacity;\n        } else if (required_total_capacity > m_allocated_capacity) {\n            uint8_t* temp_buffer = (uint8_t*)realloc(m_config_buffer, required_total_capacity);\n            if (!temp_buffer) {\n                free(m_config_buffer);\n                m_config_buffer = nullptr;\n                m_current_offset = 0;\n                m_allocated_capacity = 0;\n                return false;\n            }\n            m_config_buffer = temp_buffer;\n            m_allocated_capacity = required_total_capacity;\n        }\n\n        ParameterEntryHeader header_to_write = {param_id, data_len};\n        memcpy(m_config_buffer + m_current_offset, &header_to_write, sizeof(ParameterEntryHeader));\n        \n        memcpy(m_config_buffer + m_current_offset + sizeof(ParameterEntryHeader), param_data, data_len);\n        \n        size_t bytes_to_pad = padded_data_len - data_len;\n        if (bytes_to_pad > 0) {\n            memset(m_config_buffer + m_current_offset + sizeof(ParameterEntryHeader) + data_len, 0, bytes_to_pad);\n        }\n        \n        m_current_offset += physical_entry_size;\n        \n        return true;\n    }\n\n    const uint8_t* getConfigurationBuffer() const { return m_config_buffer; }\n    size_t getCurrentOffset() const { return m_current_offset; }\n    size_t getAllocatedCapacity() const { return m_allocated_capacity; }\n\nprivate:\n    uint8_t* m_config_buffer;\n    size_t   m_current_offset;\n    size_t   m_allocated_capacity;\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <vector>\n\n// Maximum allowed length for a sanitized string in the UI\n#define MAX_SANITIZED_STRING_LENGTH 2048\n\n// Represents a diagnostic log message structure received from a vehicle ECU\nstruct DiagnosticLogMessage {\n    uint32_t timestamp;\n    uint16_t event_id;\n    uint16_t raw_string_length; // Length of the raw description string\n    // raw_description_data follows this struct in the packet\n};\n\n// Represents a processed, sanitized log entry\nstruct SanitizedLogEntry {\n    uint32_t timestamp;\n    uint16_t event_id;\n    char*    sanitized_description; // Heap-allocated, null-terminated\n};\n\nclass TelemetryLogProcessor {\npublic:\n    TelemetryLogProcessor() {}\n\n    ~TelemetryLogProcessor() {\n        clearProcessedLogs();\n    }\n\n    void clearProcessedLogs() {\n        for (auto& entry : m_processed_entries) {\n            if (entry.sanitized_description) {\n                free(entry.sanitized_description);\n            }\n        }\n        m_processed_entries.clear();\n    }\n\n    // Vulnerable function\n    // Parses a raw packet containing multiple diagnostic log messages\n    // and sanitizes their descriptions for display.\n    bool processRawTelemetryLogsVulnerable(const uint8_t* raw_packet, size_t packet_len) {\n        if (!raw_packet || packet_len < sizeof(DiagnosticLogMessage)) {\n            return false;\n        }\n\n        clearProcessedLogs();\n\n        size_t current_offset = 0;\n\n        while (current_offset + sizeof(DiagnosticLogMessage) <= packet_len) {\n            const DiagnosticLogMessage* msg_header = reinterpret_cast<const DiagnosticLogMessage*>(raw_packet + current_offset);\n            \n            // Check if the claimed raw_string_length extends beyond the packet boundary\n            if (current_offset + sizeof(DiagnosticLogMessage) + msg_header->raw_string_length > packet_len) {\n                clearProcessedLogs();\n                return false;\n            }\n\n            // Vulnerability: Allocation based on raw_string_length + 1 (for null terminator).\n            // This does not account for character expansion during sanitization.\n            size_t allocated_desc_len = msg_header->raw_string_length + 1;\n            if (allocated_desc_len > MAX_SANITIZED_STRING_LENGTH) {\n                allocated_desc_len = MAX_SANITIZED_STRING_LENGTH;\n            }\n            if (allocated_desc_len == 0) allocated_desc_len = 1; // At least space for null terminator\n\n            char* sanitized_buffer = (char*)malloc(allocated_desc_len);\n            if (!sanitized_buffer) {\n                clearProcessedLogs();\n                return false;\n            }\n\n            SanitizedLogEntry new_entry;\n            new_entry.timestamp = msg_header->timestamp;\n            new_entry.event_id = msg_header->event_id;\n            new_entry.sanitized_description = sanitized_buffer;\n\n            const uint8_t* raw_desc_ptr = raw_packet + current_offset + sizeof(DiagnosticLogMessage);\n            size_t current_sanitized_pos = 0;\n\n            // Loop iterates 'raw_string_length' times.\n            // If a character expands (e.g., '\\n' -> '\\\\n' or 0x01 -> '[01]'), \n            // current_sanitized_pos increments by more than 1. This can exceed \n            // 'allocated_desc_len' before the loop finishes, leading to a heap overflow.\n            for (uint16_t i = 0; i < msg_header->raw_string_length; ++i) {\n                uint8_t char_code = raw_desc_ptr[i];\n\n                if (char_code >= 0x20 && char_code <= 0x7E) { // Printable ASCII\n                    sanitized_buffer[current_sanitized_pos++] = static_cast<char>(char_code);\n                } else {\n                    // Non-printable or control character. These expansions cause the overflow.\n                    if (char_code == '\\n') {\n                        sanitized_buffer[current_sanitized_pos++] = '\\\\';\n                        sanitized_buffer[current_sanitized_pos++] = 'n';\n                    } else if (char_code == '\\r') {\n                        sanitized_buffer[current_sanitized_pos++] = '\\\\';\n                        sanitized_buffer[current_sanitized_pos++] = 'r';\n                    } else if (char_code == '\\t') {\n                        sanitized_buffer[current_sanitized_pos++] = '\\\\';\n                        sanitized_buffer[current_sanitized_pos++] = 't';\n                    } else {\n                        // This specific expansion (e.g., 0x01 -> \"[01]\") leads to 4 characters.\n                        // If the raw string contains many such characters and allocated_desc_len\n                        // only accounts for 1:1 or 2:1 expansion, this will cause the heap overflow.\n                        sanitized_buffer[current_sanitized_pos++] = '[';\n                        sanitized_buffer[current_sanitized_pos++] = (char_code / 16 < 10 ? '0' + char_code / 16 : 'A' + char_code / 16 - 10);\n                        sanitized_buffer[current_sanitized_pos++] = (char_code % 16 < 10 ? '0' + char_code % 16 : 'A' + char_code % 16 - 10);\n                        sanitized_buffer[current_sanitized_pos++] = ']';\n                    }\n                }\n            }\n            sanitized_buffer[current_sanitized_pos] = '\\0'; // Null-terminate, potentially overflowing if loop already wrote past buffer\n\n            m_processed_entries.push_back(new_entry);\n\n            current_offset += sizeof(DiagnosticLogMessage) + msg_header->raw_string_length;\n        }\n\n        return true;\n    }\n\n    const std::vector<SanitizedLogEntry>& getProcessedEntries() const {\n        return m_processed_entries;\n    }\n\nprivate:\n    std::vector<SanitizedLogEntry> m_processed_entries;\n}",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n\n// Maximum allowed length for a sanitized string in the UI\n#define MAX_SANITIZED_STRING_LENGTH 2048\n\n// Represents a diagnostic log message structure received from a vehicle ECU\nstruct DiagnosticLogMessage {\n    uint32_t timestamp;\n    uint16_t event_id;\n    uint16_t raw_string_length; // Length of the raw description string\n    // raw_description_data follows this struct in the packet\n};\n\n// Represents a processed, sanitized log entry\nstruct SanitizedLogEntry {\n    uint32_t timestamp;\n    uint16_t event_id;\n    char*    sanitized_description; // Heap-allocated, null-terminated\n};\n\nclass TelemetryLogProcessor {\npublic:\n    TelemetryLogProcessor() {}\n\n    ~TelemetryLogProcessor() {\n        clearProcessedLogs();\n    }\n\n    void clearProcessedLogs() {\n        for (auto& entry : m_processed_entries) {\n            if (entry.sanitized_description) {\n                free(entry.sanitized_description);\n            }\n        }\n        m_processed_entries.clear();\n    }\n\n    // Fixed function\n    // Parses a raw packet containing multiple diagnostic log messages\n    // and sanitizes their descriptions for display.\n    bool processRawTelemetryLogsFixed(const uint8_t* raw_packet, size_t packet_len) {\n        if (!raw_packet || packet_len < sizeof(DiagnosticLogMessage)) {\n            return false;\n        }\n\n        clearProcessedLogs();\n\n        size_t current_offset = 0;\n\n        while (current_offset + sizeof(DiagnosticLogMessage) <= packet_len) {\n            const DiagnosticLogMessage* msg_header = reinterpret_cast<const DiagnosticLogMessage*>(raw_packet + current_offset);\n            \n            // Check if the claimed raw_string_length extends beyond the packet boundary\n            if (current_offset + sizeof(DiagnosticLogMessage) + msg_header->raw_string_length > packet_len) {\n                clearProcessedLogs();\n                return false;\n            }\n\n            // FIX: Correctly calculate the maximum required size based on the largest expansion factor (4x for \"[XX]\").\n            // Also, ensure it does not exceed MAX_SANITIZED_STRING_LENGTH.\n            size_t max_expansion_factor = 4; // Max expansion for \"[XX]\" format (e.g., 0x01 becomes \"[01]\")\n            size_t required_chars_for_sanitized_string = msg_header->raw_string_length * max_expansion_factor;\n            \n            // Ensure space for null terminator and apply hard limit\n            size_t allocated_desc_len = std::min(required_chars_for_sanitized_string + 1, (size_t)MAX_SANITIZED_STRING_LENGTH);\n            if (allocated_desc_len == 0) allocated_desc_len = 1; // Always allocate at least 1 byte for null terminator\n\n            char* sanitized_buffer = (char*)malloc(allocated_desc_len);\n            if (!sanitized_buffer) {\n                clearProcessedLogs();\n                return false;\n            }\n\n            SanitizedLogEntry new_entry;\n            new_entry.timestamp = msg_header->timestamp;\n            new_entry.event_id = msg_header->event_id;\n            new_entry.sanitized_description = sanitized_buffer;\n\n            const uint8_t* raw_desc_ptr = raw_packet + current_offset + sizeof(DiagnosticLogMessage);\n            size_t current_sanitized_pos = 0;\n\n            for (uint16_t i = 0; i < msg_header->raw_string_length; ++i) {\n                uint8_t char_code = raw_desc_ptr[i];\n\n                if (char_code >= 0x20 && char_code <= 0x7E) { // Printable ASCII\n                    // FIX: Add bounds check before writing\n                    if (current_sanitized_pos + 1 > allocated_desc_len - 1) { // Check if space for 1 char + null terminator\n                        break; \n                    }\n                    sanitized_buffer[current_sanitized_pos++] = static_cast<char>(char_code);\n                } else {\n                    // Non-printable or control character\n                    if (char_code == '\\n') {\n                        // FIX: Add bounds check before writing\n                        if (current_sanitized_pos + 2 > allocated_desc_len - 1) { // Check space for 2 chars + null terminator\n                            break;\n                        }\n                        sanitized_buffer[current_sanitized_pos++] = '\\\\';\n                        sanitized_buffer[current_sanitized_pos++] = 'n';\n                    } else if (char_code == '\\r') {\n                        // FIX: Add bounds check before writing\n                        if (current_sanitized_pos + 2 > allocated_desc_len - 1) {\n                            break;\n                        }\n                        sanitized_buffer[current_sanitized_pos++] = '\\\\';\n                        sanitized_buffer[current_sanitized_pos++] = 'r';\n                    } else if (char_code == '\\t') {\n                        // FIX: Add bounds check before writing\n                        if (current_sanitized_pos + 2 > allocated_desc_len - 1) {\n                            break;\n                        }\n                        sanitized_buffer[current_sanitized_pos++] = '\\\\';\n                        sanitized_buffer[current_sanitized_pos++] = 't';\n                    } else {\n                        // For other control characters, represent as \"[XX]\" (4 chars)\n                        // FIX: Add bounds check before writing\n                        if (current_sanitized_pos + 4 > allocated_desc_len - 1) { // Check space for 4 chars + null terminator\n                            break;\n                        }\n                        sanitized_buffer[current_sanitized_pos++] = '[';\n                        sanitized_buffer[current_sanitized_pos++] = (char_code / 16 < 10 ? '0' + char_code / 16 : 'A' + char_code / 16 - 10);\n                        sanitized_buffer[current_sanitized_pos++] = (char_code % 16 < 10 ? '0' + char_code % 16 : 'A' + char_code % 16 - 10);\n                        sanitized_buffer[current_sanitized_pos++] = ']';\n                    }\n                }\n            }\n            sanitized_buffer[current_sanitized_pos] = '\\0'; // Always null-terminate safely\n\n            m_processed_entries.push_back(new_entry);\n\n            current_offset += sizeof(DiagnosticLogMessage) + msg_header->raw_string_length;\n        }\n\n        return true;\n    }\n\n    const std::vector<SanitizedLogEntry>& getProcessedEntries() const {\n        return m_processed_entries;\n    }\n\nprivate:\n    std::vector<SanitizedLogEntry> m_processed_entries;\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n\ntypedef struct {\n    uint16_t entry_id;\n    uint16_t data_len;\n} LogEntryHeader;\n\nclass CircularLogBufferVulnerable {\npublic:\n    CircularLogBufferVulnerable(size_t capacity) :\n        m_buffer(nullptr),\n        m_capacity(capacity),\n        m_write_pos(0)\n    {\n        if (m_capacity > 0) {\n            m_buffer = (uint8_t*)malloc(m_capacity);\n        }\n    }\n\n    ~CircularLogBufferVulnerable() {\n        if (m_buffer) {\n            free(m_buffer);\n        }\n    }\n\n    bool appendEntryVulnerable(const uint8_t* entry_data, size_t data_packet_len) {\n        if (!entry_data || data_packet_len < sizeof(LogEntryHeader)) {\n            return false;\n        }\n\n        const LogEntryHeader* header = reinterpret_cast<const LogEntryHeader*>(entry_data);\n        uint16_t payload_len = header->data_len;\n\n        size_t total_entry_size = sizeof(LogEntryHeader) + payload_len;\n\n        if (data_packet_len < total_entry_size) {\n            return false;\n        }\n        \n        if (m_write_pos + total_entry_size > m_capacity) {\n            m_write_pos = 0;\n        }\n        \n        if (!m_buffer) {\n            return false;\n        }\n\n        for (size_t i = 0; i < total_entry_size; ++i) {\n            m_buffer[m_write_pos + i] = entry_data[i];\n        }\n\n        m_write_pos = (m_write_pos + total_entry_size) % m_capacity;\n\n        return true;\n    }\n\n    size_t getCurrentWritePosition() const {\n        return m_write_pos;\n    }\n\n    size_t getBufferCapacity() const {\n        return m_capacity;\n    }\n\nprivate:\n    uint8_t* m_buffer;\n    size_t m_capacity;\n    size_t m_write_pos;\n};\n",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n\ntypedef struct {\n    uint16_t entry_id;\n    uint16_t data_len;\n} LogEntryHeader;\n\nclass CircularLogBufferFixed {\npublic:\n    CircularLogBufferFixed(size_t capacity) :\n        m_buffer(nullptr),\n        m_capacity(capacity),\n        m_write_pos(0)\n    {\n        if (m_capacity > 0) {\n            m_buffer = (uint8_t*)malloc(m_capacity);\n        }\n    }\n\n    ~CircularLogBufferFixed() {\n        if (m_buffer) {\n            free(m_buffer);\n        }\n    }\n\n    bool appendEntryFixed(const uint8_t* entry_data, size_t data_packet_len) {\n        if (!entry_data || data_packet_len < sizeof(LogEntryHeader)) {\n            return false;\n        }\n\n        const LogEntryHeader* header = reinterpret_cast<const LogEntryHeader*>(entry_data);\n        uint16_t payload_len = header->data_len;\n\n        static const uint16_t MAX_ALLOWED_PAYLOAD_LEN = 2048;\n        if (payload_len > MAX_ALLOWED_PAYLOAD_LEN) {\n            return false;\n        }\n        \n        size_t total_entry_size = sizeof(LogEntryHeader) + payload_len;\n\n        if (total_entry_size > m_capacity) {\n            return false;\n        }\n\n        if (data_packet_len < total_entry_size) {\n            return false;\n        }\n        \n        if (m_write_pos + total_entry_size > m_capacity) {\n            m_write_pos = 0;\n        }\n        \n        if (!m_buffer) {\n            return false;\n        }\n\n        for (size_t i = 0; i < total_entry_size; ++i) {\n            m_buffer[m_write_pos + i] = entry_data[i];\n        }\n\n        m_write_pos = (m_write_pos + total_entry_size) % m_capacity;\n\n        return true;\n    }\n\n    size_t getCurrentWritePosition() const {\n        return m_write_pos;\n    }\n\n    size_t getBufferCapacity() const {\n        return m_capacity;\n    }\n\nprivate:\n    uint8_t* m_buffer;\n    size_t m_capacity;\n    size_t m_write_pos;\n};\n",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <new>\n\n// Represents a sub-message header within a larger diagnostic packet\nstruct DiagnosticSubMessageHeader {\n    uint16_t message_id;\n    uint16_t payload_length; // Actual length of payload for this sub-message\n};\n\n// Represents the overall diagnostic packet header\nstruct DiagnosticPacketHeader {\n    uint16_t packet_type;\n    uint16_t num_sub_messages;\n    uint32_t max_expected_sub_message_payload_len; // Max payload size for ANY sub-message in this packet\n};\n\nclass DiagnosticDataProcessorVulnerable {\npublic:\n    DiagnosticDataProcessorVulnerable() : m_buffer(nullptr), m_buffer_capacity(0) {}\n\n    ~DiagnosticDataProcessorVulnerable() {\n        if (m_buffer) {\n            free(m_buffer);\n            m_buffer = nullptr;\n        }\n    }\n\n    bool processPacketVulnerable(const uint8_t* raw_packet, size_t packet_len) {\n        if (!raw_packet || packet_len < sizeof(DiagnosticPacketHeader)) {\n            return false;\n        }\n\n        const DiagnosticPacketHeader* header = reinterpret_cast<const DiagnosticPacketHeader*>(raw_packet);\n\n        // Calculate total space needed for all sub-messages' payloads based on the MAX expected length.\n        // This multiplication is vulnerable to integer overflow. If num_sub_messages and\n        // max_expected_sub_message_payload_len are large, their product can exceed UINT32_MAX.\n        // E.g., num_sub_messages = 2, max_expected_sub_message_payload_len = 0x80000000 (2GB).\n        // The product 2 * 0x80000000 = 0x100000000 (4GB) will wrap around to 0 in a uint32_t.\n        uint32_t total_payload_data_space = header->num_sub_messages * header->max_expected_sub_message_payload_len; // Vulnerable point\n\n        // Add space for all sub-message headers\n        size_t total_headers_space = (size_t)header->num_sub_messages * sizeof(DiagnosticSubMessageHeader);\n        \n        // Calculate the total allocation size for the internal buffer.\n        // If total_payload_data_space wrapped to 0 due to the overflow, this size will be very small.\n        size_t total_allocation_size = total_payload_data_space + total_headers_space;\n\n        if (m_buffer) {\n            free(m_buffer);\n            m_buffer = nullptr;\n        }\n        \n        // Allocate the buffer. If total_allocation_size was truncated, this allocation is too small.\n        m_buffer = (uint8_t*)malloc(total_allocation_size);\n        if (!m_buffer) {\n            m_buffer_capacity = 0;\n            return false;\n        }\n        m_buffer_capacity = total_allocation_size;\n\n        uint8_t* current_write_ptr = m_buffer;\n        const uint8_t* current_read_ptr = raw_packet + sizeof(DiagnosticPacketHeader);\n        size_t remaining_packet_data = packet_len - sizeof(DiagnosticPacketHeader);\n\n        for (uint16_t i = 0; i < header->num_sub_messages; ++i) {\n            // Basic validation for sub-message header presence in source packet\n            if (remaining_packet_data < sizeof(DiagnosticSubMessageHeader)) {\n                return false; // Malformed packet or truncated\n            }\n\n            const DiagnosticSubMessageHeader* sub_header = reinterpret_cast<const DiagnosticSubMessageHeader*>(current_read_ptr);\n            uint16_t actual_payload_len = sub_header->payload_length;\n\n            // Validate actual payload length against remaining source packet data\n            if (remaining_packet_data - sizeof(DiagnosticSubMessageHeader) < actual_payload_len) {\n                return false; // Not enough source data for declared payload\n            }\n            \n            // --- Heap-based Buffer Overflow happens here ---\n            // No check is performed to ensure that 'current_write_ptr + sizeof(DiagnosticSubMessageHeader) + actual_payload_len'\n            // does not exceed 'm_buffer + m_buffer_capacity'.\n            // If total_allocation_size was truncated due to the integer overflow mentioned above,\n            // and actual_payload_len is still large (even if it respects the max_expected_sub_message_payload_len from the header),\n            // this memcpy will write beyond the bounds of the undersized m_buffer.\n            \n            // Copy sub-message header\n            memcpy(current_write_ptr, sub_header, sizeof(DiagnosticSubMessageHeader));\n            current_write_ptr += sizeof(DiagnosticSubMessageHeader);\n\n            // Copy sub-message payload\n            memcpy(current_write_ptr, current_read_ptr + sizeof(DiagnosticSubMessageHeader), actual_payload_len); // Direct copy\n            current_write_ptr += actual_payload_len;\n\n            current_read_ptr += sizeof(DiagnosticSubMessageHeader) + actual_payload_len;\n            remaining_packet_data -= (sizeof(DiagnosticSubMessageHeader) + actual_payload_len);\n        }\n\n        return true;\n    }\n\n    const uint8_t* getProcessedData() const { return m_buffer; }\n    size_t getProcessedDataCapacity() const { return m_buffer_capacity; }\n\nprivate:\n    uint8_t* m_buffer;\n    size_t m_buffer_capacity;\n};",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <new>\n#include <limits> // For std::numeric_limits\n\n// Represents a sub-message header within a larger diagnostic packet\nstruct DiagnosticSubMessageHeader {\n    uint16_t message_id;\n    uint16_t payload_length; // Actual length of payload for this sub-message\n};\n\n// Represents the overall diagnostic packet header\nstruct DiagnosticPacketHeader {\n    uint16_t packet_type;\n    uint16_t num_sub_messages;\n    uint32_t max_expected_sub_message_payload_len; // Max payload size for ANY sub-message in this packet\n};\n\nclass DiagnosticDataProcessorFixed {\npublic:\n    DiagnosticDataProcessorFixed() : m_buffer(nullptr), m_buffer_capacity(0) {}\n\n    ~DiagnosticDataProcessorFixed() {\n        if (m_buffer) {\n            free(m_buffer);\n            m_buffer = nullptr;\n        }\n    }\n\n    bool processPacketFixed(const uint8_t* raw_packet, size_t packet_len) {\n        if (!raw_packet || packet_len < sizeof(DiagnosticPacketHeader)) {\n            return false;\n        }\n\n        const DiagnosticPacketHeader* header = reinterpret_cast<const DiagnosticPacketHeader*>(raw_packet);\n\n        // Calculate total space needed for all sub-messages' payloads based on the MAX expected length.\n        // Use size_t for calculations to prevent intermediate overflow of smaller types,\n        // and explicitly check for overflow against SIZE_MAX.\n        size_t total_payload_data_space;\n        if (header->num_sub_messages != 0 &&\n            header->max_expected_sub_message_payload_len > std::numeric_limits<size_t>::max() / header->num_sub_messages) {\n            return false; // Integer overflow detected for payload space during multiplication\n        }\n        total_payload_data_space = (size_t)header->num_sub_messages * header->max_expected_sub_message_payload_len;\n\n        // Add space for all sub-message headers\n        size_t total_headers_space = (size_t)header->num_sub_messages * sizeof(DiagnosticSubMessageHeader);\n        \n        // Check for integer overflow when adding total_headers_space\n        if (total_payload_data_space > std::numeric_limits<size_t>::max() - total_headers_space) {\n            return false; // Integer overflow detected for total size during addition\n        }\n\n        size_t total_allocation_size = total_payload_data_space + total_headers_space;\n\n        // Ensure total_allocation_size is not zero if there are messages expected\n        if (header->num_sub_messages > 0 && total_allocation_size == 0) {\n            return false; // Calculation resulted in zero size for a non-empty packet\n        }\n\n        if (m_buffer) {\n            free(m_buffer);\n            m_buffer = nullptr;\n        }\n        \n        // Allocate the buffer. This size is now correctly calculated and checked.\n        m_buffer = (uint8_t*)malloc(total_allocation_size);\n        if (!m_buffer) {\n            m_buffer_capacity = 0;\n            return false;\n        }\n        m_buffer_capacity = total_allocation_size;\n\n        uint8_t* current_write_ptr = m_buffer;\n        const uint8_t* current_read_ptr = raw_packet + sizeof(DiagnosticPacketHeader);\n        size_t remaining_packet_data = packet_len - sizeof(DiagnosticPacketHeader);\n\n        for (uint16_t i = 0; i < header->num_sub_messages; ++i) {\n            // Validate minimum required data for sub-message header in source packet\n            if (remaining_packet_data < sizeof(DiagnosticSubMessageHeader)) {\n                return false; // Malformed packet or truncated\n            }\n\n            const DiagnosticSubMessageHeader* sub_header = reinterpret_cast<const DiagnosticSubMessageHeader*>(current_read_ptr);\n            uint16_t actual_payload_len = sub_header->payload_length;\n\n            // Validate that an individual message's payload length does not exceed the globally advertised maximum\n            if (actual_payload_len > header->max_expected_sub_message_payload_len) {\n                return false; // Individual message payload exceeds global max declared in header\n            }\n\n            size_t current_sub_message_total_len = sizeof(DiagnosticSubMessageHeader) + actual_payload_len;\n\n            // Crucial: Check if there's enough space in the *destination* buffer for the current sub-message data.\n            // This prevents heap-based buffer overflow by ensuring the memcpy destination is within bounds.\n            // Also checks for pointer arithmetic wrap-around for current_write_ptr + current_sub_message_total_len.\n            if (current_write_ptr > m_buffer + m_buffer_capacity ||\n                current_sub_message_total_len > m_buffer_capacity - (current_write_ptr - m_buffer)) \n            {\n                return false; // Not enough allocated buffer space remaining for this entry\n            }\n            \n            // Check if there's enough data in the source packet for this complete sub-message (header + payload)\n            if (remaining_packet_data < current_sub_message_total_len) {\n                return false; // Not enough source data for declared payload\n            }\n            \n            // Copy sub-message header and payload in one contiguous block\n            memcpy(current_write_ptr, current_read_ptr, current_sub_message_total_len);\n            \n            current_write_ptr += current_sub_message_total_len;\n            current_read_ptr += current_sub_message_total_len;\n            remaining_packet_data -= current_sub_message_total_len;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getProcessedData() const { return m_buffer; }\n    size_t getProcessedDataCapacity() const { return m_buffer_capacity; }\n\nprivate:\n    uint8_t* m_buffer;\n    size_t m_buffer_capacity;\n};",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstddef>\n#include <new>\n#include <cstring>\n\n// Represents a single firmware image entry within an update manifest\nstruct FirmwareImageEntry {\n    uint32_t image_id;\n    uint32_t image_size;\n    uint8_t  checksum[16];\n    char     version_string[32]; // Fixed-size string buffer for version\n};\n\n// Represents the header of a firmware update manifest packet\nstruct UpdateManifestHeader {\n    uint16_t manifest_version;\n    uint16_t num_firmware_images;   // Declared number of images - used for allocation\n    uint32_t total_payload_bytes;   // Total bytes of ALL image entries in the payload - used for loop bounds\n};\n\nclass FirmwareUpdaterVulnerable {\npublic:\n    FirmwareUpdaterVulnerable() : update_tasks(nullptr), num_tasks_allocated(0) {}\n\n    ~FirmwareUpdaterVulnerable() {\n        clearTasks();\n    }\n\n    void clearTasks() {\n        if (update_tasks) {\n            delete[] update_tasks;\n            update_tasks = nullptr;\n        }\n        num_tasks_allocated = 0;\n    }\n\n    // Processes a raw firmware update manifest packet\n    // Vulnerability: The allocation size (num_firmware_images) can be mismatched\n    // with the actual number of entries processed (derived from total_payload_bytes).\n    bool parseManifestVulnerable(const uint8_t* raw_manifest, size_t manifest_len) {\n        if (!raw_manifest || manifest_len < sizeof(UpdateManifestHeader)) {\n            return false;\n        }\n\n        const UpdateManifestHeader* header = reinterpret_cast<const UpdateManifestHeader*>(raw_manifest);\n\n        // Basic check: Ensure the reported total_payload_bytes does not exceed the actual packet length.\n        if (manifest_len < sizeof(UpdateManifestHeader) + header->total_payload_bytes) {\n            return false;\n        }\n\n        clearTasks(); // Clear any existing tasks before processing new manifest\n\n        // The heap allocation size is determined by 'num_firmware_images'.\n        // An attacker can set this to a small value (e.g., 1).\n        num_tasks_allocated = header->num_firmware_images;\n\n        // To avoid allocating 0 elements if num_firmware_images is 0, or excessive size.\n        static const uint16_t MAX_ALLOWED_IMAGES = 200;\n        if (num_tasks_allocated == 0 || num_tasks_allocated > MAX_ALLOWED_IMAGES) {\n            return false;\n        }\n\n        // Check for potential integer overflow in allocation size (though less likely with uint16_t and small struct size)\n        if ((size_t)num_tasks_allocated > (SIZE_MAX / sizeof(FirmwareImageEntry))) {\n            return false;\n        }\n\n        update_tasks = new (std::nothrow) FirmwareImageEntry[num_tasks_allocated];\n        if (!update_tasks) {\n            return false;\n        }\n\n        const uint8_t* current_payload_ptr = raw_manifest + sizeof(UpdateManifestHeader);\n        size_t bytes_processed_in_payload = 0;\n        uint16_t entry_count = 0;\n\n        // Vulnerability: The loop continues as long as there is enough data for another\n        // FirmwareImageEntry within the 'total_payload_bytes'.\n        // It DOES NOT check if 'entry_count' exceeds 'num_tasks_allocated'.\n        // An attacker can set header->num_firmware_images to a small number (e.g., 1) to get a small allocation,\n        // but craft header->total_payload_bytes to contain data for many more entries (e.g., 10 entries).\n        // This leads to 'update_tasks[entry_count]' writing past the allocated heap buffer.\n        while (bytes_processed_in_payload + sizeof(FirmwareImageEntry) <= header->total_payload_bytes) {\n\n            const FirmwareImageEntry* incoming_entry = reinterpret_cast<const FirmwareImageEntry*>(current_payload_ptr + bytes_processed_in_payload);\n            \n            // Heap-based Buffer Overflow occurs here if entry_count >= num_tasks_allocated\n            update_tasks[entry_count].image_id = incoming_entry->image_id;\n            update_tasks[entry_count].image_size = incoming_entry->image_size;\n            memcpy(update_tasks[entry_count].checksum, incoming_entry->checksum, sizeof(incoming_entry->checksum));\n            \n            // strncpy with null-termination is safe for individual string field, but the overall array access is vulnerable.\n            strncpy(update_tasks[entry_count].version_string, incoming_entry->version_string, sizeof(incoming_entry->version_string) - 1);\n            update_tasks[entry_count].version_string[sizeof(incoming_entry->version_string) - 1] = '\\0';\n\n            bytes_processed_in_payload += sizeof(FirmwareImageEntry);\n            entry_count++;\n        }\n\n        // Note: Even if total_payload_bytes is checked against manifest_len, and `num_firmware_images` is checked for max,\n        // the mismatch between `num_firmware_images` (allocation size) and `total_payload_bytes` (loop iteration count) remains.\n\n        return true;\n    }\n\n    const FirmwareImageEntry* getUpdateTasks() const { return update_tasks; }\n    uint16_t getNumTasksAllocated() const { return num_tasks_allocated; }\n\nprivate:\n    FirmwareImageEntry* update_tasks;\n    uint16_t            num_tasks_allocated;\n};\n",
    "fixed_code": "#include <cstdint>\n#include <cstddef>\n#include <new>\n#include <cstring>\n\n// Represents a single firmware image entry within an update manifest\nstruct FirmwareImageEntry {\n    uint32_t image_id;\n    uint32_t image_size;\n    uint8_t  checksum[16];\n    char     version_string[32]; // Fixed-size string buffer for version\n};\n\n// Represents the header of a firmware update manifest packet\nstruct UpdateManifestHeader {\n    uint16_t manifest_version;\n    uint16_t num_firmware_images;   // Declared number of images - used for allocation\n    uint32_t total_payload_bytes;   // Total bytes of ALL image entries in the payload - used for loop bounds\n};\n\nclass FirmwareUpdaterFixed {\npublic:\n    FirmwareUpdaterFixed() : update_tasks(nullptr), num_tasks_allocated(0) {}\n\n    ~FirmwareUpdaterFixed() {\n        clearTasks();\n    }\n\n    void clearTasks() {\n        if (update_tasks) {\n            delete[] update_tasks;\n            update_tasks = nullptr;\n        }\n        num_tasks_allocated = 0;\n    }\n\n    // Processes a raw firmware update manifest packet\n    // Fix: Ensures consistency between declared image count and total payload bytes,\n    // and strictly bounds the writing loop to the allocated array size.\n    bool parseManifestFixed(const uint8_t* raw_manifest, size_t manifest_len) {\n        if (!raw_manifest || manifest_len < sizeof(UpdateManifestHeader)) {\n            return false;\n        }\n\n        const UpdateManifestHeader* header = reinterpret_cast<const UpdateManifestHeader*>(raw_manifest);\n\n        // Fix 1: Add reasonable limits for num_firmware_images to prevent excessively large allocations.\n        static const uint16_t MAX_SUPPORTED_FIRMWARE_IMAGES = 200;\n        if (header->num_firmware_images > MAX_SUPPORTED_FIRMWARE_IMAGES) {\n            return false;\n        }\n\n        // Fix 2: Check for potential integer overflow during allocation size calculation.\n        if (header->num_firmware_images > (SIZE_MAX / sizeof(FirmwareImageEntry))) {\n            return false;\n        }\n\n        // Fix 3: Crucial consistency check: total_payload_bytes must precisely match\n        // the expected size based on num_firmware_images and entry size.\n        // This prevents an attacker from supplying a small num_firmware_images but a large total_payload_bytes.\n        if (header->num_firmware_images > 0 &&\n            header->total_payload_bytes != (size_t)header->num_firmware_images * sizeof(FirmwareImageEntry)) {\n            return false; // Malformed packet: declared count vs. total bytes mismatch\n        }\n\n        // Fix 4: Packet length check ensures enough data for the full declared payload.\n        if (manifest_len < sizeof(UpdateManifestHeader) + header->total_payload_bytes) {\n            return false;\n        }\n\n        clearTasks(); // Clear any existing tasks before processing new manifest\n\n        // Allocation size is correctly determined by 'num_firmware_images'.\n        num_tasks_allocated = header->num_firmware_images;\n\n        // If num_tasks_allocated is 0, we don't allocate or process anything.\n        if (num_tasks_allocated == 0) {\n            return true;\n        }\n\n        update_tasks = new (std::nothrow) FirmwareImageEntry[num_tasks_allocated];\n        if (!update_tasks) {\n            return false;\n        }\n\n        const uint8_t* current_payload_ptr = raw_manifest + sizeof(UpdateManifestHeader);\n\n        // Fix 5: The loop now explicitly iterates only up to 'num_tasks_allocated',\n        // which is the actual allocated size of the 'update_tasks' array.\n        // This prevents writing beyond the array bounds.\n        for (uint16_t i = 0; i < num_tasks_allocated; ++i) {\n            // Additional runtime check to ensure we don't read beyond the packet data (should be caught by Fix 4).\n            // This guards against highly malformed packets where actual data is less than declared `total_payload_bytes`.\n            if ((current_payload_ptr + (i * sizeof(FirmwareImageEntry)) + sizeof(FirmwareImageEntry)) > (raw_manifest + manifest_len)) {\n                clearTasks();\n                return false; // Malformed packet: not enough data for all declared entries\n            }\n\n            const FirmwareImageEntry* incoming_entry = reinterpret_cast<const FirmwareImageEntry*>(current_payload_ptr + (i * sizeof(FirmwareImageEntry)));\n            \n            update_tasks[i].image_id = incoming_entry->image_id;\n            update_tasks[i].image_size = incoming_entry->image_size;\n            memcpy(update_tasks[i].checksum, incoming_entry->checksum, sizeof(incoming_entry->checksum));\n            \n            // strncpy with null-termination is safe for individual string field.\n            strncpy(update_tasks[i].version_string, incoming_entry->version_string, sizeof(incoming_entry->version_string) - 1);\n            update_tasks[i].version_string[sizeof(incoming_entry->version_string) - 1] = '\\0';\n        }\n\n        return true;\n    }\n\n    const FirmwareImageEntry* getUpdateTasks() const { return update_tasks; }\n    uint16_t getNumTasksAllocated() const { return num_tasks_allocated; }\n\nprivate:\n    FirmwareImageEntry* update_tasks;\n    uint16_t            num_tasks_allocated;\n};",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n\nstruct CalibrationPoint {\n    uint32_t timestamp;\n    int16_t value;\n};\n\nstruct CalibrationPacketHeader {\n    uint16_t packet_magic;\n    uint16_t num_calibration_points;\n    uint8_t  _reserved[4];\n};\n\nclass CalibrationManager {\nprivate:\n    CalibrationPoint* m_current_calibration_data;\n    size_t m_allocated_buffer_size_bytes;\n    size_t m_active_points_count;\n\npublic:\n    CalibrationManager() : m_current_calibration_data(nullptr), m_allocated_buffer_size_bytes(0), m_active_points_count(0) {}\n\n    ~CalibrationManager() {\n        if (m_current_calibration_data) {\n            free(m_current_calibration_data);\n            m_current_calibration_data = nullptr;\n        }\n    }\n\n    void clearCalibrationData() {\n        if (m_current_calibration_data) {\n            free(m_current_calibration_data);\n            m_current_calibration_data = nullptr;\n        }\n        m_allocated_buffer_size_bytes = 0;\n        m_active_points_count = 0;\n    }\n\n    bool processCalibrationPacketVulnerable(const uint8_t* packet_buffer, size_t buffer_length) {\n        if (!packet_buffer || buffer_length < sizeof(CalibrationPacketHeader)) {\n            return false;\n        }\n\n        const CalibrationPacketHeader* header = reinterpret_cast<const CalibrationPacketHeader*>(packet_buffer);\n\n        if (header->packet_magic != 0xABCD) {\n            return false;\n        }\n\n        uint16_t num_points = header->num_calibration_points;\n\n        // This calculation is for validating the *incoming packet's* stated length.\n        // It does not protect against a subsequent heap allocation error.\n        size_t expected_payload_bytes_from_packet = num_points * sizeof(CalibrationPoint);\n        size_t total_expected_packet_size = sizeof(CalibrationPacketHeader) + expected_payload_bytes_from_packet;\n\n        if (buffer_length < total_expected_packet_size) {\n            return false;\n        }\n\n        clearCalibrationData();\n\n        // VULNERABILITY: Incorrect size calculation for malloc.\n        // CalibrationPoint is 6 bytes (uint32_t + int16_t). sizeof(uint16_t) is 2 bytes.\n        // This allocates only 1/3 of the required memory, leading to a heap overflow\n        // when the data points are subsequently written to the undersized buffer.\n        m_current_calibration_data = (CalibrationPoint*)malloc(num_points * sizeof(uint16_t));\n\n        if (!m_current_calibration_data && num_points > 0) {\n            return false;\n        }\n        m_allocated_buffer_size_bytes = num_points * sizeof(uint16_t);\n\n        const uint8_t* data_ptr = packet_buffer + sizeof(CalibrationPacketHeader);\n        size_t current_data_offset = 0;\n\n        for (uint16_t i = 0; i < num_points; ++i) {\n            // The following assignments will write out of bounds because 'm_current_calibration_data'\n            // was allocated assuming each 'CalibrationPoint' is only 2 bytes large,\n            // but each actual 'CalibrationPoint' consumes 6 bytes.\n\n            // Read timestamp (uint32_t) from packet and write to heap buffer\n            m_current_calibration_data[i].timestamp = (uint32_t)data_ptr[current_data_offset] |\n                                                      ((uint32_t)data_ptr[current_data_offset + 1] << 8) |\n                                                      ((uint32_t)data_ptr[current_data_offset + 2] << 16) |\n                                                      ((uint32_t)data_ptr[current_data_offset + 3] << 24);\n            current_data_offset += sizeof(uint32_t);\n\n            // Read value (int16_t) from packet and write to heap buffer\n            m_current_calibration_data[i].value = (int16_t)data_ptr[current_data_offset] |\n                                                  ((int16_t)data_ptr[current_data_offset + 1] << 8);\n            current_data_offset += sizeof(int16_t);\n        }\n\n        m_active_points_count = num_points;\n        return true;\n    }\n\n    size_t getActivePointsCount() const {\n        return m_active_points_count;\n    }\n\n    const CalibrationPoint* getCalibrationData() const {\n        return m_current_calibration_data;\n    }\n};\n",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n\nstruct CalibrationPoint {\n    uint32_t timestamp;\n    int16_t value;\n};\n\nstruct CalibrationPacketHeader {\n    uint16_t packet_magic;\n    uint16_t num_calibration_points;\n    uint8_t  _reserved[4];\n};\n\nclass CalibrationManager {\nprivate:\n    CalibrationPoint* m_current_calibration_data;\n    size_t m_allocated_buffer_size_bytes;\n    size_t m_active_points_count;\n\npublic:\n    CalibrationManager() : m_current_calibration_data(nullptr), m_allocated_buffer_size_bytes(0), m_active_points_count(0) {}\n\n    ~CalibrationManager() {\n        if (m_current_calibration_data) {\n            free(m_current_calibration_data);\n            m_current_calibration_data = nullptr;\n        }\n    }\n\n    void clearCalibrationData() {\n        if (m_current_calibration_data) {\n            free(m_current_calibration_data);\n            m_current_calibration_data = nullptr;\n        }\n        m_allocated_buffer_size_bytes = 0;\n        m_active_points_count = 0;\n    }\n\n    bool processCalibrationPacketFixed(const uint8_t* packet_buffer, size_t buffer_length) {\n        if (!packet_buffer || buffer_length < sizeof(CalibrationPacketHeader)) {\n            return false;\n        }\n\n        const CalibrationPacketHeader* header = reinterpret_cast<const CalibrationPacketHeader*>(packet_buffer);\n\n        if (header->packet_magic != 0xABCD) {\n            return false;\n        }\n\n        uint16_t num_points = header->num_calibration_points;\n\n        // FIX: Add a reasonable maximum limit to prevent excessive memory allocation (DoS)\n        static const uint16_t MAX_POINTS_ALLOWED = 10000;\n        if (num_points > MAX_POINTS_ALLOWED) {\n            return false;\n        }\n\n        // Calculate expected total data size for the points payload.\n        // FIX: Add integer overflow checks for multiplication and addition.\n        size_t expected_payload_bytes;\n        if (num_points > 0 && SIZE_MAX / sizeof(CalibrationPoint) < num_points) {\n            return false; \n        }\n        expected_payload_bytes = num_points * sizeof(CalibrationPoint);\n        \n        size_t total_expected_packet_size;\n        if (SIZE_MAX - sizeof(CalibrationPacketHeader) < expected_payload_bytes) {\n            return false; \n        }\n        total_expected_packet_size = sizeof(CalibrationPacketHeader) + expected_payload_bytes;\n\n        if (buffer_length < total_expected_packet_size) {\n            return false;\n        }\n\n        clearCalibrationData();\n\n        // FIX: Correct size calculation for malloc by using the actual size of CalibrationPoint.\n        m_current_calibration_data = (CalibrationPoint*)malloc(expected_payload_bytes);\n\n        if (!m_current_calibration_data && num_points > 0) {\n            return false;\n        }\n        m_allocated_buffer_size_bytes = expected_payload_bytes;\n\n        const uint8_t* data_ptr = packet_buffer + sizeof(CalibrationPacketHeader);\n        size_t current_data_offset = 0;\n\n        for (uint16_t i = 0; i < num_points; ++i) {\n            // No explicit bounds checks needed here anymore for writing to 'm_current_calibration_data'\n            // because the buffer is now correctly sized and 'i' iterates up to 'num_points - 1'.\n\n            // Read timestamp (uint32_t) from packet and write to heap buffer\n            m_current_calibration_data[i].timestamp = (uint32_t)data_ptr[current_data_offset] |\n                                                      ((uint32_t)data_ptr[current_data_offset + 1] << 8) |\n                                                      ((uint32_t)data_ptr[current_data_offset + 2] << 16) |\n                                                      ((uint32_t)data_ptr[current_data_offset + 3] << 24);\n            current_data_offset += sizeof(uint32_t);\n\n            // Read value (int16_t) from packet and write to heap buffer\n            m_current_calibration_data[i].value = (int16_t)data_ptr[current_data_offset] |\n                                                  ((int16_t)data_ptr[current_data_offset + 1] << 8);\n            current_data_offset += sizeof(int16_t);\n        }\n\n        m_active_points_count = num_points;\n        return true;\n    }\n\n    size_t getActivePointsCount() const {\n        return m_active_points_count;\n    }\n\n    const CalibrationPoint* getCalibrationData() const {\n        return m_current_calibration_data;\n    }\n};\n",
    "analysis": ""
  },
  {
    "cwe_id": "122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n\nstruct ConfigEntryHeader {\n    uint16_t key_hash;\n    uint16_t value_length; \n};\n\nclass VehicleConfigStoreVulnerable {\npublic:\n    VehicleConfigStoreVulnerable(size_t initial_capacity_bytes)\n        : m_buffer(nullptr), m_current_size(0), m_allocated_capacity(0) {\n        if (initial_capacity_bytes > 0) {\n            m_buffer = (uint8_t*)malloc(initial_capacity_bytes);\n            if (m_buffer) {\n                m_allocated_capacity = initial_capacity_bytes;\n            }\n        }\n    }\n\n    ~VehicleConfigStoreVulnerable() {\n        if (m_buffer) {\n            free(m_buffer);\n        }\n    }\n\n    bool addConfigEntryVulnerable(uint16_t key_hash, const uint8_t* value_data, uint16_t len) {\n        if (!value_data || len == 0) {\n            return false;\n        }\n\n        size_t entry_data_size_needed = sizeof(ConfigEntryHeader) + len; \n\n        if (m_current_size + entry_data_size_needed > m_allocated_capacity) {\n            size_t new_capacity = m_allocated_capacity == 0 ? entry_data_size_needed : m_allocated_capacity * 2;\n            if (new_capacity < m_current_size + entry_data_size_needed) {\n                new_capacity = m_current_size + entry_data_size_needed;\n            }\n            \n            uint8_t* new_buffer = (uint8_t*)realloc(m_buffer, new_capacity);\n            if (!new_buffer) {\n                if (m_buffer) free(m_buffer);\n                m_buffer = nullptr;\n                m_current_size = 0;\n                m_allocated_capacity = 0;\n                return false;\n            }\n            m_buffer = new_buffer;\n            m_allocated_capacity = new_capacity;\n        }\n\n        if (!m_buffer) {\n            return false;\n        }\n\n        ConfigEntryHeader header = {key_hash, len};\n        memcpy(m_buffer + m_current_size, &header, sizeof(ConfigEntryHeader));\n        \n        memcpy(m_buffer + m_current_size + sizeof(ConfigEntryHeader), value_data, len);\n\n        m_buffer[m_current_size + sizeof(ConfigEntryHeader) + len] = '\\0';\n\n        m_current_size += entry_data_size_needed; \n\n        return true;\n    }\n\n    const uint8_t* getRawBuffer() const { return m_buffer; }\n    size_t getCurrentSize() const { return m_current_size; }\n    size_t getAllocatedCapacity() const { return m_allocated_capacity; }\n\nprivate:\n    uint8_t* m_buffer;\n    size_t   m_current_size;\n    size_t   m_allocated_capacity;\n};",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <limits>\n\nstruct ConfigEntryHeader {\n    uint16_t key_hash;\n    uint16_t value_length; \n};\n\nclass VehicleConfigStoreFixed {\npublic:\n    VehicleConfigStoreFixed(size_t initial_capacity_bytes)\n        : m_buffer(nullptr), m_current_size(0), m_allocated_capacity(0) {\n        if (initial_capacity_bytes > 0) {\n            m_buffer = (uint8_t*)malloc(initial_capacity_bytes);\n            if (m_buffer) {\n                m_allocated_capacity = initial_capacity_bytes;\n            }\n        }\n    }\n\n    ~VehicleConfigStoreFixed() {\n        if (m_buffer) {\n            free(m_buffer);\n        }\n    }\n\n    bool addConfigEntryFixed(uint16_t key_hash, const uint8_t* value_data, uint16_t len) {\n        if (!value_data || len == 0) {\n            return false;\n        }\n\n        size_t entry_data_size_needed = sizeof(ConfigEntryHeader) + len + 1; \n\n        if (sizeof(ConfigEntryHeader) > std::numeric_limits<size_t>::max() - (len + 1)) {\n            return false;\n        }\n\n        if (m_current_size > std::numeric_limits<size_t>::max() - entry_data_size_needed) {\n            return false;\n        }\n        \n        if (m_current_size + entry_data_size_needed > m_allocated_capacity) {\n            size_t new_capacity = m_allocated_capacity == 0 ? entry_data_size_needed : m_allocated_capacity * 2;\n\n            if (m_allocated_capacity > (std::numeric_limits<size_t>::max() / 2) && m_allocated_capacity != 0) {\n                 new_capacity = std::numeric_limits<size_t>::max();\n            }\n            if (new_capacity < m_current_size + entry_data_size_needed) {\n                new_capacity = m_current_size + entry_data_size_needed;\n            }\n            \n            uint8_t* new_buffer = (uint8_t*)realloc(m_buffer, new_capacity);\n            if (!new_buffer) {\n                if (m_buffer) free(m_buffer);\n                m_buffer = nullptr;\n                m_current_size = 0;\n                m_allocated_capacity = 0;\n                return false;\n            }\n            m_buffer = new_buffer;\n            m_allocated_capacity = new_capacity;\n        }\n\n        if (!m_buffer) {\n            return false;\n        }\n\n        ConfigEntryHeader header = {key_hash, len};\n        memcpy(m_buffer + m_current_size, &header, sizeof(ConfigEntryHeader));\n        \n        memcpy(m_buffer + m_current_size + sizeof(ConfigEntryHeader), value_data, len);\n\n        m_buffer[m_current_size + sizeof(ConfigEntryHeader) + len] = '\\0';\n\n        m_current_size += entry_data_size_needed; \n\n        return true;\n    }\n\n    const uint8_t* getRawBuffer() const { return m_buffer; }\n    size_t getCurrentSize() const { return m_current_size; }\n    size_t getAllocatedCapacity() const { return m_allocated_capacity; }\n\nprivate:\n    uint8_t* m_buffer;\n    size_t   m_current_size;\n    size_t   m_allocated_capacity;\n};",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstddef>\n#include <vector>\n#include <new>\n#include <cstring>\n#include <cstdlib>\n\nstruct ConfigEntryMetadata {\n    uint32_t key_offset;\n    uint16_t key_len;\n    uint32_t value_offset;\n    uint16_t value_len;\n};\n\nclass VehicleConfigManagerVulnerable {\npublic:\n    VehicleConfigManagerVulnerable() : m_dataBuffer(nullptr), m_currentDataSize(0), m_allocatedCapacity(0) {\n        m_allocatedCapacity = 256;\n        m_dataBuffer = (uint8_t*)malloc(m_allocatedCapacity);\n        if (!m_dataBuffer) {\n            m_allocatedCapacity = 0;\n        }\n    }\n\n    ~VehicleConfigManagerVulnerable() {\n        if (m_dataBuffer) {\n            free(m_dataBuffer);\n            m_dataBuffer = nullptr;\n        }\n    }\n\n    bool addConfigEntryVulnerable(const char* key, uint16_t key_len, const char* value, uint16_t value_len) {\n        if (!key || !value) {\n            return false;\n        }\n\n        uint16_t entry_data_len = key_len + 1 + value_len + 1;\n\n        size_t required_total_size = m_currentDataSize + entry_data_len;\n\n        if (required_total_size > m_allocatedCapacity) {\n            uint8_t* new_buffer = (uint8_t*)realloc(m_dataBuffer, required_total_size);\n            if (!new_buffer) {\n                return false;\n            }\n            m_dataBuffer = new_buffer;\n            m_allocatedCapacity = required_total_size;\n        }\n\n        ConfigEntryMetadata new_metadata;\n        new_metadata.key_offset = m_currentDataSize;\n        new_metadata.key_len = key_len;\n        new_metadata.value_offset = m_currentDataSize + key_len + 1;\n        new_metadata.value_len = value_len;\n        m_configEntries.push_back(new_metadata);\n\n        memcpy(m_dataBuffer + m_currentDataSize, key, key_len);\n        m_dataBuffer[m_currentDataSize + key_len] = '\\0';\n\n        memcpy(m_dataBuffer + new_metadata.value_offset, value, value_len);\n        m_dataBuffer[new_metadata.value_offset + value_len] = '\\0';\n\n        m_currentDataSize += (key_len + 1 + value_len + 1);\n\n        return true;\n    }\n\n    const uint8_t* getDataBuffer() const { return m_dataBuffer; }\n    size_t getCurrentDataSize() const { return m_currentDataSize; }\n    size_t getAllocatedCapacity() const { return m_allocatedCapacity; }\n    const std::vector<ConfigEntryMetadata>& getConfigEntries() const { return m_configEntries; }\n\nprivate:\n    uint8_t* m_dataBuffer;\n    size_t m_currentDataSize;\n    size_t m_allocatedCapacity;\n    std::vector<ConfigEntryMetadata> m_configEntries;\n}",
    "fixed_code": "#include <cstdint>\n#include <cstddef>\n#include <vector>\n#include <new>\n#include <cstring>\n#include <cstdlib>\n#include <limits>\n\nstruct ConfigEntryMetadata {\n    uint32_t key_offset;\n    uint16_t key_len;\n    uint32_t value_offset;\n    uint16_t value_len;\n};\n\nclass VehicleConfigManagerFixed {\npublic:\n    VehicleConfigManagerFixed() : m_dataBuffer(nullptr), m_currentDataSize(0), m_allocatedCapacity(0) {\n        m_allocatedCapacity = 256;\n        m_dataBuffer = (uint8_t*)malloc(m_allocatedCapacity);\n        if (!m_dataBuffer) {\n            m_allocatedCapacity = 0;\n        }\n    }\n\n    ~VehicleConfigManagerFixed() {\n        if (m_dataBuffer) {\n            free(m_dataBuffer);\n            m_dataBuffer = nullptr;\n        }\n    }\n\n    bool addConfigEntryFixed(const char* key, uint16_t key_len, const char* value, uint16_t value_len) {\n        if (!key || !value) {\n            return false;\n        }\n\n        static const uint16_t MAX_KEY_LEN = 2048; \n        static const uint16_t MAX_VALUE_LEN = 2048; \n\n        if (key_len > MAX_KEY_LEN || value_len > MAX_VALUE_LEN) {\n            return false;\n        }\n\n        if (key_len > (std::numeric_limits<size_t>::max() - 1 - value_len - 1)) {\n            return false;\n        }\n        size_t required_data_for_new_entry = (size_t)key_len + 1 + (size_t)value_len + 1;\n\n        if (m_currentDataSize > (std::numeric_limits<size_t>::max() - required_data_for_new_entry)) {\n            return false;\n        }\n        size_t required_total_size = m_currentDataSize + required_data_for_new_entry;\n\n        static const size_t MAX_TOTAL_CONFIG_SIZE = 64 * 1024; \n        if (required_total_size > MAX_TOTAL_CONFIG_SIZE) {\n            return false;\n        }\n\n        if (required_total_size > m_allocatedCapacity) {\n            uint8_t* new_buffer = (uint8_t*)realloc(m_dataBuffer, required_total_size);\n            if (!new_buffer) {\n                return false;\n            }\n            m_dataBuffer = new_buffer;\n            m_allocatedCapacity = required_total_size;\n        }\n\n        ConfigEntryMetadata new_metadata;\n        new_metadata.key_offset = static_cast<uint32_t>(m_currentDataSize);\n        new_metadata.key_len = key_len;\n        new_metadata.value_offset = static_cast<uint32_t>(m_currentDataSize + key_len + 1);\n        new_metadata.value_len = value_len;\n        m_configEntries.push_back(new_metadata);\n\n        memcpy(m_dataBuffer + m_currentDataSize, key, key_len);\n        m_dataBuffer[m_currentDataSize + key_len] = '\\0';\n\n        memcpy(m_dataBuffer + new_metadata.value_offset, value, value_len);\n        m_dataBuffer[new_metadata.value_offset + value_len] = '\\0';\n\n        m_currentDataSize += required_data_for_new_entry;\n\n        return true;\n    }\n\n    const uint8_t* getDataBuffer() const { return m_dataBuffer; }\n    size_t getCurrentDataSize() const { return m_currentDataSize; }\n    size_t getAllocatedCapacity() const { return m_allocatedCapacity; }\n    const std::vector<ConfigEntryMetadata>& getConfigEntries() const { return m_configEntries; }\n\nprivate:\n    uint8_t* m_dataBuffer;\n    size_t m_currentDataSize;\n    size_t m_allocatedCapacity;\n    std::vector<ConfigEntryMetadata> m_configEntries;\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstddef>\n#include <vector>\n#include <new>\n\n// Represents the format of an incoming network/internal packet header for sensor data batches.\nstruct SensorBatchPacketHeader {\n    uint16_t packet_magic;\n    uint16_t num_readings;\n    uint32_t aggregate_data_payload_size; // Sum of all 'data_length' from individual readings in the packet\n};\n\n// Represents the format of an individual sensor reading entry as it appears in the raw packet\n// and how it's intended to be stored contiguously in the internal buffer.\nstruct RawSensorReadingEntry {\n    uint16_t sensor_id;\n    uint32_t timestamp;\n    uint16_t data_length; // The length of the actual data bytes for THIS reading (following this header)\n    // uint8_t data[]; // Variable length data conceptually follows this header\n};\n\nclass DynamicSensorDataLogger {\npublic:\n    DynamicSensorDataLogger() : m_storage_buffer(nullptr), m_allocated_capacity(0), m_current_size(0) {}\n\n    ~DynamicSensorDataLogger() {\n        if (m_storage_buffer) {\n            delete[] m_storage_buffer;\n        }\n    }\n\n    void clearBuffer() {\n        if (m_storage_buffer) {\n            delete[] m_storage_buffer;\n            m_storage_buffer = nullptr;\n        }\n        m_allocated_capacity = 0;\n        m_current_size = 0;\n    }\n\n    // Processes a raw packet containing a batch of sensor data readings.\n    // VULNERABILITY: Heap-based buffer overflow due to incorrect allocation size.\n    bool processSensorDataBatchVulnerable(const uint8_t* raw_packet, size_t packet_length) {\n        if (!raw_packet || packet_length < sizeof(SensorBatchPacketHeader)) {\n            return false;\n        }\n\n        const SensorBatchPacketHeader* batch_header = reinterpret_cast<const SensorBatchPacketHeader*>(raw_packet);\n\n        if (batch_header->packet_magic != 0xFEED) { // Validate magic number\n            return false;\n        }\n\n        // Check if the total payload size advertised in the header exceeds the provided packet length.\n        // This is a necessary boundary check for the incoming packet, but not sufficient for the heap allocation.\n        if (batch_header->aggregate_data_payload_size > (packet_length - sizeof(SensorBatchPacketHeader))) {\n            return false;\n        }\n\n        clearBuffer();\n\n        // VULNERABILITY:\n        // The internal storage buffer is allocated *only* based on 'aggregate_data_payload_size'\n        // from the batch header. This size is intended to cover only the variable-length data\n        // portions of all readings.\n        // However, each RawSensorReadingEntry also includes a fixed-size header (sensor_id, timestamp, data_length)\n        // which will also be copied into this buffer. This fixed-size header space is *not* accounted for in the allocation.\n        m_storage_buffer = new (std::nothrow) uint8_t[batch_header->aggregate_data_payload_size];\n        if (!m_storage_buffer && batch_header->aggregate_data_payload_size > 0) {\n            return false;\n        }\n        m_allocated_capacity = batch_header->aggregate_data_payload_size;\n        m_current_size = 0;\n\n        size_t current_packet_read_offset = sizeof(SensorBatchPacketHeader);\n\n        for (uint16_t i = 0; i < batch_header->num_readings; ++i) {\n            // Ensure there's enough packet data for at least an individual reading header.\n            if (current_packet_read_offset + sizeof(RawSensorReadingEntry) > packet_length) {\n                clearBuffer();\n                return false;\n            }\n\n            const RawSensorReadingEntry* reading_header = reinterpret_cast<const RawSensorReadingEntry*>(raw_packet + current_packet_read_offset);\n\n            // Calculate the total size of this single entry (fixed header + variable data payload).\n            size_t current_entry_total_size = sizeof(RawSensorReadingEntry) + reading_header->data_length;\n\n            // Check if the current entry's data extends beyond the remaining packet data.\n            if (current_packet_read_offset + current_entry_total_size > packet_length) {\n                clearBuffer();\n                return false;\n            }\n            \n            // Copy the entire RawSensorReadingEntry (its fixed header + its data payload)\n            // from the raw packet into the internal storage buffer.\n            // As 'm_current_size' accumulates 'current_entry_total_size' for each reading,\n            // it will quickly exceed 'm_allocated_capacity' because 'm_allocated_capacity'\n            // only accounts for the sum of 'data_length's, not also 'sizeof(RawSensorReadingEntry)' for each.\n            // This loop will write past the end of 'm_storage_buffer' if there are multiple readings.\n            for (size_t k = 0; k < current_entry_total_size; ++k) {\n                m_storage_buffer[m_current_size + k] = raw_packet[current_packet_read_offset + k];\n            }\n\n            // Advance offsets for the next reading.\n            m_current_size += current_entry_total_size; // Tracks bytes written to internal buffer\n            current_packet_read_offset += current_entry_total_size; // Tracks bytes consumed from source packet\n        }\n\n        return true;\n    }\n\n    const uint8_t* getStoredData() const { return m_storage_buffer; }\n    size_t getStoredDataSize() const { return m_current_size; }\n    size_t getAllocatedCapacity() const { return m_allocated_capacity; }\n\nprivate:\n    uint8_t* m_storage_buffer;\n    size_t   m_allocated_capacity;\n    size_t   m_current_size;\n};",
    "fixed_code": "#include <cstdint>\n#include <cstddef>\n#include <vector>\n#include <new>\n#include <limits>\n#include <algorithm>\n\n// Represents the format of an incoming network/internal packet header for sensor data batches.\nstruct SensorBatchPacketHeader {\n    uint16_t packet_magic;\n    uint16_t num_readings;\n    uint32_t aggregate_data_payload_size; // Sum of all 'data_length' from individual readings in the packet\n};\n\n// Represents the format of an individual sensor reading entry as it appears in the raw packet\n// and how it's intended to be stored contiguously in the internal buffer.\nstruct RawSensorReadingEntry {\n    uint16_t sensor_id;\n    uint32_t timestamp;\n    uint16_t data_length; // The length of the actual data bytes for THIS reading (following this header)\n    // uint8_t data[]; // Variable length data conceptually follows this header\n};\n\nclass DynamicSensorDataLogger {\npublic:\n    DynamicSensorDataLogger() : m_storage_buffer(nullptr), m_allocated_capacity(0), m_current_size(0) {}\n\n    ~DynamicSensorDataLogger() {\n        if (m_storage_buffer) {\n            delete[] m_storage_buffer;\n        }\n    }\n\n    void clearBuffer() {\n        if (m_storage_buffer) {\n            delete[] m_storage_buffer;\n            m_storage_buffer = nullptr;\n        }\n        m_allocated_capacity = 0;\n        m_current_size = 0;\n    }\n\n    // Processes a raw packet containing a batch of sensor data readings (fixed version).\n    bool processSensorDataBatchFixed(const uint8_t* raw_packet, size_t packet_length) {\n        if (!raw_packet || packet_length < sizeof(SensorBatchPacketHeader)) {\n            return false;\n        }\n\n        const SensorBatchPacketHeader* batch_header = reinterpret_cast<const SensorBatchPacketHeader*>(raw_packet);\n\n        if (batch_header->packet_magic != 0xFEED) {\n            return false;\n        }\n\n        // Add reasonable limits to prevent excessive resource consumption (DoS).\n        static const uint16_t MAX_READINGS = 1000;\n        if (batch_header->num_readings > MAX_READINGS) {\n            return false;\n        }\n        static const uint16_t MAX_SINGLE_PAYLOAD_LEN = 1500; // E.g., based on MTU\n\n        // Check if the total payload size advertised in the header exceeds the provided packet length.\n        if (batch_header->aggregate_data_payload_size > (packet_length - sizeof(SensorBatchPacketHeader))) {\n            return false;\n        }\n\n        clearBuffer();\n\n        // FIX:\n        // Calculate the *correct* total required size for the internal buffer.\n        // This must include the size of each RawSensorReadingEntry header\n        // *plus* the aggregate data payload.\n        size_t headers_total_size;\n        // Prevent integer overflow for multiplication.\n        if (batch_header->num_readings > (std::numeric_limits<size_t>::max() / sizeof(RawSensorReadingEntry))) {\n            return false;\n        }\n        headers_total_size = batch_header->num_readings * sizeof(RawSensorReadingEntry);\n\n        size_t total_required_buffer_size;\n        // Prevent integer overflow for addition.\n        if (headers_total_size > (std::numeric_limits<size_t>::max() - batch_header->aggregate_data_payload_size)) {\n            return false;\n        }\n        total_required_buffer_size = headers_total_size + batch_header->aggregate_data_payload_size;\n\n        // Handle edge case of zero-sized allocation request for non-zero number of readings.\n        if (total_required_buffer_size == 0 && batch_header->num_readings > 0) {\n             return false;\n        }\n        // Handle graceful exit for empty batches.\n        if (total_required_buffer_size == 0 && batch_header->num_readings == 0) {\n            return true;\n        }\n\n        m_storage_buffer = new (std::nothrow) uint8_t[total_required_buffer_size];\n        if (!m_storage_buffer) {\n            return false;\n        }\n        m_allocated_capacity = total_required_buffer_size;\n        m_current_size = 0;\n\n        size_t current_packet_read_offset = sizeof(SensorBatchPacketHeader);\n        uint32_t accumulated_payload_length_from_entries = 0; // For final consistency check\n\n        for (uint16_t i = 0; i < batch_header->num_readings; ++i) {\n            // Ensure enough packet data for the current individual reading header.\n            if (current_packet_read_offset + sizeof(RawSensorReadingEntry) > packet_length) {\n                clearBuffer();\n                return false;\n            }\n\n            const RawSensorReadingEntry* reading_header = reinterpret_cast<const RawSensorReadingEntry*>(raw_packet + current_packet_read_offset);\n\n            size_t current_entry_payload_len = reading_header->data_length;\n            \n            // Enforce maximum individual payload length.\n            if (current_entry_payload_len > MAX_SINGLE_PAYLOAD_LEN) {\n                clearBuffer();\n                return false;\n            }\n\n            size_t current_entry_total_size = sizeof(RawSensorReadingEntry) + current_entry_payload_len;\n\n            // Check if the current entry's data extends beyond the remaining packet data.\n            if (current_packet_read_offset + current_entry_total_size > packet_length) {\n                clearBuffer();\n                return false;\n            }\n            \n            // FIX: Crucial check to prevent heap buffer overflow.\n            // Ensure there is enough space remaining in the allocated internal buffer\n            // before attempting to copy the current entry.\n            if (m_current_size > (m_allocated_capacity - current_entry_total_size)) {\n                clearBuffer();\n                return false; // Not enough space left in our allocated buffer\n            }\n\n            // Copy the entire RawSensorReadingEntry (its fixed header + its data payload).\n            for (size_t k = 0; k < current_entry_total_size; ++k) {\n                m_storage_buffer[m_current_size + k] = raw_packet[current_packet_read_offset + k];\n            }\n\n            // Advance offsets for the next reading.\n            m_current_size += current_entry_total_size;\n            current_packet_read_offset += current_entry_total_size;\n\n            // Accumulate payload length for final consistency check. Add overflow protection.\n            if (accumulated_payload_length_from_entries > (std::numeric_limits<uint32_t>::max() - current_entry_payload_len)) {\n                clearBuffer();\n                return false;\n            }\n            accumulated_payload_length_from_entries += current_entry_payload_len;\n        }\n\n        // Final consistency checks:\n        // 1. Ensure the sum of individual data_lengths matches the advertised aggregate_data_payload_size.\n        // 2. Ensure the total bytes written to the internal buffer matches the calculated total_required_buffer_size.\n        if (accumulated_payload_length_from_entries != batch_header->aggregate_data_payload_size ||\n            m_current_size != total_required_buffer_size) {\n            clearBuffer();\n            return false;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getStoredData() const { return m_storage_buffer; }\n    size_t getStoredDataSize() const { return m_current_size; }\n    size_t getAllocatedCapacity() const { return m_allocated_capacity; }\n\nprivate:\n    uint8_t* m_storage_buffer;\n    size_t   m_allocated_capacity;\n    size_t   m_current_size;\n};",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <new>\n#include <limits>\n\n// Represents a raw sensor data packet header received over a bus.\nstruct RawSensorPacketHeader {\n    uint16_t packet_id;\n    uint16_t num_readings; // Number of uint16_t readings following the header\n    uint32_t checksum;     // Simple checksum for integrity\n};\n\n// Class to process raw sensor data into floating-point format for internal use.\nclass SensorDataProcessorVulnerable {\npublic:\n    SensorDataProcessorVulnerable() : m_processed_data(nullptr), m_num_elements(0), m_allocated_bytes(0) {}\n\n    ~SensorDataProcessorVulnerable() {\n        if (m_processed_data) {\n            free(m_processed_data);\n            m_processed_data = nullptr;\n        }\n    }\n\n    // Processes a raw sensor data packet, converting uint16_t readings to float.\n    // VULNERABILITY: Heap-based buffer overflow due to incorrect allocation size for type conversion.\n    bool processRawSensorDataVulnerable(const uint8_t* raw_packet, size_t packet_length) {\n        if (!raw_packet || packet_length < sizeof(RawSensorPacketHeader)) {\n            return false;\n        }\n\n        const RawSensorPacketHeader* header = reinterpret_cast<const RawSensorPacketHeader*>(raw_packet);\n\n        if (header->packet_id != 0xABCD) { // Simple magic check for realism\n            return false;\n        }\n\n        // Basic sanity check on packet length for the raw data payload\n        // This checks if the packet contains enough raw data based on 'num_readings' and 'uint16_t' size.\n        if (header->num_readings > (std::numeric_limits<size_t>::max() / sizeof(uint16_t))) {\n            return false; // Prevent integer overflow for this length calculation\n        }\n        size_t expected_raw_data_size = static_cast<size_t>(header->num_readings) * sizeof(uint16_t);\n        \n        if (packet_length < sizeof(RawSensorPacketHeader) + expected_raw_data_size) {\n            return false;\n        }\n\n        // Free existing buffer if any\n        if (m_processed_data) {\n            free(m_processed_data);\n            m_processed_data = nullptr;\n        }\n\n        // VULNERABILITY:\n        // The allocation size is calculated based on the *original* uint16_t size, not the target float size.\n        // If sizeof(float) > sizeof(uint16_t) (e.g., 4 bytes vs 2 bytes), this allocation is too small.\n        // For example, if num_readings is 100:\n        // Allocated: 100 * 2 = 200 bytes\n        // Needed:    100 * 4 = 400 bytes (for float)\n        // The loop iterating through 'i' will eventually write past the end of 'm_processed_data'.\n        m_allocated_bytes = static_cast<size_t>(header->num_readings) * sizeof(uint16_t);\n        \n        m_processed_data = (float*)malloc(m_allocated_bytes);\n        if (!m_processed_data && m_allocated_bytes > 0) {\n            return false;\n        }\n        \n        m_num_elements = header->num_readings;\n\n        const uint16_t* raw_readings_ptr = reinterpret_cast<const uint16_t*>(raw_packet + sizeof(RawSensorPacketHeader));\n\n        for (uint16_t i = 0; i < m_num_elements; ++i) {\n            // This write operation expects 'm_processed_data' to hold 'float' type elements.\n            // As 'i' increments, the access m_processed_data[i] will go out of bounds of the \n            // buffer allocated based on 'sizeof(uint16_t)'.\n            m_processed_data[i] = static_cast<float>(raw_readings_ptr[i]);\n        }\n\n        // Additional check for checksum (for realism, not directly related to the overflow)\n        uint32_t calculated_checksum = 0;\n        for (uint16_t i = 0; i < header->num_readings; ++i) {\n            calculated_checksum += raw_readings_ptr[i];\n        }\n        if (calculated_checksum != header->checksum) {\n            if (m_processed_data) {\n                free(m_processed_data);\n                m_processed_data = nullptr;\n            }\n            m_num_elements = 0;\n            m_allocated_bytes = 0;\n            return false;\n        }\n\n        return true;\n    }\n\n    const float* getProcessedData() const { return m_processed_data; }\n    uint16_t getNumElements() const { return m_num_elements; }\n\nprivate:\n    float*   m_processed_data;\n    uint16_t m_num_elements;\n    size_t   m_allocated_bytes;\n};",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <new>\n#include <limits>\n\n// Represents a raw sensor data packet header received over a bus.\nstruct RawSensorPacketHeader {\n    uint16_t packet_id;\n    uint16_t num_readings; // Number of uint16_t readings following the header\n    uint32_t checksum;     // Simple checksum for integrity\n};\n\n// Class to process raw sensor data into floating-point format for internal use.\nclass SensorDataProcessorFixed {\npublic:\n    SensorDataProcessorFixed() : m_processed_data(nullptr), m_num_elements(0), m_allocated_bytes(0) {}\n\n    ~SensorDataProcessorFixed() {\n        if (m_processed_data) {\n            free(m_processed_data);\n            m_processed_data = nullptr;\n        }\n    }\n\n    // Processes a raw sensor data packet, converting uint16_t readings to float.\n    // FIX: Correctly allocates buffer based on target data type size (float).\n    bool processRawSensorDataFixed(const uint8_t* raw_packet, size_t packet_length) {\n        if (!raw_packet || packet_length < sizeof(RawSensorPacketHeader)) {\n            return false;\n        }\n\n        const RawSensorPacketHeader* header = reinterpret_cast<const RawSensorPacketHeader*>(raw_packet);\n\n        if (header->packet_id != 0xABCD) {\n            return false;\n        }\n\n        // Basic sanity check on packet length for the raw data payload\n        if (header->num_readings > (std::numeric_limits<size_t>::max() / sizeof(uint16_t))) {\n            return false; // Prevent integer overflow for this length calculation\n        }\n        size_t expected_raw_data_size = static_cast<size_t>(header->num_readings) * sizeof(uint16_t);\n\n        if (packet_length < sizeof(RawSensorPacketHeader) + expected_raw_data_size) {\n            return false;\n        }\n\n        // Free existing buffer if any\n        if (m_processed_data) {\n            free(m_processed_data);\n            m_processed_data = nullptr;\n        }\n\n        // FIX:\n        // The allocation size is now correctly calculated based on the *target* data type size (float).\n        // Also, add an integer overflow check for the multiplication.\n        if (header->num_readings > (std::numeric_limits<size_t>::max() / sizeof(float))) {\n            return false; // Prevent integer overflow during allocation size calculation\n        }\n        m_allocated_bytes = static_cast<size_t>(header->num_readings) * sizeof(float);\n        \n        m_processed_data = (float*)malloc(m_allocated_bytes);\n        if (!m_processed_data && m_allocated_bytes > 0) { // If allocation fails for non-zero size\n            return false;\n        }\n        \n        m_num_elements = header->num_readings;\n\n        const uint16_t* raw_readings_ptr = reinterpret_cast<const uint16_t*>(raw_packet + sizeof(RawSensorPacketHeader));\n\n        for (uint16_t i = 0; i < m_num_elements; ++i) {\n            // Now, m_processed_data is allocated with enough space for 'float' elements,\n            // so accessing m_processed_data[i] will be within bounds.\n            m_processed_data[i] = static_cast<float>(raw_readings_ptr[i]);\n        }\n\n        // Additional check for checksum\n        uint32_t calculated_checksum = 0;\n        for (uint16_t i = 0; i < header->num_readings; ++i) {\n            calculated_checksum += raw_readings_ptr[i];\n        }\n        if (calculated_checksum != header->checksum) {\n            if (m_processed_data) {\n                free(m_processed_data);\n                m_processed_data = nullptr;\n            }\n            m_num_elements = 0;\n            m_allocated_bytes = 0;\n            return false;\n        }\n\n        return true;\n    }\n\n    const float* getProcessedData() const { return m_processed_data; }\n    uint16_t getNumElements() const { return m_num_elements; }\n\nprivate:\n    float*   m_processed_data;\n    uint16_t m_num_elements;\n    size_t   m_allocated_bytes;\n};",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <limits>\n\nstruct SensorSample {\n    uint32_t timestamp;\n    int16_t  value_x;\n    int16_t  value_y;\n    int16_t  value_z;\n    uint8_t  status;\n};\n\nstruct SensorPacketHeader {\n    uint16_t packet_id;\n    uint32_t offset_in_total_stream;\n    uint32_t num_samples_in_packet;\n};\n\nclass SensorDataRecorderVulnerable {\npublic:\n    SensorDataRecorderVulnerable(size_t max_recording_bytes)\n        : m_recording_buffer(nullptr), m_allocated_size(0) {\n        if (max_recording_bytes > 0) {\n            m_recording_buffer = (uint8_t*)malloc(max_recording_bytes);\n            if (m_recording_buffer) {\n                m_allocated_size = max_recording_bytes;\n            }\n        }\n    }\n\n    ~SensorDataRecorderVulnerable() {\n        if (m_recording_buffer) {\n            free(m_recording_buffer);\n            m_recording_buffer = nullptr;\n        }\n    }\n\n    bool processSensorDataPacketVulnerable(const uint8_t* packet_data, size_t packet_len) {\n        if (!packet_data || packet_len < sizeof(SensorPacketHeader)) {\n            return false;\n        }\n\n        const SensorPacketHeader* header = reinterpret_cast<const SensorPacketHeader*>(packet_data);\n\n        uint32_t expected_packet_data_length_bytes = header->num_samples_in_packet * sizeof(SensorSample);\n\n        uint32_t dest_offset = header->offset_in_total_stream;\n\n        if (dest_offset + expected_packet_data_length_bytes > m_allocated_size) {\n            return false;\n        }\n\n        if (packet_len < sizeof(SensorPacketHeader) + (size_t)header->num_samples_in_packet * sizeof(SensorSample)) {\n            return false;\n        }\n\n        size_t source_data_read_offset = sizeof(SensorPacketHeader);\n\n        for (uint32_t i = 0; i < header->num_samples_in_packet; ++i) {\n            size_t current_sample_size = sizeof(SensorSample);\n            \n            size_t current_source_pos = source_data_read_offset + (size_t)i * current_sample_size;\n            size_t current_dest_pos = dest_offset + (size_t)i * current_sample_size;\n\n            for (size_t k = 0; k < current_sample_size; ++k) {\n                m_recording_buffer[current_dest_pos + k] = packet_data[current_source_pos + k];\n            }\n        }\n\n        return true;\n    }\n\n    size_t getAllocatedSize() const {\n        return m_allocated_size;\n    }\n\n    const uint8_t* getRecordingBuffer() const {\n        return m_recording_buffer;\n    }\n\nprivate:\n    uint8_t* m_recording_buffer;\n    size_t m_allocated_size;\n};",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <limits>\n\nstruct SensorSample {\n    uint32_t timestamp;\n    int16_t  value_x;\n    int16_t  value_y;\n    int16_t  value_z;\n    uint8_t  status;\n};\n\nstruct SensorPacketHeader {\n    uint16_t packet_id;\n    uint32_t offset_in_total_stream;\n    uint32_t num_samples_in_packet;\n};\n\nclass SensorDataRecorderFixed {\npublic:\n    SensorDataRecorderFixed(size_t max_recording_bytes)\n        : m_recording_buffer(nullptr), m_allocated_size(0) {\n        if (max_recording_bytes > 0) {\n            m_recording_buffer = (uint8_t*)malloc(max_recording_bytes);\n            if (m_recording_buffer) {\n                m_allocated_size = max_recording_bytes;\n            }\n        }\n    }\n\n    ~SensorDataRecorderFixed() {\n        if (m_recording_buffer) {\n            free(m_recording_buffer);\n            m_recording_buffer = nullptr;\n        }\n    }\n\n    bool processSensorDataPacketFixed(const uint8_t* packet_data, size_t packet_len) {\n        if (!packet_data || packet_len < sizeof(SensorPacketHeader)) {\n            return false;\n        }\n\n        const SensorPacketHeader* header = reinterpret_cast<const SensorPacketHeader*>(packet_data);\n\n        size_t samples_data_length;\n        if (header->num_samples_in_packet > std::numeric_limits<size_t>::max() / sizeof(SensorSample)) {\n            return false;\n        }\n        samples_data_length = (size_t)header->num_samples_in_packet * sizeof(SensorSample);\n\n        size_t dest_offset = header->offset_in_total_stream;\n\n        if (dest_offset > std::numeric_limits<size_t>::max() - samples_data_length) {\n            return false;\n        }\n        size_t end_write_pos = dest_offset + samples_data_length;\n\n        if (end_write_pos > m_allocated_size) {\n            return false;\n        }\n\n        if (packet_len < sizeof(SensorPacketHeader) + samples_data_length) {\n            return false;\n        }\n\n        size_t source_data_read_offset = sizeof(SensorPacketHeader);\n\n        for (uint32_t i = 0; i < header->num_samples_in_packet; ++i) {\n            size_t current_sample_size = sizeof(SensorSample);\n            \n            size_t current_source_pos = source_data_read_offset + (size_t)i * current_sample_size;\n            size_t current_dest_pos = dest_offset + (size_t)i * current_sample_size;\n\n            for (size_t k = 0; k < current_sample_size; ++k) {\n                m_recording_buffer[current_dest_pos + k] = packet_data[current_source_pos + k];\n            }\n        }\n\n        return true;\n    }\n\n    size_t getAllocatedSize() const {\n        return m_allocated_size;\n    }\n\n    const uint8_t* getRecordingBuffer() const {\n        return m_recording_buffer;\n    }\n\nprivate:\n    uint8_t* m_recording_buffer;\n    size_t m_allocated_size;\n};",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n\n#pragma pack(push, 1)\nstruct ModuleConfigHeader {\n    uint16_t module_id;\n    uint16_t payload_length; \n};\n#pragma pack(pop)\n\nconst size_t MAX_STORED_CONFIG_ENTRIES = 5; \nconst size_t ALLOC_SLOT_PAYLOAD_SIZE = 64; \n\nclass FirmwareConfigStorageVulnerable {\nprivate:\n    uint8_t* m_config_buffer;\n    size_t m_current_data_offset; \n    size_t m_total_allocated_capacity; \n    size_t m_num_stored_entries; \n\npublic:\n    FirmwareConfigStorageVulnerable() :\n        m_config_buffer(nullptr),\n        m_current_data_offset(0),\n        m_total_allocated_capacity(0),\n        m_num_stored_entries(0)\n    {\n        m_total_allocated_capacity = MAX_STORED_CONFIG_ENTRIES * (sizeof(ModuleConfigHeader) + ALLOC_SLOT_PAYLOAD_SIZE);\n        m_config_buffer = (uint8_t*)malloc(m_total_allocated_capacity);\n        if (!m_config_buffer) {\n            m_total_allocated_capacity = 0;\n        }\n    }\n\n    ~FirmwareConfigStorageVulnerable() {\n        if (m_config_buffer) {\n            free(m_config_buffer);\n        }\n    }\n\n    bool addModuleConfigEntryVulnerable(const uint8_t* raw_entry_data, size_t raw_entry_data_len) {\n        if (!m_config_buffer || !raw_entry_data || raw_entry_data_len < sizeof(ModuleConfigHeader)) {\n            return false;\n        }\n\n        const ModuleConfigHeader* header = reinterpret_cast<const ModuleConfigHeader*>(raw_entry_data);\n        uint16_t actual_payload_len = header->payload_length;\n\n        size_t incoming_entry_full_size = sizeof(ModuleConfigHeader) + actual_payload_len;\n\n        if (incoming_entry_full_size != raw_entry_data_len) {\n            return false;\n        }\n\n        if (m_num_stored_entries >= MAX_STORED_CONFIG_ENTRIES) {\n            return false;\n        }\n\n        size_t write_position_for_entry = m_num_stored_entries * (sizeof(ModuleConfigHeader) + ALLOC_SLOT_PAYLOAD_SIZE);\n\n        memcpy(m_config_buffer + write_position_for_entry, raw_entry_data, incoming_entry_full_size);\n\n        m_num_stored_entries++;\n\n        return true;\n    }\n\n    size_t getNumStoredEntries() const {\n        return m_num_stored_entries;\n    }\n\n    size_t getTotalAllocatedCapacity() const {\n        return m_total_allocated_capacity;\n    }\n\n    const uint8_t* getConfigBuffer() const {\n        return m_config_buffer;\n    }\n}",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n\n#pragma pack(push, 1)\nstruct ModuleConfigHeader {\n    uint16_t module_id;\n    uint16_t payload_length; \n};\n#pragma pack(pop)\n\nconst size_t MAX_STORED_CONFIG_ENTRIES = 5; \nconst size_t ALLOC_SLOT_PAYLOAD_SIZE = 64; \n\nclass FirmwareConfigStorageFixed {\nprivate:\n    uint8_t* m_config_buffer;\n    size_t m_current_data_offset; \n    size_t m_total_allocated_capacity; \n    size_t m_num_stored_entries; \n\npublic:\n    FirmwareConfigStorageFixed() :\n        m_config_buffer(nullptr),\n        m_current_data_offset(0),\n        m_total_allocated_capacity(0),\n        m_num_stored_entries(0)\n    {\n        m_total_allocated_capacity = MAX_STORED_CONFIG_ENTRIES * (sizeof(ModuleConfigHeader) + ALLOC_SLOT_PAYLOAD_SIZE);\n        m_config_buffer = (uint8_t*)malloc(m_total_allocated_capacity);\n        if (!m_config_buffer) {\n            m_total_allocated_capacity = 0;\n        }\n    }\n\n    ~FirmwareConfigStorageFixed() {\n        if (m_config_buffer) {\n            free(m_config_buffer);\n        }\n    }\n\n    bool addModuleConfigEntryFixed(const uint8_t* raw_entry_data, size_t raw_entry_data_len) {\n        if (!m_config_buffer || !raw_entry_data || raw_entry_data_len < sizeof(ModuleConfigHeader)) {\n            return false;\n        }\n\n        const ModuleConfigHeader* header = reinterpret_cast<const ModuleConfigHeader*>(raw_entry_data);\n        uint16_t actual_payload_len = header->payload_length;\n\n        if (actual_payload_len > ALLOC_SLOT_PAYLOAD_SIZE) {\n            return false; \n        }\n\n        size_t incoming_entry_full_size = sizeof(ModuleConfigHeader) + actual_payload_len;\n\n        if (incoming_entry_full_size != raw_entry_data_len) {\n            return false;\n        }\n\n        if (m_num_stored_entries >= MAX_STORED_CONFIG_ENTRIES) {\n            return false;\n        }\n\n        size_t write_position_for_entry = m_num_stored_entries * (sizeof(ModuleConfigHeader) + ALLOC_SLOT_PAYLOAD_SIZE);\n\n        if (write_position_for_entry + incoming_entry_full_size > m_total_allocated_capacity) {\n            return false; \n        }\n\n        memcpy(m_config_buffer + write_position_for_entry, raw_entry_data, incoming_entry_full_size);\n\n        m_num_stored_entries++;\n\n        return true;\n    }\n\n    size_t getNumStoredEntries() const {\n        return m_num_stored_entries;\n    }\n\n    size_t getTotalAllocatedCapacity() const {\n        return m_total_allocated_capacity;\n    }\n\n    const uint8_t* getConfigBuffer() const {\n        return m_config_buffer;\n    }\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <vector>\n#include <cstring>\n#include <new>\n\n// Represents a packet containing multiple string-based configuration entries.\n// total_string_bytes_in_packet: The sum of lengths of all strings present in this packet, WITHOUT null terminators.\n// num_strings: The count of individual strings in this packet.\nstruct ConfigPacketHeader {\n    uint32_t total_string_bytes_in_packet;\n    uint16_t num_strings;\n};\n\n// Each string entry within the packet payload has its own length.\nstruct StringEntryHeader {\n    uint16_t string_len; // Length of the string data, WITHOUT null terminator.\n};\n\nclass VehicleConfigLoaderVulnerable {\npublic:\n    VehicleConfigLoaderVulnerable() : m_config_strings_buffer(nullptr), m_buffer_capacity(0), m_current_offset(0) {}\n\n    ~VehicleConfigLoaderVulnerable() {\n        if (m_config_strings_buffer) {\n            free(m_config_strings_buffer);\n            m_config_strings_buffer = nullptr;\n        }\n    }\n\n    // Loads configuration strings from a raw packet.\n    // The packet is assumed to contain a ConfigPacketHeader followed by\n    // 'num_strings' entries, where each entry is a StringEntryHeader\n    // followed by its 'string_len' bytes of data.\n    bool loadConfigurationVulnerable(const uint8_t* packet_data, size_t packet_length) {\n        if (!packet_data || packet_length < sizeof(ConfigPacketHeader)) {\n            return false;\n        }\n\n        const ConfigPacketHeader* header = reinterpret_cast<const ConfigPacketHeader*>(packet_data);\n\n        // Basic sanity check: ensure total payload bytes claimed by header fits in the actual packet.\n        if (header->total_string_bytes_in_packet > (packet_length - sizeof(ConfigPacketHeader))) {\n            return false;\n        }\n        \n        // Deallocate existing buffer if any.\n        if (m_config_strings_buffer) {\n            free(m_config_strings_buffer);\n            m_config_strings_buffer = nullptr;\n        }\n\n        // VULNERABILITY:\n        // The buffer is allocated exactly based on 'total_string_bytes_in_packet'.\n        // The definition of 'total_string_bytes_in_packet' explicitly states it's WITHOUT null terminators.\n        // However, the loop below explicitly adds a null terminator after each string (m_config_strings_buffer[...]=\\0).\n        // For each of the 'num_strings' present, an extra byte (the null terminator) will be written\n        // beyond the allocated size, leading to a heap-based buffer overflow.\n        m_buffer_capacity = header->total_string_bytes_in_packet;\n        \n        m_config_strings_buffer = (char*)malloc(m_buffer_capacity);\n        if (!m_config_strings_buffer && m_buffer_capacity > 0) {\n            return false; // Allocation failed for a non-zero sized buffer.\n        }\n        \n        m_current_offset = 0;\n\n        const uint8_t* current_payload_ptr = packet_data + sizeof(ConfigPacketHeader);\n        size_t remaining_payload_data = packet_length - sizeof(ConfigPacketHeader);\n\n        for (uint16_t i = 0; i < header->num_strings; ++i) {\n            if (remaining_payload_data < sizeof(StringEntryHeader)) {\n                if (m_config_strings_buffer) { free(m_config_strings_buffer); m_config_strings_buffer = nullptr; }\n                return false;\n            }\n\n            const StringEntryHeader* string_hdr = reinterpret_cast<const StringEntryHeader*>(current_payload_ptr);\n            uint16_t current_string_len = string_hdr->string_len;\n\n            // Advance past the StringEntryHeader\n            current_payload_ptr += sizeof(StringEntryHeader);\n            remaining_payload_data -= sizeof(StringEntryHeader);\n\n            // Check if enough payload data remains for the string content in the input packet.\n            if (remaining_payload_data < current_string_len) {\n                if (m_config_strings_buffer) { free(m_config_strings_buffer); m_config_strings_buffer = nullptr; }\n                return false;\n            }\n            \n            // Copy string data to the internal buffer.\n            memcpy(m_config_strings_buffer + m_current_offset, current_payload_ptr, current_string_len);\n            \n            // Add null terminator after the string data.\n            // This is the operation that causes the heap-based buffer overflow if\n            // m_buffer_capacity was only calculated from 'total_string_bytes_in_packet'.\n            m_config_strings_buffer[m_current_offset + current_string_len] = '\\0'; \n            \n            m_current_offset += current_string_len + 1; // Advance offset, accounting for null terminator\n\n            // Advance past the string data in the input packet.\n            current_payload_ptr += current_string_len;\n            remaining_payload_data -= current_string_len;\n        }\n\n        return true;\n    }\n\n    const char* getConfigStringsBuffer() const { return m_config_strings_buffer; }\n    size_t getBufferSize() const { return m_current_offset; } // Return actual used size (including nulls)\n\nprivate:\n    char*  m_config_strings_buffer;\n    size_t m_buffer_capacity;\n    size_t m_current_offset;\n};",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <vector>\n#include <cstring>\n#include <new>\n#include <limits> // For std::numeric_limits\n\n// Represents a packet containing multiple string-based configuration entries.\n// total_string_bytes_in_packet: The sum of lengths of all strings present in this packet, WITHOUT null terminators.\n// num_strings: The count of individual strings in this packet.\nstruct ConfigPacketHeader {\n    uint32_t total_string_bytes_in_packet;\n    uint16_t num_strings;\n};\n\n// Each string entry within the packet payload has its own length.\nstruct StringEntryHeader {\n    uint16_t string_len; // Length of the string data, WITHOUT null terminator.\n};\n\nclass VehicleConfigLoaderFixed {\npublic:\n    VehicleConfigLoaderFixed() : m_config_strings_buffer(nullptr), m_buffer_capacity(0), m_current_offset(0) {}\n\n    ~VehicleConfigLoaderFixed() {\n        if (m_config_strings_buffer) {\n            free(m_config_strings_buffer);\n            m_config_strings_buffer = nullptr;\n        }\n    }\n\n    // Loads configuration strings from a raw packet.\n    // The packet is assumed to contain a ConfigPacketHeader followed by\n    // 'num_strings' entries, where each entry is a StringEntryHeader\n    // followed by its 'string_len' bytes of data.\n    bool loadConfigurationFixed(const uint8_t* packet_data, size_t packet_length) {\n        if (!packet_data || packet_length < sizeof(ConfigPacketHeader)) {\n            return false;\n        }\n\n        const ConfigPacketHeader* header = reinterpret_cast<const ConfigPacketHeader*>(packet_data);\n\n        // FIX:\n        // 1. Calculate the required total buffer size, accounting for null terminators for each string.\n        // 2. Add an integer overflow check for this calculation.\n        if (header->num_strings > (std::numeric_limits<size_t>::max() - header->total_string_bytes_in_packet)) {\n            return false; // Integer overflow if num_strings + total_string_bytes_in_packet exceeds size_t max.\n        }\n        size_t required_total_buffer_size = static_cast<size_t>(header->total_string_bytes_in_packet) + header->num_strings;\n\n        // Check if the input packet length is sufficient for all expected string data + individual string headers.\n        if (header->num_strings > (std::numeric_limits<size_t>::max() / sizeof(StringEntryHeader))) {\n            return false; // Prevent integer overflow in string entry header size calculation\n        }\n        size_t expected_packet_payload_size = static_cast<size_t>(header->num_strings) * sizeof(StringEntryHeader) + header->total_string_bytes_in_packet;\n\n        if (packet_length < sizeof(ConfigPacketHeader) + expected_packet_payload_size) {\n            return false;\n        }\n        \n        // Deallocate existing buffer if any.\n        if (m_config_strings_buffer) {\n            free(m_config_strings_buffer);\n            m_config_strings_buffer = nullptr;\n        }\n\n        // FIX: Allocate buffer with enough space for strings AND their null terminators.\n        m_buffer_capacity = required_total_buffer_size;\n        \n        m_config_strings_buffer = (char*)malloc(m_buffer_capacity);\n        if (!m_config_strings_buffer && m_buffer_capacity > 0) { // Check if allocation failed for non-zero sized buffer.\n            return false;\n        }\n        \n        m_current_offset = 0;\n\n        const uint8_t* current_payload_ptr = packet_data + sizeof(ConfigPacketHeader);\n        size_t remaining_payload_data = packet_length - sizeof(ConfigPacketHeader);\n\n        for (uint16_t i = 0; i < header->num_strings; ++i) {\n            if (remaining_payload_data < sizeof(StringEntryHeader)) {\n                if (m_config_strings_buffer) { free(m_config_strings_buffer); m_config_strings_buffer = nullptr; }\n                return false;\n            }\n\n            const StringEntryHeader* string_hdr = reinterpret_cast<const StringEntryHeader*>(current_payload_ptr);\n            uint16_t current_string_len = string_hdr->string_len;\n\n            // Advance past the StringEntryHeader\n            current_payload_ptr += sizeof(StringEntryHeader);\n            remaining_payload_data -= sizeof(StringEntryHeader);\n\n            // Check if enough payload data remains for the string content in the input packet.\n            if (remaining_payload_data < current_string_len) {\n                if (m_config_strings_buffer) { free(m_config_strings_buffer); m_config_strings_buffer = nullptr; }\n                return false;\n            }\n\n            // Check if there is enough space in the destination buffer for the current string AND its null terminator.\n            // This guards against malicious inputs where individual string lengths might exceed what's implied by total_string_bytes_in_packet\n            // or general inconsistencies, even after the initial buffer size calculation.\n            if (m_current_offset > (m_buffer_capacity - (current_string_len + 1))) {\n                 if (m_config_strings_buffer) { free(m_config_strings_buffer); m_config_strings_buffer = nullptr; }\n                 return false;\n            }\n            \n            // Copy string data to the internal buffer.\n            memcpy(m_config_strings_buffer + m_current_offset, current_payload_ptr, current_string_len);\n            \n            // Add null terminator after the string data. This is now safe as space was explicitly allocated.\n            m_config_strings_buffer[m_current_offset + current_string_len] = '\\0'; \n            \n            m_current_offset += current_string_len + 1; // Advance offset, accounting for null terminator\n\n            // Advance past the string data in the input packet.\n            current_payload_ptr += current_string_len;\n            remaining_payload_data -= current_string_len;\n        }\n\n        return true;\n    }\n\n    const char* getConfigStringsBuffer() const { return m_config_strings_buffer; }\n    size_t getBufferSize() const { return m_current_offset; } // Return actual used size (including nulls)\n\nprivate:\n    char*  m_config_strings_buffer;\n    size_t m_buffer_capacity;\n    size_t m_current_offset;\n};",
    "analysis": ""
  },
  {
    "cwe_id": "122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <new>\n#include <algorithm>\n\n// Define types for clarity\ntypedef uint8_t TelemetryBlockType;\n\n// Telemetry Block Types\nconst TelemetryBlockType TYPE_RAW_SENSOR_DATA = 0x01;\nconst TelemetryBlockType TYPE_TEXT_MESSAGE = 0x02;\nconst TelemetryBlockType TYPE_EVENT_CODE = 0x03;\n\nstruct TelemetryBlockHeader {\n    TelemetryBlockType block_type;\n    uint16_t block_id;\n    uint16_t data_length; // Length of the data payload following this header\n};\n\nclass TelemetryDataBufferVulnerable {\npublic:\n    TelemetryDataBufferVulnerable(size_t initial_capacity = 256)\n        : m_buffer(nullptr), m_current_size(0), m_allocated_capacity(0) {\n        if (initial_capacity > 0) {\n            m_buffer = (uint8_t*)malloc(initial_capacity);\n            if (m_buffer) {\n                m_allocated_capacity = initial_capacity;\n            }\n        }\n    }\n\n    ~TelemetryDataBufferVulnerable() {\n        if (m_buffer) {\n            free(m_buffer);\n            m_buffer = nullptr;\n        }\n    }\n\n    // Appends a telemetry block to the internal buffer.\n    // The vulnerability lies here: When TYPE_RAW_SENSOR_DATA is processed,\n    // data_length bytes are received, but they are converted to 2*data_length hex characters.\n    // The buffer resizing logic only accounts for data_length *in bytes* for the\n    // space needed for the raw sensor data, leading to an overflow when the hex characters are written.\n    bool appendTelemetryBlockVulnerable(const TelemetryBlockHeader* header, const uint8_t* payload) {\n        if (!header || !payload || header->data_length == 0) {\n            return false;\n        }\n\n        size_t block_header_size = sizeof(TelemetryBlockHeader);\n        size_t effective_payload_size = 0; // The actual size needed in the buffer for the payload\n\n        switch (header->block_type) {\n            case TYPE_RAW_SENSOR_DATA:\n                // Raw sensor data will be converted to hex string (2 chars per byte)\n                // VULNERABILITY: The realloc calculation below does NOT account for this expansion.\n                // It treats `header->data_length` as the size needed, not `2 * header->data_length`.\n                effective_payload_size = header->data_length; \n                break;\n            case TYPE_TEXT_MESSAGE:\n            case TYPE_EVENT_CODE:\n                // For text or event codes, it's a direct byte copy, plus null terminator\n                effective_payload_size = header->data_length + 1; // +1 for null terminator\n                break;\n            default:\n                return false; // Unknown type\n        }\n\n        size_t total_space_needed_for_this_block = block_header_size + effective_payload_size;\n\n        // Basic check for potential integer overflow in size calculation before addition\n        if (m_current_size > (~(size_t)0) - total_space_needed_for_this_block) {\n            return false;\n        }\n\n        // Check if current buffer has enough space. If not, reallocate.\n        if (m_current_size + total_space_needed_for_this_block > m_allocated_capacity) {\n            size_t new_capacity = m_allocated_capacity == 0 ? total_space_needed_for_this_block : m_allocated_capacity * 2;\n            // Ensure new_capacity is at least what's needed and doesn't overflow during doubling\n            if (m_allocated_capacity > (~(size_t)0) / 2 && m_allocated_capacity != 0) {\n                new_capacity = (~(size_t)0);\n            }\n            if (new_capacity < m_current_size + total_space_needed_for_this_block) {\n                new_capacity = m_current_size + total_space_needed_for_this_block;\n            }\n            \n            uint8_t* new_buffer = (uint8_t*)realloc(m_buffer, new_capacity);\n            if (!new_buffer) {\n                if (m_buffer) {\n                    free(m_buffer);\n                    m_buffer = nullptr;\n                }\n                m_current_size = 0;\n                m_allocated_capacity = 0;\n                return false;\n            }\n            m_buffer = new_buffer;\n            m_allocated_capacity = new_capacity;\n        }\n\n        if (!m_buffer) {\n            return false;\n        }\n\n        // Copy header\n        memcpy(m_buffer + m_current_size, header, block_header_size);\n        m_current_size += block_header_size;\n\n        // Copy payload based on type\n        switch (header->block_type) {\n            case TYPE_RAW_SENSOR_DATA: {\n                // Convert each byte to two hex characters\n                // This is where the overflow happens: `m_current_size` has only been incremented\n                // by `header->data_length` in the effective_payload_size calculation, \n                // but we write `header->data_length * 2` characters.\n                for (uint16_t i = 0; i < header->data_length; ++i) {\n                    uint8_t byte_val = payload[i];\n                    // VULNERABLE WRITE: No bounds check here for the conversion output\n                    // The allocated space was only for `header->data_length` for this payload,\n                    // but we are writing 2 characters per byte.\n                    m_buffer[m_current_size++] = (byte_val >> 4) < 10 ? ('0' + (byte_val >> 4)) : ('A' + (byte_val >> 4) - 10);\n                    m_buffer[m_current_size++] = (byte_val & 0x0F) < 10 ? ('0' + (byte_val & 0x0F)) : ('A' + (byte_val & 0x0F) - 10);\n                }\n                break;\n            }\n            case TYPE_TEXT_MESSAGE:\n            case TYPE_EVENT_CODE: {\n                memcpy(m_buffer + m_current_size, payload, header->data_length);\n                m_current_size += header->data_length;\n                m_buffer[m_current_size++] = '\\0'; // Null terminate\n                break;\n            }\n            default:\n                return false;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getBuffer() const { return m_buffer; }\n    size_t getCurrentSize() const { return m_current_size; }\n    size_t getAllocatedCapacity() const { return m_allocated_capacity; }\n\nprivate:\n    uint8_t* m_buffer;\n    size_t   m_current_size;\n    size_t   m_allocated_capacity;\n\n    // Helper to convert nibble to hex char (0-9, A-F)\n    char nibbleToHex(uint8_t nibble) {\n        if (nibble < 10) {\n            return '0' + nibble;\n        } else {\n            return 'A' + (nibble - 10);\n        }\n    }\n};",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <new>\n#include <algorithm>\n#include <limits>\n\n// Define types for clarity\ntypedef uint8_t TelemetryBlockType;\n\n// Telemetry Block Types\nconst TelemetryBlockType TYPE_RAW_SENSOR_DATA = 0x01;\nconst TelemetryBlockType TYPE_TEXT_MESSAGE = 0x02;\nconst TelemetryBlockType TYPE_EVENT_CODE = 0x03;\n\nstruct TelemetryBlockHeader {\n    TelemetryBlockType block_type;\n    uint16_t block_id;\n    uint16_t data_length; // Length of the data payload following this header\n};\n\nclass TelemetryDataBufferFixed {\npublic:\n    TelemetryDataBufferFixed(size_t initial_capacity = 256)\n        : m_buffer(nullptr), m_current_size(0), m_allocated_capacity(0) {\n        if (initial_capacity > 0) {\n            m_buffer = (uint8_t*)malloc(initial_capacity);\n            if (m_buffer) {\n                m_allocated_capacity = initial_capacity;\n            }\n        }\n    }\n\n    ~TelemetryDataBufferFixed() {\n        if (m_buffer) {\n            free(m_buffer);\n            m_buffer = nullptr;\n        }\n    }\n\n    bool appendTelemetryBlockFixed(const TelemetryBlockHeader* header, const uint8_t* payload) {\n        if (!header || !payload || header->data_length == 0) {\n            return false;\n        }\n\n        size_t block_header_size = sizeof(TelemetryBlockHeader);\n        size_t required_payload_storage_size = 0; // The actual size needed in the buffer for the payload\n\n        switch (header->block_type) {\n            case TYPE_RAW_SENSOR_DATA:\n                // FIX: Raw sensor data will be converted to hex string (2 chars per byte).\n                // Ensure data_length * 2 doesn't overflow.\n                if (header->data_length > (std::numeric_limits<uint16_t>::max() / 2)) {\n                    return false; // multiplication would overflow\n                }\n                required_payload_storage_size = static_cast<size_t>(header->data_length) * 2;\n                break;\n            case TYPE_TEXT_MESSAGE:\n            case TYPE_EVENT_CODE:\n                // For text or event codes, it's a direct byte copy, plus null terminator\n                // FIX: Ensure data_length + 1 doesn't overflow\n                if (header->data_length == std::numeric_limits<uint16_t>::max()) {\n                    return false; // addition would overflow\n                }\n                required_payload_storage_size = static_cast<size_t>(header->data_length) + 1; // +1 for null terminator\n                break;\n            default:\n                return false; // Unknown type\n        }\n\n        // FIX: Check for integer overflow before adding header size\n        if (block_header_size > std::numeric_limits<size_t>::max() - required_payload_storage_size) {\n            return false; // addition would overflow\n        }\n        size_t total_space_needed_for_this_block = block_header_size + required_payload_storage_size;\n\n        // Check for potential integer overflow in m_current_size + total_space_needed_for_this_block\n        if (m_current_size > std::numeric_limits<size_t>::max() - total_space_needed_for_this_block) {\n            return false; // Would overflow size_t\n        }\n\n        // Check if current buffer has enough space. If not, reallocate.\n        if (m_current_size + total_space_needed_for_this_block > m_allocated_capacity) {\n            size_t new_capacity = m_allocated_capacity == 0 ? total_space_needed_for_this_block : m_allocated_capacity * 2;\n            \n            // Handle overflow during doubling of capacity\n            if (m_allocated_capacity > std::numeric_limits<size_t>::max() / 2 && m_allocated_capacity != 0) {\n                 new_capacity = std::numeric_limits<size_t>::max();\n            }\n\n            // Ensure new_capacity is at least what's needed\n            if (new_capacity < m_current_size + total_space_needed_for_this_block) {\n                new_capacity = m_current_size + total_space_needed_for_this_block;\n            }\n\n            uint8_t* new_buffer = (uint8_t*)realloc(m_buffer, new_capacity);\n            if (!new_buffer) {\n                if (m_buffer) {\n                    free(m_buffer);\n                    m_buffer = nullptr;\n                }\n                m_current_size = 0;\n                m_allocated_capacity = 0;\n                return false;\n            }\n            m_buffer = new_buffer;\n            m_allocated_capacity = new_capacity;\n        }\n\n        if (!m_buffer) {\n            return false;\n        }\n\n        // Copy header\n        memcpy(m_buffer + m_current_size, header, block_header_size);\n        m_current_size += block_header_size;\n\n        // Copy payload based on type\n        switch (header->block_type) {\n            case TYPE_RAW_SENSOR_DATA: {\n                // FIX: Loop bound and write now match the correctly calculated required_payload_storage_size\n                size_t bytes_to_write_char_count = static_cast<size_t>(header->data_length) * 2;\n                if (m_current_size > m_allocated_capacity - bytes_to_write_char_count) {\n                    return false;\n                }\n\n                for (uint16_t i = 0; i < header->data_length; ++i) {\n                    uint8_t byte_val = payload[i];\n                    m_buffer[m_current_size++] = nibbleToHex(byte_val >> 4);\n                    m_buffer[m_current_size++] = nibbleToHex(byte_val & 0x0F);\n                }\n                break;\n            }\n            case TYPE_TEXT_MESSAGE:\n            case TYPE_EVENT_CODE: {\n                // FIX: Ensure enough space for memcpy + null terminator\n                size_t copy_len = header->data_length;\n                if (m_current_size > m_allocated_capacity - (copy_len + 1)) {\n                     return false;\n                }\n                memcpy(m_buffer + m_current_size, payload, copy_len);\n                m_current_size += copy_len;\n                m_buffer[m_current_size++] = '\\0'; // Null terminate\n                break;\n            }\n            default:\n                return false;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getBuffer() const { return m_buffer; }\n    size_t getCurrentSize() const { return m_current_size; }\n    size_t getAllocatedCapacity() const { return m_allocated_capacity; }\n\nprivate:\n    uint8_t* m_buffer;\n    size_t   m_current_size;\n    size_t   m_allocated_capacity;\n\n    // Helper to convert nibble to hex char (0-9, A-F)\n    char nibbleToHex(uint8_t nibble) {\n        if (nibble < 10) {\n            return '0' + nibble;\n        } else {\n            return 'A' + (nibble - 10);\n        }\n    }\n};",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstddef>\n#include <new>\n#include <cstring>\n\n#pragma pack(push, 1)\n\nstruct SensorRecordHeader {\n    uint16_t record_id;\n    uint32_t timestamp_ms;\n    uint16_t metadata_len; \n};\n\nstruct SensorDataBatchHeader {\n    uint16_t num_records;\n    uint32_t total_payload_bytes; \n};\n\n#pragma pack(pop)\n\nclass SensorDataProcessor {\npublic:\n    SensorDataProcessor() : m_processed_data_buffer(nullptr), m_buffer_capacity(0) {}\n\n    ~SensorDataProcessor() {\n        if (m_processed_data_buffer) {\n            delete[] m_processed_data_buffer;\n            m_processed_data_buffer = nullptr;\n        }\n    }\n\n    bool processSensorBatchVulnerable(const uint8_t* raw_batch_packet, size_t packet_length) {\n        if (!raw_batch_packet || packet_length < sizeof(SensorDataBatchHeader)) {\n            return false;\n        }\n\n        const SensorDataBatchHeader* batch_header = reinterpret_cast<const SensorDataBatchHeader*>(raw_batch_packet);\n\n        if (batch_header->total_payload_bytes > (packet_length - sizeof(SensorDataBatchHeader))) {\n            return false;\n        }\n\n        if (m_processed_data_buffer) {\n            delete[] m_processed_data_buffer;\n            m_processed_data_buffer = nullptr;\n        }\n\n        m_buffer_capacity = batch_header->total_payload_bytes;\n        \n        if (m_buffer_capacity == 0 && batch_header->num_records > 0) {\n             return false;\n        }\n        \n        m_processed_data_buffer = new (std::nothrow) uint8_t[m_buffer_capacity];\n        if (!m_processed_data_buffer && m_buffer_capacity > 0) {\n            return false;\n        }\n\n        size_t current_read_offset_in_packet = sizeof(SensorDataBatchHeader);\n        size_t current_write_offset_in_buffer = 0;\n\n        for (uint16_t i = 0; i < batch_header->num_records; ++i) {\n            if (current_read_offset_in_packet + sizeof(SensorRecordHeader) > packet_length) {\n                return false;\n            }\n\n            const SensorRecordHeader* record_header = reinterpret_cast<const SensorRecordHeader*>(raw_batch_packet + current_read_offset_in_packet);\n            uint16_t current_metadata_len = record_header->metadata_len;\n\n            if (current_read_offset_in_packet + sizeof(SensorRecordHeader) + current_metadata_len > packet_length) {\n                return false;\n            }\n\n            size_t bytes_to_copy_this_record = sizeof(SensorRecordHeader) + current_metadata_len;\n            \n            memcpy(m_processed_data_buffer + current_write_offset_in_buffer, record_header, bytes_to_copy_this_record);\n\n            current_read_offset_in_packet += bytes_to_copy_this_record;\n            current_write_offset_in_buffer += bytes_to_copy_this_record;\n        }\n        \n        if (current_write_offset_in_buffer > m_buffer_capacity) {\n            return false;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getProcessedDataBuffer() const {\n        return m_processed_data_buffer;\n    }\n\n    size_t getBufferCapacity() const {\n        return m_buffer_capacity;\n    }\n\nprivate:\n    uint8_t* m_processed_data_buffer;\n    size_t m_buffer_capacity;\n};\n",
    "fixed_code": "#include <cstdint>\n#include <cstddef>\n#include <new>\n#include <cstring>\n#include <limits>\n\n#pragma pack(push, 1)\n\nstruct SensorRecordHeader {\n    uint16_t record_id;\n    uint32_t timestamp_ms;\n    uint16_t metadata_len; \n};\n\nstruct SensorDataBatchHeader {\n    uint16_t num_records;\n    uint32_t total_payload_bytes; \n};\n\n#pragma pack(pop)\n\nclass SensorDataProcessorFixed {\npublic:\n    SensorDataProcessorFixed() : m_processed_data_buffer(nullptr), m_buffer_capacity(0) {}\n\n    ~SensorDataProcessorFixed() {\n        if (m_processed_data_buffer) {\n            delete[] m_processed_data_buffer;\n            m_processed_data_buffer = nullptr;\n        }\n    }\n\n    bool processSensorBatchFixed(const uint8_t* raw_batch_packet, size_t packet_length) {\n        if (!raw_batch_packet || packet_length < sizeof(SensorDataBatchHeader)) {\n            return false;\n        }\n\n        const SensorDataBatchHeader* batch_header = reinterpret_cast<const SensorDataBatchHeader*>(raw_batch_packet);\n\n        if (batch_header->total_payload_bytes > (packet_length - sizeof(SensorDataBatchHeader))) {\n            return false;\n        }\n        \n        size_t calculated_payload_size = 0;\n        size_t current_packet_scan_offset = sizeof(SensorDataBatchHeader);\n\n        static const uint16_t MAX_NUM_RECORDS = 100;\n        if (batch_header->num_records > MAX_NUM_RECORDS) {\n            return false;\n        }\n\n        for (uint16_t i = 0; i < batch_header->num_records; ++i) {\n            if (current_packet_scan_offset > (packet_length - sizeof(SensorRecordHeader))) {\n                return false;\n            }\n\n            const SensorRecordHeader* record_header_scan = reinterpret_cast<const SensorRecordHeader*>(raw_batch_packet + current_packet_scan_offset);\n            uint16_t current_metadata_len = record_header_scan->metadata_len;\n            \n            if (sizeof(SensorRecordHeader) > (std::numeric_limits<size_t>::max() - calculated_payload_size) ||\n                current_metadata_len > (std::numeric_limits<size_t>::max() - calculated_payload_size - sizeof(SensorRecordHeader))) {\n                return false;\n            }\n            \n            calculated_payload_size += sizeof(SensorRecordHeader) + current_metadata_len;\n            current_packet_scan_offset += sizeof(SensorRecordHeader) + current_metadata_len;\n\n            if (current_packet_scan_offset > packet_length) {\n                return false;\n            }\n        }\n\n        if (calculated_payload_size != batch_header->total_payload_bytes) {\n            return false;\n        }\n\n        if (m_processed_data_buffer) {\n            delete[] m_processed_data_buffer;\n            m_processed_data_buffer = nullptr;\n        }\n\n        m_buffer_capacity = calculated_payload_size;\n        \n        if (m_buffer_capacity == 0 && batch_header->num_records > 0) {\n            return false;\n        }\n\n        m_processed_data_buffer = new (std::nothrow) uint8_t[m_buffer_capacity];\n        if (!m_processed_data_buffer && m_buffer_capacity > 0) {\n            return false;\n        }\n\n        size_t current_read_offset_in_packet = sizeof(SensorDataBatchHeader);\n        size_t current_write_offset_in_buffer = 0;\n\n        for (uint16_t i = 0; i < batch_header->num_records; ++i) {\n            if (current_read_offset_in_packet > (packet_length - sizeof(SensorRecordHeader))) {\n                return false;\n            }\n\n            const SensorRecordHeader* record_header = reinterpret_cast<const SensorRecordHeader*>(raw_batch_packet + current_read_offset_in_packet);\n            uint16_t current_metadata_len = record_header->metadata_len;\n\n            if (current_read_offset_in_packet > (packet_length - sizeof(SensorRecordHeader) - current_metadata_len)) {\n                return false;\n            }\n\n            size_t bytes_to_copy_this_record = sizeof(SensorRecordHeader) + current_metadata_len;\n            \n            if (current_write_offset_in_buffer > (m_buffer_capacity - bytes_to_copy_this_record)) {\n                return false; \n            }\n\n            memcpy(m_processed_data_buffer + current_write_offset_in_buffer, record_header, bytes_to_copy_this_record);\n\n            current_read_offset_in_packet += bytes_to_copy_this_record;\n            current_write_offset_in_buffer += bytes_to_copy_this_record;\n        }\n        \n        if (current_write_offset_in_buffer != m_buffer_capacity) {\n            return false;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getProcessedDataBuffer() const {\n        return m_processed_data_buffer;\n    }\n\n    size_t getBufferCapacity() const {\n        return m_buffer_capacity;\n    }\n\nprivate:\n    uint8_t* m_processed_data_buffer;\n    size_t m_buffer_capacity;\n};\n",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <limits>\n\n// Represents a single sensor reading record.\n// The padding is added to ensure sizeof(SensorReading) is a value\n// that facilitates integer overflow demonstration with a large uint32_t count.\nstruct SensorReading {\n    uint32_t timestamp;\n    int16_t  value_x;\n    int16_t  value_y;\n    int16_t  value_z;\n    uint8_t  status_flags;\n    uint8_t  _padding[13]; // Padding to make total size 24 bytes\n};\n\n// Represents a packet received by the vehicle's telemetry system.\nstruct SensorDataPacketHeader {\n    uint16_t packet_id;\n    uint32_t num_readings;  // Number of SensorReading structures in this packet (can be maliciously large)\n    uint32_t total_payload_size_bytes; // Advertised total size of all readings combined\n};\n\nclass SensorDataCollection {\npublic:\n    SensorDataCollection() : m_readings_buffer(nullptr), m_current_num_readings(0), m_allocated_max_readings(0) {}\n\n    ~SensorDataCollection() {\n        clearData();\n    }\n\n    void clearData() {\n        if (m_readings_buffer) {\n            free(m_readings_buffer);\n            m_readings_buffer = nullptr;\n        }\n        m_current_num_readings = 0;\n        m_allocated_max_readings = 0;\n    }\n\n    bool processSensorDataPacketVulnerable(const uint8_t* raw_packet, size_t raw_len) {\n        clearData();\n\n        if (!raw_packet || raw_len < sizeof(SensorDataPacketHeader)) {\n            return false;\n        }\n\n        const SensorDataPacketHeader* header = reinterpret_cast<const SensorDataPacketHeader*>(raw_packet);\n\n        // Basic sanity checks for packet header values\n        if (header->packet_id != 0xABCD) {\n            return false;\n        }\n        if (header->num_readings == 0 && header->total_payload_size_bytes > 0) {\n            return false;\n        }\n\n        // VULNERABILITY: Integer overflow in allocation size calculation leading to heap overflow.\n        // If 'header->num_readings' is maliciously large (e.g., 200,000,000) and 'sizeof(SensorReading)' is 24 bytes,\n        // their product (200,000,000 * 24 = 4,800,000,000) will overflow a 32-bit unsigned integer\n        // (max value approx 4.29 billion). The result will wrap around (e.g., 505,032,704 bytes).\n        // This significantly smaller, wrapped-around value is then used for malloc.\n        uint32_t calculated_alloc_bytes_u32 = header->num_readings * sizeof(SensorReading);\n\n        m_readings_buffer = (SensorReading*)malloc(calculated_alloc_bytes_u32);\n        if (!m_readings_buffer && calculated_alloc_bytes_u32 > 0) {\n            return false; // Allocation failed or zero-size requested for non-zero data\n        }\n\n        // m_allocated_max_readings is set based on the potentially undersized allocated memory.\n        // If overflow occurred, this value will be smaller than the true 'header->num_readings'.\n        m_allocated_max_readings = calculated_alloc_bytes_u32 / sizeof(SensorReading);\n        m_current_num_readings = 0;\n\n        size_t current_packet_read_offset = sizeof(SensorDataPacketHeader);\n\n        // Loop iterates 'header->num_readings' times, which can be the malicious large value.\n        // The internal buffer 'm_readings_buffer' was allocated based on the potentially\n        // overflowed smaller size.\n        for (uint32_t i = 0; i < header->num_readings; ++i) {\n            // Source packet bounds check. This check prevents reading past raw_len,\n            // but does not prevent writing past the allocated heap buffer.\n            if (current_packet_read_offset + sizeof(SensorReading) > raw_len) {\n                clearData();\n                return false;\n            }\n\n            // Direct assignment of SensorReading structure into the heap buffer.\n            // This write operation will cause a heap-based buffer overflow\n            // when 'i' exceeds 'm_allocated_max_readings' due to the undersized allocation.\n            m_readings_buffer[i] = *reinterpret_cast<const SensorReading*>(raw_packet + current_packet_read_offset);\n\n            m_current_num_readings++;\n            current_packet_read_offset += sizeof(SensorReading);\n        }\n        \n        // This consistency check does not prevent the overflow, which already happened during the loop.\n        if (m_current_num_readings != header->num_readings) {\n            clearData();\n            return false;\n        }\n\n        return true;\n    }\n\nprivate:\n    SensorReading* m_readings_buffer;\n    size_t m_current_num_readings;\n    size_t m_allocated_max_readings;\n};",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <limits> // For std::numeric_limits\n\n// Represents a single sensor reading record.\nstruct SensorReading {\n    uint32_t timestamp;\n    int16_t  value_x;\n    int16_t  value_y;\n    int16_t  value_z;\n    uint8_t  status_flags;\n    uint8_t  _padding[13]; // Padding to make total size 24 bytes\n};\n\n// Represents a packet received by the vehicle's telemetry system.\nstruct SensorDataPacketHeader {\n    uint16_t packet_id;\n    uint32_t num_readings;\n    uint32_t total_payload_size_bytes;\n};\n\nclass SensorDataCollection {\npublic:\n    SensorDataCollection() : m_readings_buffer(nullptr), m_current_num_readings(0), m_allocated_max_readings(0) {}\n\n    ~SensorDataCollection() {\n        clearData();\n    }\n\n    void clearData() {\n        if (m_readings_buffer) {\n            free(m_readings_buffer);\n            m_readings_buffer = nullptr;\n        }\n        m_current_num_readings = 0;\n        m_allocated_max_readings = 0;\n    }\n\n    bool processSensorDataPacketFixed(const uint8_t* raw_packet, size_t raw_len) {\n        clearData();\n\n        if (!raw_packet || raw_len < sizeof(SensorDataPacketHeader)) {\n            return false;\n        }\n\n        const SensorDataPacketHeader* header = reinterpret_cast<const SensorDataPacketHeader*>(raw_packet);\n\n        // Basic sanity checks for packet header values\n        if (header->packet_id != 0xABCD) {\n            return false;\n        }\n        if (header->num_readings == 0 && header->total_payload_size_bytes > 0) {\n            return false;\n        }\n\n        // FIXED: Prevent integer overflow in allocation size calculation.\n        // Use 'size_t' for calculations to utilize the largest possible integer type for size.\n        // Explicitly check for potential overflow before multiplication.\n        size_t required_total_bytes_for_readings;\n        // Check if `num_readings * sizeof(SensorReading)` would overflow `size_t`.\n        // This indicates an excessive memory request that cannot be safely handled.\n        if (header->num_readings > (std::numeric_limits<size_t>::max() / sizeof(SensorReading))) {\n            return false;\n        }\n        required_total_bytes_for_readings = (size_t)header->num_readings * sizeof(SensorReading);\n        \n        // Additional consistency check: Ensure the advertised total_payload_size_bytes\n        // matches the calculated size based on 'num_readings' and 'sizeof(SensorReading)'.\n        // This catches malformed packets where these two fields are inconsistent.\n        if (required_total_bytes_for_readings != header->total_payload_size_bytes && header->num_readings > 0) {\n            return false;\n        }\n\n        // Critical check: Ensure the source packet actually contains enough data for all readings.\n        // This prevents reading out-of-bounds from the source 'raw_packet'.\n        if (raw_len < sizeof(SensorDataPacketHeader) + required_total_bytes_for_readings) {\n            return false;\n        }\n        \n        // Handle zero-allocation case explicitly.\n        if (required_total_bytes_for_readings == 0) {\n            // No readings, nothing to process/allocate. If num_readings > 0 but size is 0, it's an error.\n            return header->num_readings == 0;\n        }\n\n        m_readings_buffer = (SensorReading*)malloc(required_total_bytes_for_readings);\n        if (!m_readings_buffer) {\n            return false; // Allocation failed\n        }\n        // m_allocated_max_readings is now correctly set based on the truly allocated memory.\n        m_allocated_max_readings = required_total_bytes_for_readings / sizeof(SensorReading);\n        m_current_num_readings = 0;\n\n        size_t current_packet_read_offset = sizeof(SensorDataPacketHeader);\n\n        for (uint32_t i = 0; i < header->num_readings; ++i) {\n            // Explicit bounds check on the destination buffer.\n            // This check is now effective because 'm_allocated_max_readings' is correctly calculated,\n            // preventing writes beyond the allocated heap memory.\n            if (i >= m_allocated_max_readings) {\n                // This condition should ideally not be met if previous checks are sufficient.\n                // It acts as a robust final safeguard.\n                clearData();\n                return false;\n            }\n            \n            // Source buffer bounds check (redundant with earlier check, but good for robustness)\n            if (current_packet_read_offset > (std::numeric_limits<size_t>::max() - sizeof(SensorReading)) ||\n                current_packet_read_offset + sizeof(SensorReading) > raw_len) {\n                clearData();\n                return false;\n            }\n\n            m_readings_buffer[i] = *reinterpret_cast<const SensorReading*>(raw_packet + current_packet_read_offset);\n\n            m_current_num_readings++;\n            current_packet_read_offset += sizeof(SensorReading);\n        }\n        \n        // Final consistency check (ensures all advertised readings were processed and written).\n        if (m_current_num_readings != header->num_readings) {\n            clearData();\n            return false;\n        }\n\n        return true;\n    }\n\nprivate:\n    SensorReading* m_readings_buffer;\n    size_t m_current_num_readings;\n    size_t m_allocated_max_readings;\n};",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstddef>\n#include <new>\n#include <cstring>\n\nstruct DTC_Entry {\n    uint32_t code;\n    uint16_t status_flags;\n    uint8_t  occurrence_count;\n    char     reserved[5];\n};\n\nstruct DiagnosticPacketHeader {\n    uint16_t packet_id;\n    uint16_t num_dtc_entries;\n    uint32_t payload_data_bytes;\n};\n\nclass VehicleDiagnosticLoggerVulnerable {\npublic:\n    VehicleDiagnosticLoggerVulnerable() : m_dtc_buffer(nullptr), m_buffer_capacity(0), m_actual_dtc_count(0) {}\n\n    ~VehicleDiagnosticLoggerVulnerable() {\n        if (m_dtc_buffer) {\n            delete[] m_dtc_buffer;\n            m_dtc_buffer = nullptr;\n        }\n    }\n\n    bool processDiagnosticPacketVulnerable(const uint8_t* raw_packet_data, size_t packet_data_len) {\n        if (!raw_packet_data || packet_data_len < sizeof(DiagnosticPacketHeader)) {\n            return false;\n        }\n\n        const DiagnosticPacketHeader* header = reinterpret_cast<const DiagnosticPacketHeader*>(raw_packet_data);\n\n        if (packet_data_len < sizeof(DiagnosticPacketHeader) + header->payload_data_bytes) {\n            return false;\n        }\n\n        if (m_dtc_buffer) {\n            delete[] m_dtc_buffer;\n            m_dtc_buffer = nullptr;\n            m_buffer_capacity = 0;\n            m_actual_dtc_count = 0;\n        }\n\n        m_buffer_capacity = header->num_dtc_entries;\n        if (m_buffer_capacity == 0) {\n            return true;\n        }\n        \n        if (m_buffer_capacity > (SIZE_MAX / sizeof(DTC_Entry))) {\n            return false;\n        }\n\n        m_dtc_buffer = new (std::nothrow) DTC_Entry[m_buffer_capacity];\n        if (!m_dtc_buffer) {\n            return false;\n        }\n\n        const uint8_t* current_payload_ptr = raw_packet_data + sizeof(DiagnosticPacketHeader);\n        size_t current_payload_offset = 0;\n        uint16_t dtc_processed_count = 0;\n\n        while (current_payload_offset + sizeof(DTC_Entry) <= header->payload_data_bytes) {\n            \n            if (current_payload_ptr + current_payload_offset + sizeof(DTC_Entry) > raw_packet_data + packet_data_len) {\n                delete[] m_dtc_buffer;\n                m_dtc_buffer = nullptr;\n                m_buffer_capacity = 0;\n                m_actual_dtc_count = 0;\n                return false;\n            }\n\n            const DTC_Entry* incoming_dtc = reinterpret_cast<const DTC_Entry*>(current_payload_ptr + current_payload_offset);\n            \n            m_dtc_buffer[dtc_processed_count].code = incoming_dtc->code;\n            m_dtc_buffer[dtc_processed_count].status_flags = incoming_dtc->status_flags;\n            m_dtc_buffer[dtc_processed_count].occurrence_count = incoming_dtc->occurrence_count;\n            std::memcpy(m_dtc_buffer[dtc_processed_count].reserved, incoming_dtc->reserved, sizeof(incoming_dtc->reserved));\n\n            current_payload_offset += sizeof(DTC_Entry);\n            dtc_processed_count++;\n        }\n\n        m_actual_dtc_count = dtc_processed_count;\n\n        return true;\n    }\n\n    const DTC_Entry* getDTCBuffer() const { return m_dtc_buffer; }\n    uint16_t getBufferCapacity() const { return m_buffer_capacity; }\n    uint16_t getActualDTCCount() const { return m_actual_dtc_count; }\n\nprivate:\n    DTC_Entry* m_dtc_buffer;\n    uint16_t   m_buffer_capacity;\n    uint16_t   m_actual_dtc_count;\n}",
    "fixed_code": "#include <cstdint>\n#include <cstddef>\n#include <new>\n#include <cstring>\n#include <limits>\n\nstruct DTC_Entry {\n    uint32_t code;\n    uint16_t status_flags;\n    uint8_t  occurrence_count;\n    char     reserved[5];\n};\n\nstruct DiagnosticPacketHeader {\n    uint16_t packet_id;\n    uint16_t num_dtc_entries;\n    uint32_t payload_data_bytes;\n};\n\nclass VehicleDiagnosticLoggerFixed {\npublic:\n    VehicleDiagnosticLoggerFixed() : m_dtc_buffer(nullptr), m_buffer_capacity(0), m_actual_dtc_count(0) {}\n\n    ~VehicleDiagnosticLoggerFixed() {\n        if (m_dtc_buffer) {\n            delete[] m_dtc_buffer;\n            m_dtc_buffer = nullptr;\n        }\n    }\n\n    bool processDiagnosticPacketFixed(const uint8_t* raw_packet_data, size_t packet_data_len) {\n        if (!raw_packet_data || packet_data_len < sizeof(DiagnosticPacketHeader)) {\n            return false;\n        }\n\n        const DiagnosticPacketHeader* header = reinterpret_cast<const DiagnosticPacketHeader*>(raw_packet_data);\n\n        size_t expected_payload_from_num_entries;\n        if (header->num_dtc_entries > (std::numeric_limits<size_t>::max() / sizeof(DTC_Entry))) {\n            return false;\n        }\n        expected_payload_from_num_entries = (size_t)header->num_dtc_entries * sizeof(DTC_Entry);\n\n        if (header->payload_data_bytes != expected_payload_from_num_entries ||\n            packet_data_len < sizeof(DiagnosticPacketHeader) + header->payload_data_bytes) {\n            return false;\n        }\n        \n        if (m_dtc_buffer) {\n            delete[] m_dtc_buffer;\n            m_dtc_buffer = nullptr;\n            m_buffer_capacity = 0;\n            m_actual_dtc_count = 0;\n        }\n\n        m_buffer_capacity = header->num_dtc_entries;\n        if (m_buffer_capacity == 0) {\n            return true;\n        }\n\n        m_dtc_buffer = new (std::nothrow) DTC_Entry[m_buffer_capacity];\n        if (!m_dtc_buffer) {\n            return false;\n        }\n\n        const uint8_t* current_payload_ptr = raw_packet_data + sizeof(DiagnosticPacketHeader);\n        \n        for (uint16_t i = 0; i < m_buffer_capacity; ++i) {\n            if ((size_t)i * sizeof(DTC_Entry) + sizeof(DTC_Entry) > header->payload_data_bytes) {\n                delete[] m_dtc_buffer;\n                m_dtc_buffer = nullptr;\n                m_buffer_capacity = 0;\n                m_actual_dtc_count = 0;\n                return false;\n            }\n\n            const DTC_Entry* incoming_dtc = reinterpret_cast<const DTC_Entry*>(current_payload_ptr + (size_t)i * sizeof(DTC_Entry));\n            \n            m_dtc_buffer[i].code = incoming_dtc->code;\n            m_dtc_buffer[i].status_flags = incoming_dtc->status_flags;\n            m_dtc_buffer[i].occurrence_count = incoming_dtc->occurrence_count;\n            std::memcpy(m_dtc_buffer[i].reserved, incoming_dtc->reserved, sizeof(incoming_dtc->reserved));\n        }\n\n        m_actual_dtc_count = m_buffer_capacity;\n        return true;\n    }\n\n    const DTC_Entry* getDTCBuffer() const { return m_dtc_buffer; }\n    uint16_t getBufferCapacity() const { return m_buffer_capacity; }\n    uint16_t getActualDTCCount() const { return m_actual_dtc_count; }\n\nprivate:\n    DTC_Entry* m_dtc_buffer;\n    uint16_t   m_buffer_capacity;\n    uint16_t   m_actual_dtc_count;\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstddef>\n#include <cstdlib>\n#include <new>\n\nstruct DiagnosticEntryHeader {\n    uint32_t timestamp;\n    uint16_t event_code;\n    uint16_t data_payload_length;\n};\n\nstruct DiagnosticStreamPacket {\n    uint32_t  stream_id;\n    uint16_t  num_entries_in_packet;\n    uint32_t  total_packet_payload_bytes;\n};\n\nclass DiagnosticLogStreamVulnerable {\npublic:\n    DiagnosticLogStreamVulnerable() : m_log_buffer(nullptr), m_current_size(0), m_allocated_capacity(0) {}\n\n    ~DiagnosticLogStreamVulnerable() {\n        if (m_log_buffer) {\n            free(m_log_buffer);\n        }\n    }\n\n    void resetStream() {\n        if (m_log_buffer) {\n            free(m_log_buffer);\n            m_log_buffer = nullptr;\n        }\n        m_current_size = 0;\n        m_allocated_capacity = 0;\n    }\n\n    bool appendDiagnosticDataVulnerable(const uint8_t* raw_packet, size_t packet_len) {\n        if (!raw_packet || packet_len < sizeof(DiagnosticStreamPacket)) {\n            return false;\n        }\n\n        const DiagnosticStreamPacket* packet_header = reinterpret_cast<const DiagnosticStreamPacket*>(raw_packet);\n        \n        if (packet_len < sizeof(DiagnosticStreamPacket) + packet_header->total_packet_payload_bytes) {\n            return false;\n        }\n\n        const uint8_t* current_data_ptr = raw_packet + sizeof(DiagnosticStreamPacket);\n        size_t bytes_remaining_in_packet = packet_header->total_packet_payload_bytes;\n\n        for (uint16_t i = 0; i < packet_header->num_entries_in_packet; ++i) {\n            if (bytes_remaining_in_packet < sizeof(DiagnosticEntryHeader)) {\n                return false;\n            }\n\n            const DiagnosticEntryHeader* entry_header = reinterpret_cast<const DiagnosticEntryHeader*>(current_data_ptr);\n\n            size_t entry_total_size = sizeof(DiagnosticEntryHeader) + entry_header->data_payload_length;\n\n            if (bytes_remaining_in_packet < entry_total_size) {\n                return false;\n            }\n\n            size_t required_capacity = m_current_size + entry_total_size;\n\n            if (required_capacity > m_allocated_capacity) {\n                size_t new_capacity = m_allocated_capacity * 2;\n\n                if (new_capacity < required_capacity) {\n                    new_capacity = required_capacity;\n                }\n                \n                uint8_t* temp_buffer = (uint8_t*)realloc(m_log_buffer, new_capacity);\n                if (!temp_buffer) {\n                    if (m_log_buffer) {\n                        free(m_log_buffer);\n                        m_log_buffer = nullptr;\n                    }\n                    m_current_size = 0;\n                    m_allocated_capacity = 0;\n                    return false;\n                }\n                m_log_buffer = temp_buffer;\n                m_allocated_capacity = new_capacity;\n            }\n\n            for (size_t k = 0; k < sizeof(DiagnosticEntryHeader); ++k) {\n                m_log_buffer[m_current_size + k] = current_data_ptr[k];\n            }\n            m_current_size += sizeof(DiagnosticEntryHeader);\n\n            for (size_t k = 0; k < entry_header->data_payload_length; ++k) {\n                m_log_buffer[m_current_size + k] = current_data_ptr[sizeof(DiagnosticEntryHeader) + k];\n            }\n            m_current_size += entry_header->data_payload_length;\n\n            current_data_ptr += entry_total_size;\n            bytes_remaining_in_packet -= entry_total_size;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getLogBuffer() const {\n        return m_log_buffer;\n    }\n\n    size_t getCurrentSize() const {\n        return m_current_size;\n    }\n\nprivate:\n    uint8_t* m_log_buffer;\n    size_t   m_current_size;\n    size_t   m_allocated_capacity;\n};",
    "fixed_code": "#include <cstdint>\n#include <cstddef>\n#include <cstdlib>\n#include <new>\n#include <limits>\n\nstruct DiagnosticEntryHeader {\n    uint32_t timestamp;\n    uint16_t event_code;\n    uint16_t data_payload_length;\n};\n\nstruct DiagnosticStreamPacket {\n    uint32_t  stream_id;\n    uint16_t  num_entries_in_packet;\n    uint32_t  total_packet_payload_bytes;\n};\n\nclass DiagnosticLogStreamFixed {\npublic:\n    DiagnosticLogStreamFixed() : m_log_buffer(nullptr), m_current_size(0), m_allocated_capacity(0) {}\n\n    ~DiagnosticLogStreamFixed() {\n        if (m_log_buffer) {\n            free(m_log_buffer);\n        }\n    }\n\n    void resetStream() {\n        if (m_log_buffer) {\n            free(m_log_buffer);\n            m_log_buffer = nullptr;\n        }\n        m_current_size = 0;\n        m_allocated_capacity = 0;\n    }\n\n    bool appendDiagnosticDataFixed(const uint8_t* raw_packet, size_t packet_len) {\n        if (!raw_packet || packet_len < sizeof(DiagnosticStreamPacket)) {\n            return false;\n        }\n\n        const DiagnosticStreamPacket* packet_header = reinterpret_cast<const DiagnosticStreamPacket*>(raw_packet);\n        \n        if (packet_len < sizeof(DiagnosticStreamPacket) + packet_header->total_packet_payload_bytes) {\n            return false;\n        }\n\n        const uint8_t* current_data_ptr = raw_packet + sizeof(DiagnosticStreamPacket);\n        size_t bytes_remaining_in_packet = packet_header->total_packet_payload_bytes;\n\n        static const uint16_t MAX_SINGLE_PAYLOAD_LENGTH = 0xFFF0; \n\n        for (uint16_t i = 0; i < packet_header->num_entries_in_packet; ++i) {\n            if (bytes_remaining_in_packet < sizeof(DiagnosticEntryHeader)) {\n                return false;\n            }\n\n            const DiagnosticEntryHeader* entry_header = reinterpret_cast<const DiagnosticEntryHeader*>(current_data_ptr);\n\n            if (entry_header->data_payload_length > MAX_SINGLE_PAYLOAD_LENGTH) {\n                return false;\n            }\n\n            size_t entry_total_size = sizeof(DiagnosticEntryHeader) + entry_header->data_payload_length;\n\n            if (bytes_remaining_in_packet < entry_total_size) {\n                return false;\n            }\n\n            if (m_current_size > std::numeric_limits<size_t>::max() - entry_total_size) {\n                return false;\n            }\n            \n            size_t required_capacity = m_current_size + entry_total_size;\n\n            if (required_capacity > m_allocated_capacity) {\n                size_t new_capacity;\n\n                if (m_allocated_capacity > std::numeric_limits<size_t>::max() / 2) {\n                    new_capacity = std::numeric_limits<size_t>::max();\n                } else {\n                    new_capacity = m_allocated_capacity * 2;\n                }\n\n                if (new_capacity < required_capacity) {\n                    if (required_capacity > std::numeric_limits<size_t>::max()) {\n                        return false;\n                    }\n                    new_capacity = required_capacity;\n                }\n                \n                uint8_t* temp_buffer = (uint8_t*)realloc(m_log_buffer, new_capacity);\n                if (!temp_buffer) {\n                    if (m_log_buffer) {\n                        free(m_log_buffer);\n                        m_log_buffer = nullptr;\n                    }\n                    m_current_size = 0;\n                    m_allocated_capacity = 0;\n                    return false;\n                }\n                m_log_buffer = temp_buffer;\n                m_allocated_capacity = new_capacity;\n            }\n\n            for (size_t k = 0; k < sizeof(DiagnosticEntryHeader); ++k) {\n                m_log_buffer[m_current_size + k] = current_data_ptr[k];\n            }\n            m_current_size += sizeof(DiagnosticEntryHeader);\n\n            for (size_t k = 0; k < entry_header->data_payload_length; ++k) {\n                m_log_buffer[m_current_size + k] = current_data_ptr[sizeof(DiagnosticEntryHeader) + k];\n            }\n            m_current_size += entry_header->data_payload_length;\n\n            current_data_ptr += entry_total_size;\n            bytes_remaining_in_packet -= entry_total_size;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getLogBuffer() const {\n        return m_log_buffer;\n    }\n\n    size_t getCurrentSize() const {\n        return m_current_size;\n    }\n\nprivate:\n    uint8_t* m_log_buffer;\n    size_t   m_current_size;\n    size_t   m_allocated_capacity;\n};",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <new>\n#include <algorithm>\n#include <limits>\n\nstruct DiagnosticRecordHeader {\n    uint16_t record_id;\n    uint16_t data_length; \n};\n\nclass DiagnosticDataStoreVulnerable {\npublic:\n    DiagnosticDataStoreVulnerable() : m_buffer(nullptr), m_current_data_size(0), m_allocated_capacity(0) {}\n\n    ~DiagnosticDataStoreVulnerable() {\n        if (m_buffer) {\n            free(m_buffer);\n            m_buffer = nullptr;\n        }\n    }\n\n    bool appendDiagnosticRecordVulnerable(const uint8_t* raw_record_data, size_t raw_record_len) {\n        if (!raw_record_data || raw_record_len < sizeof(DiagnosticRecordHeader)) {\n            return false;\n        }\n\n        const DiagnosticRecordHeader* header = reinterpret_cast<const DiagnosticRecordHeader*>(raw_record_data);\n        uint16_t advertised_data_length = header->data_length;\n\n        if (raw_record_len != (sizeof(DiagnosticRecordHeader) + advertised_data_length)) {\n            return false;\n        }\n\n        size_t new_required_capacity = m_current_data_size + advertised_data_length;\n\n        const size_t MAX_TOTAL_BUFFER_SIZE = 16 * 1024 * 1024;\n        if (new_required_capacity > MAX_TOTAL_BUFFER_SIZE) {\n            return false;\n        }\n        \n        uint8_t* new_buffer = (uint8_t*)realloc(m_buffer, new_required_capacity);\n\n        if (!new_buffer && new_required_capacity > 0) {\n            return false;\n        }\n        \n        m_buffer = new_buffer;\n        m_allocated_capacity = new_required_capacity;\n\n        std::memcpy(m_buffer + m_current_data_size, raw_record_data, raw_record_len);\n        \n        m_current_data_size += raw_record_len;\n\n        return true;\n    }\n\n    const uint8_t* getRawDataBuffer() const {\n        return m_buffer;\n    }\n\n    size_t getCurrentDataSize() const {\n        return m_current_data_size;\n    }\n\nprivate:\n    uint8_t* m_buffer;\n    size_t m_current_data_size;\n    size_t m_allocated_capacity;\n};",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <new>\n#include <algorithm>\n#include <limits>\n\nstruct DiagnosticRecordHeader {\n    uint16_t record_id;\n    uint16_t data_length; \n};\n\nclass DiagnosticDataStoreFixed {\npublic:\n    DiagnosticDataStoreFixed() : m_buffer(nullptr), m_current_data_size(0), m_allocated_capacity(0) {}\n\n    ~DiagnosticDataStoreFixed() {\n        if (m_buffer) {\n            free(m_buffer);\n            m_buffer = nullptr;\n        }\n    }\n\n    bool appendDiagnosticRecordFixed(const uint8_t* raw_record_data, size_t raw_record_len) {\n        if (!raw_record_data || raw_record_len < sizeof(DiagnosticRecordHeader)) {\n            return false;\n        }\n\n        const DiagnosticRecordHeader* header = reinterpret_cast<const DiagnosticRecordHeader*>(raw_record_data);\n        uint16_t advertised_data_length = header->data_length;\n\n        if (raw_record_len != (sizeof(DiagnosticRecordHeader) + advertised_data_length)) {\n            return false;\n        }\n\n        size_t new_required_capacity;\n        if (m_current_data_size > (std::numeric_limits<size_t>::max() - raw_record_len)) {\n            return false;\n        }\n        new_required_capacity = m_current_data_size + raw_record_len;\n\n        const size_t MAX_TOTAL_BUFFER_SIZE = 16 * 1024 * 1024;\n        if (new_required_capacity > MAX_TOTAL_BUFFER_SIZE) {\n            return false;\n        }\n        \n        uint8_t* new_buffer = (uint8_t*)realloc(m_buffer, new_required_capacity);\n\n        if (!new_buffer && new_required_capacity > 0) {\n            return false;\n        }\n        \n        m_buffer = new_buffer;\n        m_allocated_capacity = new_required_capacity;\n\n        std::memcpy(m_buffer + m_current_data_size, raw_record_data, raw_record_len);\n        \n        m_current_data_size += raw_record_len;\n\n        return true;\n    }\n\n    const uint8_t* getRawDataBuffer() const {\n        return m_buffer;\n    }\n\n    size_t getCurrentDataSize() const {\n        return m_current_data_size;\n    }\n\nprivate:\n    uint8_t* m_buffer;\n    size_t m_current_data_size;\n    size_t m_allocated_capacity;\n};",
    "analysis": ""
  },
  {
    "cwe_id": "122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstddef>\n#include <new>\n#include <numeric>\n\nstruct CommandPacketHeader {\n    uint16_t command_id;\n    uint16_t payload_length;\n    uint8_t flags;\n};\n\nstruct ProcessedCommand {\n    uint16_t command_id;\n    size_t   data_size;\n    uint8_t* data;\n};\n\nclass CommandProcessorVulnerable {\npublic:\n    CommandProcessorVulnerable() : m_processed_cmd_data(nullptr), m_allocated_size(0) {}\n\n    ~CommandProcessorVulnerable() {\n        if (m_processed_cmd_data) {\n            delete[] m_processed_cmd_data;\n            m_processed_cmd_data = nullptr;\n        }\n    }\n\n    bool processCommandVulnerable(const uint8_t* raw_packet, size_t packet_len) {\n        if (!raw_packet || packet_len < sizeof(CommandPacketHeader)) {\n            return false;\n        }\n\n        const CommandPacketHeader* header = reinterpret_cast<const CommandPacketHeader*>(raw_packet);\n\n        static const uint16_t MAX_ALLOWED_PAYLOAD = 1024;\n        if (header->payload_length == 0 || header->payload_length > MAX_ALLOWED_PAYLOAD) {\n            return false;\n        }\n\n        if (packet_len < (sizeof(CommandPacketHeader) + header->payload_length)) {\n            return false;\n        }\n\n        if (m_processed_cmd_data) {\n            delete[] m_processed_cmd_data;\n            m_processed_cmd_data = nullptr;\n            m_allocated_size = 0;\n        }\n\n        m_processed_cmd_data = new (std::nothrow) uint8_t[header->payload_length];\n        if (!m_processed_cmd_data) {\n            return false;\n        }\n        m_allocated_size = header->payload_length;\n\n        const uint8_t* payload_src = raw_packet + sizeof(CommandPacketHeader);\n        for (uint16_t i = 0; i < header->payload_length; ++i) {\n            m_processed_cmd_data[i] = payload_src[i];\n        }\n\n        if (header->command_id == 0x101 || header->command_id == 0x202) {\n            uint8_t checksum = 0;\n            for (uint16_t i = 0; i < header->payload_length; ++i) {\n                checksum ^= m_processed_cmd_data[i];\n            }\n            m_processed_cmd_data[header->payload_length] = checksum;\n        }\n\n        m_last_processed_cmd.command_id = header->command_id;\n        m_last_processed_cmd.data_size = header->payload_length;\n        m_last_processed_cmd.data = m_processed_cmd_data;\n\n        return true;\n    }\n\n    const ProcessedCommand& getLastProcessedCommand() const {\n        return m_last_processed_cmd;\n    }\n\nprivate:\n    uint8_t* m_processed_cmd_data;\n    size_t m_allocated_size;\n    ProcessedCommand m_last_processed_cmd;\n}",
    "fixed_code": "#include <cstdint>\n#include <cstddef>\n#include <new>\n#include <numeric>\n#include <limits>\n\nstruct CommandPacketHeader {\n    uint16_t command_id;\n    uint16_t payload_length;\n    uint8_t flags;\n};\n\nstruct ProcessedCommand {\n    uint16_t command_id;\n    size_t   data_size;\n    uint8_t* data;\n};\n\nclass CommandProcessorFixed {\npublic:\n    CommandProcessorFixed() : m_processed_cmd_data(nullptr), m_allocated_size(0) {}\n\n    ~CommandProcessorFixed() {\n        if (m_processed_cmd_data) {\n            delete[] m_processed_cmd_data;\n            m_processed_cmd_data = nullptr;\n        }\n    }\n\n    bool processCommandFixed(const uint8_t* raw_packet, size_t packet_len) {\n        if (!raw_packet || packet_len < sizeof(CommandPacketHeader)) {\n            return false;\n        }\n\n        const CommandPacketHeader* header = reinterpret_cast<const CommandPacketHeader*>(raw_packet);\n\n        static const uint16_t MAX_ALLOWED_PAYLOAD = 1024;\n        if (header->payload_length == 0 || header->payload_length > MAX_ALLOWED_PAYLOAD) {\n            return false;\n        }\n\n        bool needs_checksum_byte = (header->command_id == 0x101 || header->command_id == 0x202);\n        size_t required_allocation_size = header->payload_length;\n        if (needs_checksum_byte) {\n            if (required_allocation_size >= std::numeric_limits<size_t>::max()) {\n                return false;\n            }\n            required_allocation_size += 1;\n        }\n        \n        if (packet_len < (sizeof(CommandPacketHeader) + header->payload_length)) {\n            return false;\n        }\n\n        if (m_processed_cmd_data) {\n            delete[] m_processed_cmd_data;\n            m_processed_cmd_data = nullptr;\n            m_allocated_size = 0;\n        }\n\n        m_processed_cmd_data = new (std::nothrow) uint8_t[required_allocation_size];\n        if (!m_processed_cmd_data) {\n            return false;\n        }\n        m_allocated_size = required_allocation_size;\n\n        const uint8_t* payload_src = raw_packet + sizeof(CommandPacketHeader);\n        for (uint16_t i = 0; i < header->payload_length; ++i) {\n            m_processed_cmd_data[i] = payload_src[i];\n        }\n\n        if (needs_checksum_byte) {\n            uint8_t checksum = 0;\n            for (uint16_t i = 0; i < header->payload_length; ++i) {\n                checksum ^= m_processed_cmd_data[i];\n            }\n            m_processed_cmd_data[header->payload_length] = checksum;\n        }\n\n        m_last_processed_cmd.command_id = header->command_id;\n        m_last_processed_cmd.data_size = header->payload_length;\n        m_last_processed_cmd.data = m_processed_cmd_data;\n\n        return true;\n    }\n\n    const ProcessedCommand& getLastProcessedCommand() const {\n        return m_last_processed_cmd;\n    }\n\nprivate:\n    uint8_t* m_processed_cmd_data;\n    size_t m_allocated_size;\n    ProcessedCommand m_last_processed_cmd;\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <vector>\n\n#pragma pack(push, 1)\nstruct SensorBatchHeader {\n    uint32_t timestamp;\n    uint16_t num_entries;\n};\n\nstruct SensorEntryHeader {\n    uint8_t  sensor_id;\n    uint16_t data_len; \n};\n#pragma pack(pop)\n\nclass VehicleSensorLoggerVulnerable {\npublic:\n    VehicleSensorLoggerVulnerable() :\n        m_log_buffer(nullptr),\n        m_current_buffer_size(0),\n        m_allocated_capacity(0)\n    {\n        m_allocated_capacity = 1024;\n        m_log_buffer = (uint8_t*)malloc(m_allocated_capacity);\n        if (!m_log_buffer) {\n            m_allocated_capacity = 0;\n        }\n    }\n\n    ~VehicleSensorLoggerVulnerable() {\n        if (m_log_buffer) {\n            free(m_log_buffer);\n            m_log_buffer = nullptr;\n        }\n    }\n\n    bool addSensorBatchVulnerable(const uint8_t* raw_data_packet, size_t packet_length) {\n        if (!raw_data_packet || packet_length < sizeof(SensorBatchHeader)) {\n            return false;\n        }\n\n        const SensorBatchHeader* batch_hdr = reinterpret_cast<const SensorBatchHeader*>(raw_data_packet);\n        size_t current_packet_offset = sizeof(SensorBatchHeader);\n        size_t total_new_data_size = 0;\n\n        for (uint16_t i = 0; i < batch_hdr->num_entries; ++i) {\n            if (current_packet_offset + sizeof(SensorEntryHeader) > packet_length) {\n                return false;\n            }\n            const SensorEntryHeader* entry_hdr = reinterpret_cast<const SensorEntryHeader*>(raw_data_packet + current_packet_offset);\n            uint16_t entry_data_len = entry_hdr->data_len;\n\n            size_t required_entry_size = sizeof(SensorEntryHeader) + entry_data_len;\n            total_new_data_size += required_entry_size;\n            \n            if (current_packet_offset + required_entry_size > packet_length) {\n                return false;\n            }\n            current_packet_offset += required_entry_size;\n        }\n\n        // VULNERABILITY: Integer overflow in required_total_space calculation.\n        // If m_current_buffer_size is already very large (e.g., near SIZE_MAX) and\n        // total_new_data_size is also large, their sum can wrap around, resulting\n        // in a significantly smaller 'required_total_space' than actually needed.\n        size_t required_total_space = m_current_buffer_size + total_new_data_size;\n        \n        if (required_total_space > m_allocated_capacity) {\n            size_t new_capacity = m_allocated_capacity * 2; \n            if (new_capacity < required_total_space) {\n                new_capacity = required_total_space + 256; \n            }\n            // If required_total_space wrapped around, new_capacity will also be small.\n            \n            uint8_t* new_buffer = (uint8_t*)realloc(m_log_buffer, new_capacity);\n            if (!new_buffer) {\n                return false;\n            }\n            m_log_buffer = new_buffer;\n            m_allocated_capacity = new_capacity;\n        }\n\n        current_packet_offset = sizeof(SensorBatchHeader);\n        \n        for (uint16_t i = 0; i < batch_hdr->num_entries; ++i) {\n            const SensorEntryHeader* entry_hdr = reinterpret_cast<const SensorEntryHeader*>(raw_data_packet + current_packet_offset);\n            uint16_t entry_data_len = entry_hdr->data_len;\n            size_t bytes_to_copy_for_entry = sizeof(SensorEntryHeader) + entry_data_len;\n\n            m_log_buffer[m_current_buffer_size] = entry_hdr->sensor_id;\n            m_log_buffer[m_current_buffer_size + 1] = (uint8_t)(entry_hdr->data_len & 0xFF);\n            m_log_buffer[m_current_buffer_size + 2] = (uint8_t)((entry_hdr->data_len >> 8) & 0xFF);\n            \n            const uint8_t* payload_src = raw_data_packet + current_packet_offset + sizeof(SensorEntryHeader);\n            // VULNERABILITY: If the buffer was undersized due to the integer overflow above,\n            // this loop will write past the end of the allocated 'm_log_buffer' in the heap.\n            for (uint16_t j = 0; j < entry_data_len; ++j) {\n                m_log_buffer[m_current_buffer_size + sizeof(SensorEntryHeader) + j] = payload_src[j];\n            }\n            \n            m_current_buffer_size += bytes_to_copy_for_entry;\n            current_packet_offset += bytes_to_copy_for_entry;\n        }\n\n        return true;\n    }\n\n    size_t getCurrentBufferSize() const { return m_current_buffer_size; }\n    size_t getAllocatedCapacity() const { return m_allocated_capacity; }\n    const uint8_t* getLogBuffer() const { return m_log_buffer; }\n\nprivate:\n    uint8_t* m_log_buffer;\n    size_t m_current_buffer_size;\n    size_t m_allocated_capacity;\n};\n",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <vector>\n#include <limits>\n\n#pragma pack(push, 1)\nstruct SensorBatchHeader {\n    uint32_t timestamp;\n    uint16_t num_entries;\n};\n\nstruct SensorEntryHeader {\n    uint8_t  sensor_id;\n    uint16_t data_len;\n};\n#pragma pack(pop)\n\nclass VehicleSensorLoggerFixed {\npublic:\n    VehicleSensorLoggerFixed() :\n        m_log_buffer(nullptr),\n        m_current_buffer_size(0),\n        m_allocated_capacity(0)\n    {\n        m_allocated_capacity = 1024;\n        m_log_buffer = (uint8_t*)malloc(m_allocated_capacity);\n        if (!m_log_buffer) {\n            m_allocated_capacity = 0;\n        }\n    }\n\n    ~VehicleSensorLoggerFixed() {\n        if (m_log_buffer) {\n            free(m_log_buffer);\n            m_log_buffer = nullptr;\n        }\n    }\n\n    bool addSensorBatchFixed(const uint8_t* raw_data_packet, size_t packet_length) {\n        if (!raw_data_packet || packet_length < sizeof(SensorBatchHeader)) {\n            return false;\n        }\n\n        const SensorBatchHeader* batch_hdr = reinterpret_cast<const SensorBatchHeader*>(raw_data_packet);\n        size_t current_packet_offset_scan = sizeof(SensorBatchHeader);\n        size_t total_new_data_size = 0;\n\n        static const uint16_t MAX_BATCH_ENTRIES = 250;\n        if (batch_hdr->num_entries > MAX_BATCH_ENTRIES) {\n            return false;\n        }\n\n        for (uint16_t i = 0; i < batch_hdr->num_entries; ++i) {\n            if (current_packet_offset_scan > (packet_length - sizeof(SensorEntryHeader))) {\n                return false;\n            }\n            const SensorEntryHeader* entry_hdr = reinterpret_cast<const SensorEntryHeader*>(raw_data_packet + current_packet_offset_scan);\n            uint16_t entry_data_len = entry_hdr->data_len;\n\n            if (sizeof(SensorEntryHeader) > (std::numeric_limits<size_t>::max() - total_new_data_size) ||\n                entry_data_len > (std::numeric_limits<size_t>::max() - total_new_data_size - sizeof(SensorEntryHeader))) {\n                return false;\n            }\n            \n            size_t required_entry_size = sizeof(SensorEntryHeader) + entry_data_len;\n            total_new_data_size += required_entry_size;\n            \n            if (current_packet_offset_scan > (packet_length - required_entry_size)) {\n                return false;\n            }\n            current_packet_offset_scan += required_entry_size;\n        }\n\n        if (total_new_data_size > (std::numeric_limits<size_t>::max() - m_current_buffer_size)) {\n            return false;\n        }\n        size_t required_total_space = m_current_buffer_size + total_new_data_size;\n\n        if (required_total_space > m_allocated_capacity) {\n            size_t new_capacity = m_allocated_capacity * 2;\n            if (new_capacity < m_allocated_capacity) {\n                new_capacity = std::numeric_limits<size_t>::max();\n            }\n            \n            if (new_capacity < required_total_space) {\n                new_capacity = required_total_space;\n            }\n\n            static const size_t MAX_LOG_BUFFER_SIZE = 16 * 1024 * 1024;\n            if (new_capacity > MAX_LOG_BUFFER_SIZE) {\n                if (required_total_space > MAX_LOG_BUFFER_SIZE) {\n                    return false;\n                }\n                new_capacity = MAX_LOG_BUFFER_SIZE;\n            }\n\n            uint8_t* new_buffer = (uint8_t*)realloc(m_log_buffer, new_capacity);\n            if (!new_buffer) {\n                return false;\n            }\n            m_log_buffer = new_buffer;\n            m_allocated_capacity = new_capacity;\n        }\n\n        size_t current_packet_offset_copy = sizeof(SensorBatchHeader);\n        \n        for (uint16_t i = 0; i < batch_hdr->num_entries; ++i) {\n            const SensorEntryHeader* entry_hdr = reinterpret_cast<const SensorEntryHeader*>(raw_data_packet + current_packet_offset_copy);\n            uint16_t entry_data_len = entry_hdr->data_len;\n            size_t bytes_to_copy_for_entry = sizeof(SensorEntryHeader) + entry_data_len;\n\n            if (m_current_buffer_size > (m_allocated_capacity - bytes_to_copy_for_entry)) {\n                return false;\n            }\n\n            m_log_buffer[m_current_buffer_size] = entry_hdr->sensor_id;\n            m_log_buffer[m_current_buffer_size + 1] = (uint8_t)(entry_hdr->data_len & 0xFF);\n            m_log_buffer[m_current_buffer_size + 2] = (uint8_t)((entry_hdr->data_len >> 8) & 0xFF);\n            \n            const uint8_t* payload_src = raw_data_packet + current_packet_offset_copy + sizeof(SensorEntryHeader);\n            for (uint16_t j = 0; j < entry_data_len; ++j) {\n                m_log_buffer[m_current_buffer_size + sizeof(SensorEntryHeader) + j] = payload_src[j];\n            }\n            \n            m_current_buffer_size += bytes_to_copy_for_entry;\n            current_packet_offset_copy += bytes_to_copy_for_entry;\n        }\n\n        return true;\n    }\n\n    size_t getCurrentBufferSize() const { return m_current_buffer_size; }\n    size_t getAllocatedCapacity() const { return m_allocated_capacity; }\n    const uint8_t* getLogBuffer() const { return m_log_buffer; }\n\nprivate:\n    uint8_t* m_log_buffer;\n    size_t m_current_buffer_size;\n    size_t m_allocated_capacity;\n};\n",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <new>\n\n// Represents a single diagnostic event's metadata\nstruct EventMetadata {\n    uint32_t timestamp;\n    uint16_t event_id;\n    uint16_t payload_length; // Actual length of this specific event's payload\n};\n\n// --- Vulnerable Class --- \n// Designed to store a stream of diagnostic events in a pre-allocated contiguous buffer.\nclass DiagnosticStorageVulnerable {\npublic:\n    // Constructor: Allocates a buffer based on an expected maximum number of events\n    // and a 'configured' maximum payload size per event. This 'configured' size\n    // is used to determine the fixed slot size for each event in the buffer.\n    DiagnosticStorageVulnerable(uint32_t max_total_events, uint16_t configured_max_payload_per_event)\n        : m_buffer(nullptr), m_buffer_capacity_bytes(0), m_current_event_count(0),\n          m_configured_max_payload_size(configured_max_payload_per_event) {\n\n        if (max_total_events == 0 || configured_max_payload_per_event == 0) {\n            return;\n        }\n\n        // Calculate the fixed size of each slot in the buffer.\n        // This size includes the EventMetadata and a fixed-size payload area\n        // based on 'configured_max_payload_per_event'.\n        size_t bytes_per_event_slot = sizeof(EventMetadata) + configured_max_payload_per_event;\n        \n        // Basic overflow check for the size_t calculation\n        if (max_total_events > SIZE_MAX / bytes_per_event_slot) {\n            // Prevent immediate integer overflow during allocation size calculation\n            return;\n        }\n\n        m_buffer_capacity_bytes = max_total_events * bytes_per_event_slot;\n        m_buffer = (uint8_t*)malloc(m_buffer_capacity_bytes);\n\n        if (m_buffer == nullptr && m_buffer_capacity_bytes > 0) {\n            m_buffer_capacity_bytes = 0; // Allocation failed\n        }\n    }\n\n    ~DiagnosticStorageVulnerable() {\n        if (m_buffer) {\n            free(m_buffer);\n        }\n    }\n\n    // Stores a single diagnostic event into the internal buffer.\n    // 'event_data' points to a byte stream containing EventMetadata followed by its payload.\n    // 'data_len' is the total length of 'event_data' (metadata + payload).\n    bool storeEventVulnerable(const uint8_t* event_data, size_t data_len) {\n        if (!event_data || data_len < sizeof(EventMetadata) || m_buffer == nullptr) {\n            return false;\n        }\n\n        const EventMetadata* incoming_meta = reinterpret_cast<const EventMetadata*>(event_data);\n        uint16_t actual_payload_len = incoming_meta->payload_length;\n        size_t total_incoming_event_size = sizeof(EventMetadata) + actual_payload_len;\n\n        // Ensure the incoming data itself is complete and not truncated\n        if (data_len < total_incoming_event_size) {\n            return false;\n        }\n\n        // Calculate the target offset in the internal buffer for the new event.\n        // This calculation relies on m_configured_max_payload_size for the slot size.\n        size_t bytes_per_event_slot = sizeof(EventMetadata) + m_configured_max_payload_size;\n        size_t write_offset = m_current_event_count * bytes_per_event_slot;\n\n        // This check validates if there's enough overall allocated space for the *next slot*\n        // based on the 'configured' size. It DOES NOT check if the *actual* incoming event's\n        // payload length exceeds the individual slot's configured size.\n        if (write_offset + bytes_per_event_slot > m_buffer_capacity_bytes) {\n            return false; // Not enough total capacity for another event slot at configured size\n        }\n\n        // VULNERABILITY:\n        // The 'memcpy' copies 'total_incoming_event_size' bytes. If 'actual_payload_len'\n        // (from the incoming data) is greater than 'm_configured_max_payload_size'\n        // (used for allocation and slot size calculation), then 'total_incoming_event_size'\n        // will be larger than 'bytes_per_event_slot'.\n        // This will cause 'memcpy' to write beyond the bounds of the current event's\n        // allocated slot in 'm_buffer', overflowing into the subsequent event's slot,\n        // or potentially past the end of 'm_buffer' if it's the last event.\n        // There is no check to ensure 'actual_payload_len <= m_configured_max_payload_size' here.\n        memcpy(m_buffer + write_offset, event_data, total_incoming_event_size);\n\n        m_current_event_count++;\n        return true;\n    }\n\n    size_t getStoredEventCount() const { return m_current_event_count; }\n    size_t getAllocatedCapacityBytes() const { return m_buffer_capacity_bytes; }\n    const uint8_t* getBuffer() const { return m_buffer; }\n\nprivate:\n    uint8_t* m_buffer;\n    size_t   m_buffer_capacity_bytes;\n    uint32_t m_current_event_count;\n    uint16_t m_configured_max_payload_size; // Maximum payload size assumed for each slot during allocation\n};",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <new>\n#include <limits> // For SIZE_MAX\n\n// Represents a single diagnostic event's metadata\nstruct EventMetadata {\n    uint32_t timestamp;\n    uint16_t event_id;\n    uint16_t payload_length; // Actual length of this specific event's payload\n};\n\n// --- Fixed Class ---\n// Designed to store a stream of diagnostic events in a pre-allocated contiguous buffer.\nclass DiagnosticStorageFixed {\npublic:\n    // Constructor: Allocates a buffer based on an expected maximum number of events\n    // and a 'configured' maximum payload size per event. This 'configured' size\n    // is used to determine the fixed slot size for each event in the buffer.\n    DiagnosticStorageFixed(uint32_t max_total_events, uint16_t configured_max_payload_per_event)\n        : m_buffer(nullptr), m_buffer_capacity_bytes(0), m_current_event_count(0),\n          m_configured_max_payload_size(configured_max_payload_per_event) {\n\n        if (max_total_events == 0 || configured_max_payload_per_event == 0) {\n            return;\n        }\n\n        // Calculate the fixed size of each slot in the buffer.\n        // This size includes the EventMetadata and a fixed-size payload area\n        // based on 'configured_max_payload_per_event'.\n        size_t bytes_per_event_slot = sizeof(EventMetadata) + configured_max_payload_per_event;\n        \n        // Basic overflow check for the size_t calculation\n        if (max_total_events > SIZE_MAX / bytes_per_event_slot) {\n            // Prevent immediate integer overflow during allocation size calculation\n            return;\n        }\n\n        m_buffer_capacity_bytes = max_total_events * bytes_per_event_slot;\n        m_buffer = (uint8_t*)malloc(m_buffer_capacity_bytes);\n\n        if (m_buffer == nullptr && m_buffer_capacity_bytes > 0) {\n            m_buffer_capacity_bytes = 0; // Allocation failed\n        }\n    }\n\n    ~DiagnosticStorageFixed() {\n        if (m_buffer) {\n            free(m_buffer);\n        }\n    }\n\n    // Stores a single diagnostic event into the internal buffer.\n    // 'event_data' points to a byte stream containing EventMetadata followed by its payload.\n    // 'data_len' is the total length of 'event_data' (metadata + payload).\n    bool storeEventFixed(const uint8_t* event_data, size_t data_len) {\n        if (!event_data || data_len < sizeof(EventMetadata) || m_buffer == nullptr) {\n            return false;\n        }\n\n        const EventMetadata* incoming_meta = reinterpret_cast<const EventMetadata*>(event_data);\n        uint16_t actual_payload_len = incoming_meta->payload_length;\n        \n        // FIX: Add a crucial check to ensure that the actual payload length of the\n        // incoming event does not exceed the 'configured_max_payload_size'.\n        // This prevents an individual event from overflowing its pre-allocated slot.\n        if (actual_payload_len > m_configured_max_payload_size) {\n            return false; // Reject event as its payload is too large for the configured slot size\n        }\n\n        size_t total_incoming_event_size = sizeof(EventMetadata) + actual_payload_len;\n\n        // Ensure the incoming data itself is complete and not truncated\n        if (data_len < total_incoming_event_size) {\n            return false;\n        }\n\n        // Calculate the target offset in the internal buffer for the new event.\n        // This calculation relies on m_configured_max_payload_size for the slot size.\n        size_t bytes_per_event_slot = sizeof(EventMetadata) + m_configured_max_payload_size;\n        size_t write_offset = m_current_event_count * bytes_per_event_slot;\n\n        // Ensure there is enough overall buffer capacity for the current event's slot.\n        // This check is now effective, as 'total_incoming_event_size' is guaranteed\n        // to be less than or equal to 'bytes_per_event_slot' after the fix.\n        if (write_offset > m_buffer_capacity_bytes ||\n            write_offset + bytes_per_event_slot > m_buffer_capacity_bytes) {\n            return false;\n        }\n        \n        // memcpy is now safe because total_incoming_event_size is guaranteed to fit within the slot.\n        memcpy(m_buffer + write_offset, event_data, total_incoming_event_size);\n\n        m_current_event_count++;\n        return true;\n    }\n\n    size_t getStoredEventCount() const { return m_current_event_count; }\n    size_t getAllocatedCapacityBytes() const { return m_buffer_capacity_bytes; }\n    const uint8_t* getBuffer() const { return m_buffer; }\n\nprivate:\n    uint8_t* m_buffer;\n    size_t   m_buffer_capacity_bytes;\n    uint32_t m_current_event_count;\n    uint16_t m_configured_max_payload_size; // Maximum payload size assumed for each slot during allocation\n};",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <vector>\n#include <new>\n\n#pragma pack(push, 1)\nstruct EventRecordHeaderVulnerable {\n    uint16_t event_type;\n    uint16_t data_size; \n};\n#pragma pack(pop)\n\nclass EventRecordVulnerable {\npublic:\n    EventRecordVulnerable() : m_event_data(nullptr), m_allocated_data_size(0) {}\n\n    ~EventRecordVulnerable() {\n        if (m_event_data) {\n            delete[] m_event_data;\n            m_event_data = nullptr;\n        }\n    }\n\n    bool populateFromRawDataVulnerable(const uint8_t* raw_input_block, size_t input_block_len) {\n        if (!raw_input_block || input_block_len < sizeof(EventRecordHeaderVulnerable)) {\n            return false;\n        }\n\n        const EventRecordHeaderVulnerable* header = reinterpret_cast<const EventRecordHeaderVulnerable*>(raw_input_block);\n        \n        uint16_t advertised_data_len = header->data_size;\n\n        if (m_event_data) {\n            delete[] m_event_data;\n            m_event_data = nullptr;\n        }\n\n        m_event_data = new (std::nothrow) uint8_t[advertised_data_len];\n        if (!m_event_data) {\n            m_allocated_data_size = 0;\n            return false;\n        }\n        m_allocated_data_size = advertised_data_len;\n\n        size_t bytes_to_copy = input_block_len - sizeof(EventRecordHeaderVulnerable);\n\n        for (size_t i = 0; i < bytes_to_copy; ++i) {\n            m_event_data[i] = raw_input_block[sizeof(EventRecordHeaderVulnerable) + i];\n        }\n\n        return true;\n    }\n\n    const uint8_t* getEventData() const {\n        return m_event_data;\n    }\n\n    uint16_t getAllocatedDataSize() const {\n        return m_allocated_data_size;\n    }\n\nprivate:\n    uint8_t* m_event_data;\n    uint16_t m_allocated_data_size;\n};\n\nclass VehicleEventDataManagerVulnerable {\npublic:\n    VehicleEventDataManagerVulnerable() {}\n    ~VehicleEventDataManagerVulnerable() {\n        for (auto* record : m_records) {\n            delete record;\n        }\n    }\n\n    bool addEventFromPacketVulnerable(const uint8_t* packet_data, size_t packet_len) {\n        EventRecordVulnerable* new_record = new (std::nothrow) EventRecordVulnerable();\n        if (!new_record) {\n            return false;\n        }\n\n        if (!new_record->populateFromRawDataVulnerable(packet_data, packet_len)) {\n            delete new_record;\n            return false;\n        }\n\n        m_records.push_back(new_record);\n        return true;\n    }\n\n    size_t getNumRecords() const {\n        return m_records.size();\n    }\n\n    const EventRecordVulnerable* getRecord(size_t index) const {\n        if (index < m_records.size()) {\n            return m_records[index];\n        }\n        return nullptr;\n    }\n\nprivate:\n    std::vector<EventRecordVulnerable*> m_records;\n}",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <vector>\n#include <new>\n#include <algorithm>\n\n#pragma pack(push, 1)\nstruct EventRecordHeaderFixed {\n    uint16_t event_type;\n    uint16_t data_size; \n};\n#pragma pack(pop)\n\nclass EventRecordFixed {\npublic:\n    EventRecordFixed() : m_event_data(nullptr), m_allocated_data_size(0) {}\n\n    ~EventRecordFixed() {\n        if (m_event_data) {\n            delete[] m_event_data;\n            m_event_data = nullptr;\n        }\n    }\n\n    bool populateFromRawDataFixed(const uint8_t* raw_input_block, size_t input_block_len) {\n        if (!raw_input_block || input_block_len < sizeof(EventRecordHeaderFixed)) {\n            return false;\n        }\n\n        const EventRecordHeaderFixed* header = reinterpret_cast<const EventRecordHeaderFixed*>(raw_input_block);\n        \n        uint16_t advertised_data_len = header->data_size;\n\n        if (m_event_data) {\n            delete[] m_event_data;\n            m_event_data = nullptr;\n        }\n\n        m_event_data = new (std::nothrow) uint8_t[advertised_data_len];\n        if (!m_event_data) {\n            m_allocated_data_size = 0;\n            return false;\n        }\n        m_allocated_data_size = advertised_data_len;\n\n        size_t actual_data_available_in_input = 0;\n        if (input_block_len > sizeof(EventRecordHeaderFixed)) {\n            actual_data_available_in_input = input_block_len - sizeof(EventRecordHeaderFixed);\n        } else {\n            return false;\n        }\n        \n        size_t bytes_to_copy = std::min((size_t)advertised_data_len, actual_data_available_in_input);\n\n        for (size_t i = 0; i < bytes_to_copy; ++i) {\n            m_event_data[i] = raw_input_block[sizeof(EventRecordHeaderFixed) + i];\n        }\n\n        return true;\n    }\n\n    const uint8_t* getEventData() const {\n        return m_event_data;\n    }\n\n    uint16_t getAllocatedDataSize() const {\n        return m_allocated_data_size;\n    }\n\nprivate:\n    uint8_t* m_event_data;\n    uint16_t m_allocated_data_size;\n};\n\nclass VehicleEventDataManagerFixed {\npublic:\n    VehicleEventDataManagerFixed() {}\n    ~VehicleEventDataManagerFixed() {\n        for (auto* record : m_records) {\n            delete record;\n        }\n    }\n\n    bool addEventFromPacketFixed(const uint8_t* packet_data, size_t packet_len) {\n        EventRecordFixed* new_record = new (std::nothrow) EventRecordFixed();\n        if (!new_record) {\n            return false;\n        }\n\n        if (!new_record->populateFromRawDataFixed(packet_data, packet_len)) {\n            delete new_record;\n            return false;\n        }\n\n        m_records.push_back(new_record);\n        return true;\n    }\n\n    size_t getNumRecords() const {\n        return m_records.size();\n    }\n\n    const EventRecordFixed* getRecord(size_t index) const {\n        if (index < m_records.size()) {\n            return m_records[index];\n        }\n        return nullptr;\n    }\n\nprivate:\n    std::vector<EventRecordFixed*> m_records;\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n\n\nstruct TelemetryEntryHeader {\n    uint8_t  entry_type;\n    uint16_t entry_data_len;\n};\n\n#define CAN_MESSAGE_PAYLOAD_SIZE 8\n#define MAX_TELEMETRY_BUFFER_SIZE (1 * 1024 * 1024)\n\nclass TelemetryRecorderVulnerable {\nprivate:\n    uint8_t* m_buffer;\n    size_t m_current_offset;\n    size_t m_allocated_capacity;\n\npublic:\n    TelemetryRecorderVulnerable() : m_buffer(nullptr), m_current_offset(0), m_allocated_capacity(0) {\n        m_allocated_capacity = 4096;\n        m_buffer = (uint8_t*)malloc(m_allocated_capacity);\n        if (!m_buffer) {\n            m_allocated_capacity = 0;\n        }\n    }\n\n    ~TelemetryRecorderVulnerable() {\n        if (m_buffer) {\n            free(m_buffer);\n            m_buffer = nullptr;\n        }\n    }\n\n    bool recordTelemetryEntryVulnerable(const uint8_t* raw_entry, size_t raw_entry_len) {\n        if (!raw_entry || raw_entry_len < sizeof(TelemetryEntryHeader)) {\n            return false;\n        }\n\n        const TelemetryEntryHeader* header = reinterpret_cast<const TelemetryEntryHeader*>(raw_entry);\n        uint8_t entry_type = header->entry_type;\n        uint16_t advertised_data_len = header->entry_data_len;\n\n        size_t required_space_for_this_entry = sizeof(TelemetryEntryHeader) + advertised_data_len;\n\n        if (m_current_offset + required_space_for_this_entry > MAX_TELEMETRY_BUFFER_SIZE) {\n            return false;\n        }\n\n        if (m_current_offset + required_space_for_this_entry > m_allocated_capacity) {\n            size_t new_capacity = m_allocated_capacity * 2;\n            if (new_capacity < m_current_offset + required_space_for_this_entry) {\n                new_capacity = m_current_offset + required_space_for_this_entry + 4096;\n            }\n            if (new_capacity > MAX_TELEMETRY_BUFFER_SIZE) {\n                new_capacity = MAX_TELEMETRY_BUFFER_SIZE;\n            }\n\n            uint8_t* new_buffer = (uint8_t*)realloc(m_buffer, new_capacity);\n            if (!new_buffer) {\n                return false;\n            }\n            m_buffer = new_buffer;\n            m_allocated_capacity = new_capacity;\n        }\n\n        for (size_t i = 0; i < sizeof(TelemetryEntryHeader); ++i) {\n            m_buffer[m_current_offset + i] = raw_entry[i];\n        }\n\n        const uint8_t* payload_src = raw_entry + sizeof(TelemetryEntryHeader);\n        size_t bytes_to_copy_payload;\n\n        if (entry_type == 0x03) {\n            bytes_to_copy_payload = (size_t)advertised_data_len * CAN_MESSAGE_PAYLOAD_SIZE;\n        } else {\n            bytes_to_copy_payload = advertised_data_len;\n        }\n\n        if (raw_entry_len < sizeof(TelemetryEntryHeader) + bytes_to_copy_payload) {\n            return false;\n        }\n        \n        for (size_t i = 0; i < bytes_to_copy_payload; ++i) {\n            m_buffer[m_current_offset + sizeof(TelemetryEntryHeader) + i] = payload_src[i];\n        }\n\n        m_current_offset += sizeof(TelemetryEntryHeader) + bytes_to_copy_payload;\n\n        return true;\n    }\n\n    const uint8_t* getTelemetryBuffer() const {\n        return m_buffer;\n    }\n\n    size_t getContainedDataSize() const {\n        return m_current_offset;\n    }\n};\n",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <limits>\n\n\nstruct TelemetryEntryHeader {\n    uint8_t  entry_type;\n    uint16_t entry_data_len;\n};\n\n#define CAN_MESSAGE_PAYLOAD_SIZE 8\n#define MAX_TELEMETRY_BUFFER_SIZE (1 * 1024 * 1024)\n\nclass TelemetryRecorderFixed {\nprivate:\n    uint8_t* m_buffer;\n    size_t m_current_offset;\n    size_t m_allocated_capacity;\n\npublic:\n    TelemetryRecorderFixed() : m_buffer(nullptr), m_current_offset(0), m_allocated_capacity(0) {\n        m_allocated_capacity = 4096;\n        m_buffer = (uint8_t*)malloc(m_allocated_capacity);\n        if (!m_buffer) {\n            m_allocated_capacity = 0;\n        }\n    }\n\n    ~TelemetryRecorderFixed() {\n        if (m_buffer) {\n            free(m_buffer);\n            m_buffer = nullptr;\n        }\n    }\n\n    bool recordTelemetryEntryFixed(const uint8_t* raw_entry, size_t raw_entry_len) {\n        if (!raw_entry || raw_entry_len < sizeof(TelemetryEntryHeader)) {\n            return false;\n        }\n\n        const TelemetryEntryHeader* header = reinterpret_cast<const TelemetryEntryHeader*>(raw_entry);\n        uint8_t entry_type = header->entry_type;\n        uint16_t advertised_data_len_or_count = header->entry_data_len;\n\n        size_t actual_payload_size;\n        if (entry_type == 0x03) {\n            if (advertised_data_len_or_count > (std::numeric_limits<size_t>::max() / CAN_MESSAGE_PAYLOAD_SIZE)) {\n                 return false;\n            }\n            actual_payload_size = (size_t)advertised_data_len_or_count * CAN_MESSAGE_PAYLOAD_SIZE;\n        } else {\n            actual_payload_size = advertised_data_len_or_count;\n        }\n\n        if (actual_payload_size > (std::numeric_limits<size_t>::max() - sizeof(TelemetryEntryHeader))) {\n            return false;\n        }\n        size_t required_space_for_this_entry = sizeof(TelemetryEntryHeader) + actual_payload_size;\n\n        if (m_current_offset > (MAX_TELEMETRY_BUFFER_SIZE - required_space_for_this_entry)) {\n            return false;\n        }\n\n        if (m_current_offset + required_space_for_this_entry > m_allocated_capacity) {\n            size_t new_capacity = m_allocated_capacity;\n            if (new_capacity == 0) {\n                new_capacity = 4096;\n            }\n\n            while (new_capacity < m_current_offset + required_space_for_this_entry) {\n                if (new_capacity > (std::numeric_limits<size_t>::max() / 2)) {\n                    new_capacity = std::numeric_limits<size_t>::max();\n                    break;\n                }\n                new_capacity *= 2;\n            }\n            if (new_capacity > MAX_TELEMETRY_BUFFER_SIZE) {\n                new_capacity = MAX_TELEMETRY_BUFFER_SIZE;\n            }\n            if (new_capacity < m_current_offset + required_space_for_this_entry) {\n                return false;\n            }\n\n            uint8_t* new_buffer = (uint8_t*)realloc(m_buffer, new_capacity);\n            if (!new_buffer && new_capacity > 0) {\n                return false;\n            }\n            m_buffer = new_buffer;\n            m_allocated_capacity = new_capacity;\n        }\n\n        if (raw_entry_len < sizeof(TelemetryEntryHeader) + actual_payload_size) {\n            return false;\n        }\n        \n        for (size_t i = 0; i < sizeof(TelemetryEntryHeader); ++i) {\n            m_buffer[m_current_offset + i] = raw_entry[i];\n        }\n\n        const uint8_t* payload_src = raw_entry + sizeof(TelemetryEntryHeader);\n        \n        for (size_t i = 0; i < actual_payload_size; ++i) {\n            m_buffer[m_current_offset + sizeof(TelemetryEntryHeader) + i] = payload_src[i];\n        }\n\n        m_current_offset += required_space_for_this_entry;\n\n        return true;\n    }\n\n    const uint8_t* getTelemetryBuffer() const {\n        return m_buffer;\n    }\n\n    size_t getContainedDataSize() const {\n        return m_current_offset;\n    }\n};\n",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <vector>\n\n// Max theoretical size for a decoded data block to prevent extreme allocation.\n// Even with this, an overflow can occur if the internal RLE logic expands beyond a malicious 'total_decoded_size' field.\n#define MAX_DECODED_BLOCK_SIZE 65536 // 64KB\n\n// Represents the header for an incoming telemetry data block\nstruct TelemetryBlockHeader {\n    uint16_t block_id;\n    uint16_t num_entries;\n    uint32_t total_decoded_size; // Advertised total size of ALL decoded data entries in this block\n};\n\n// Represents the header for an individual entry within the block\nstruct TelemetryEntryHeader {\n    uint8_t  entry_type; // 0x01 for raw, 0x02 for RLE\n    uint16_t encoded_data_length; // Length of the *encoded* data that follows this header\n};\n\nenum TelemetryEntryType : uint8_t {\n    RAW_DATA = 0x01,\n    RLE_DATA = 0x02\n};\n\nclass VehicleTelemetryProcessorVulnerable {\npublic:\n    VehicleTelemetryProcessorVulnerable() : m_decoded_buffer(nullptr), m_current_buffer_pos(0), m_allocated_capacity(0) {}\n\n    ~VehicleTelemetryProcessorVulnerable() {\n        if (m_decoded_buffer) {\n            free(m_decoded_buffer);\n        }\n    }\n\n    void resetBuffer() {\n        if (m_decoded_buffer) {\n            free(m_decoded_buffer);\n            m_decoded_buffer = nullptr;\n        }\n        m_current_buffer_pos = 0;\n        m_allocated_capacity = 0;\n    }\n\n    // Processes a raw telemetry data packet and appends decoded data to an internal buffer.\n    bool processTelemetryBlockVulnerable(const uint8_t* raw_packet, size_t packet_len) {\n        if (!raw_packet || packet_len < sizeof(TelemetryBlockHeader)) {\n            return false;\n        }\n\n        const TelemetryBlockHeader* block_header = reinterpret_cast<const TelemetryBlockHeader*>(raw_packet);\n\n        // Preliminary check for packet size vs advertised total payload\n        // This check is insufficient, as total_decoded_size can be manipulated by attacker\n        // to be smaller than actual decoded size while still fitting in packet_len\n        if (packet_len < sizeof(TelemetryBlockHeader) + block_header->total_decoded_size) {\n            return false;\n        }\n\n        // Allocate buffer based on the *advertised* total_decoded_size.\n        // VULNERABILITY: This size might be undersized if RLE entries expand beyond what the attacker\n        // advertises as total_decoded_size, leading to a heap overflow during the copy loop.\n        size_t desired_alloc_size = block_header->total_decoded_size;\n        if (desired_alloc_size == 0) { // Handle empty block case\n             resetBuffer();\n             return true;\n        }\n\n        // Apply a hard limit to prevent excessively large legitimate allocations,\n        // but this doesn't prevent overflow for malicious inputs within this limit.\n        if (desired_alloc_size > MAX_DECODED_BLOCK_SIZE) {\n            return false;\n        }\n\n        // Reallocate/allocate the buffer\n        uint8_t* new_buffer = (uint8_t*)realloc(m_decoded_buffer, desired_alloc_size);\n        if (!new_buffer) {\n            // Realloc failed, clean up old buffer if it existed\n            if (m_decoded_buffer) free(m_decoded_buffer);\n            m_decoded_buffer = nullptr;\n            m_current_buffer_pos = 0;\n            m_allocated_capacity = 0;\n            return false;\n        }\n        m_decoded_buffer = new_buffer;\n        m_allocated_capacity = desired_alloc_size;\n        m_current_buffer_pos = 0; // Reset position for new block processing\n\n        size_t current_packet_offset = sizeof(TelemetryBlockHeader);\n\n        for (uint16_t i = 0; i < block_header->num_entries; ++i) {\n            if (current_packet_offset + sizeof(TelemetryEntryHeader) > packet_len) {\n                resetBuffer();\n                return false;\n            }\n\n            const TelemetryEntryHeader* entry_header = reinterpret_cast<const TelemetryEntryHeader*>(raw_packet + current_packet_offset);\n            \n            // Check if the encoded data fits within the packet\n            if (current_packet_offset + sizeof(TelemetryEntryHeader) + entry_header->encoded_data_length > packet_len) {\n                resetBuffer();\n                return false;\n            }\n\n            const uint8_t* entry_data_ptr = raw_packet + current_packet_offset + sizeof(TelemetryEntryHeader);\n            size_t bytes_to_read = entry_header->encoded_data_length;\n\n            switch (entry_header->entry_type) {\n                case RAW_DATA: {\n                    // Direct copy of raw data\n                    if (m_current_buffer_pos + bytes_to_read > m_allocated_capacity) {\n                        // This check exists, but for RLE data, bytes_to_read is encoded length, not decoded.\n                        // If total_decoded_size was manipulated, this may be too late or not applicable.\n                        resetBuffer();\n                        return false;\n                    }\n                    std::memcpy(m_decoded_buffer + m_current_buffer_pos, entry_data_ptr, bytes_to_read);\n                    m_current_buffer_pos += bytes_to_read;\n                    break;\n                }\n                case RLE_DATA: {\n                    // Process Run-Length Encoded data (format: [byte_to_repeat][repeat_count]...)\n                    size_t rle_current_read_offset = 0;\n                    while (rle_current_read_offset + 1 < bytes_to_read) { // Need at least 2 bytes (value, count)\n                        uint8_t value_to_repeat = entry_data_ptr[rle_current_read_offset];\n                        uint8_t repeat_count = entry_data_ptr[rle_current_read_offset + 1];\n\n                        // VULNERABILITY: No check here if 'm_current_buffer_pos + repeat_count' exceeds 'm_allocated_capacity'.\n                        // The 'm_allocated_capacity' is based on the potentially undersized 'total_decoded_size' field.\n                        // An attacker can craft a 'total_decoded_size' smaller than the actual\n                        // expanded size of RLE data, leading to a heap overflow.\n                        for (uint8_t k = 0; k < repeat_count; ++k) {\n                            m_decoded_buffer[m_current_buffer_pos + k] = value_to_repeat;\n                        }\n                        m_current_buffer_pos += repeat_count;\n\n                        rle_current_read_offset += 2; // Move to the next RLE pair\n                    }\n                    break;\n                }\n                default:\n                    // Unknown type, or other types would be handled here\n                    resetBuffer();\n                    return false;\n            }\n            current_packet_offset += sizeof(TelemetryEntryHeader) + bytes_to_read;\n        }\n\n        // Final check: ensure the total size written matches the advertised size.\n        // This check comes *after* the writes, so an overflow would have already occurred if triggered.\n        if (m_current_buffer_pos > block_header->total_decoded_size) {\n            resetBuffer(); \n            return false;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getDecodedBuffer() const { return m_decoded_buffer; }\n    size_t getCurrentDecodedSize() const { return m_current_buffer_pos; }\n\nprivate:\n    uint8_t* m_decoded_buffer;\n    size_t   m_current_buffer_pos;\n    size_t   m_allocated_capacity;\n};",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <limits>\n\n// Max theoretical size for a decoded data block to prevent extreme allocation.\n#define MAX_DECODED_BLOCK_SIZE 65536 // 64KB\n\n// Represents the header for an incoming telemetry data block\nstruct TelemetryBlockHeaderFixed {\n    uint16_t block_id;\n    uint16_t num_entries;\n    uint32_t total_decoded_size; // Advertised total size of ALL decoded data entries in this block\n};\n\n// Represents the header for an individual entry within the block\nstruct TelemetryEntryHeaderFixed {\n    uint8_t  entry_type;\n    uint16_t encoded_data_length; // Length of the *encoded* data that follows this header\n};\n\nenum TelemetryEntryTypeFixed : uint8_t {\n    RAW_DATA_FIXED = 0x01,\n    RLE_DATA_FIXED = 0x02\n};\n\nclass VehicleTelemetryProcessorFixed {\npublic:\n    VehicleTelemetryProcessorFixed() : m_decoded_buffer(nullptr), m_current_buffer_pos(0), m_allocated_capacity(0) {}\n\n    ~VehicleTelemetryProcessorFixed() {\n        if (m_decoded_buffer) {\n            free(m_decoded_buffer);\n        }\n    }\n\n    void resetBuffer() {\n        if (m_decoded_buffer) {\n            free(m_decoded_buffer);\n            m_decoded_buffer = nullptr;\n        }\n        m_current_buffer_pos = 0;\n        m_allocated_capacity = 0;\n    }\n\n    // Processes a raw telemetry data packet and appends decoded data to an internal buffer.\n    bool processTelemetryBlockFixed(const uint8_t* raw_packet, size_t packet_len) {\n        if (!raw_packet || packet_len < sizeof(TelemetryBlockHeaderFixed)) {\n            return false;\n        }\n\n        const TelemetryBlockHeaderFixed* block_header = reinterpret_cast<const TelemetryBlockHeaderFixed*>(raw_packet);\n\n        // FIX: Calculate the *actual* maximum possible decoded size based on entries in a pre-pass.\n        size_t calculated_max_decoded_size = 0;\n        size_t current_packet_offset_for_calc = sizeof(TelemetryBlockHeaderFixed);\n\n        for (uint16_t i = 0; i < block_header->num_entries; ++i) {\n            // Ensure enough data for header itself in the packet\n            if (current_packet_offset_for_calc + sizeof(TelemetryEntryHeaderFixed) > packet_len) {\n                return false; \n            }\n            const TelemetryEntryHeaderFixed* entry_header_calc = reinterpret_cast<const TelemetryEntryHeaderFixed*>(raw_packet + current_packet_offset_for_calc);\n\n            // Ensure encoded data length does not exceed packet boundary\n            if (current_packet_offset_for_calc + sizeof(TelemetryEntryHeaderFixed) + entry_header_calc->encoded_data_length > packet_len) {\n                return false;\n            }\n            \n            size_t max_decoded_bytes_for_entry = 0;\n            if (entry_header_calc->entry_type == RAW_DATA_FIXED) {\n                max_decoded_bytes_for_entry = entry_header_calc->encoded_data_length;\n            } else if (entry_header_calc->entry_type == RLE_DATA_FIXED) {\n                // RLE: each 2 bytes (value, count) can expand to up to 255 bytes.\n                // So, encoded_data_length bytes can expand to (encoded_data_length / 2) * 255.\n                if (entry_header_calc->encoded_data_length % 2 != 0) {\n                    return false; // Malformed RLE data (odd number of bytes)\n                }\n                size_t num_rle_pairs = entry_header_calc->encoded_data_length / 2;\n                // Check for integer overflow before multiplication\n                if (num_rle_pairs > (std::numeric_limits<size_t>::max() / 255)) {\n                    return false; // Resulting size too large\n                }\n                max_decoded_bytes_for_entry = num_rle_pairs * 255;\n            } else {\n                return false; // Unknown or unsupported entry type\n            }\n\n            // Check for integer overflow when summing total calculated size\n            if (calculated_max_decoded_size > std::numeric_limits<size_t>::max() - max_decoded_bytes_for_entry) {\n                return false; // Total calculated size overflow\n            }\n            calculated_max_decoded_size += max_decoded_bytes_for_entry;\n\n            current_packet_offset_for_calc += sizeof(TelemetryEntryHeaderFixed) + entry_header_calc->encoded_data_length;\n        }\n\n        // FIX: Verify advertised total_decoded_size against the *calculated* max required size.\n        // If the advertised size is less than what's potentially needed, it's a malformed/malicious packet.\n        if (block_header->total_decoded_size < calculated_max_decoded_size) {\n            return false;\n        }\n        \n        // Final sanity check on calculated size against hard limit\n        if (calculated_max_decoded_size > MAX_DECODED_BLOCK_SIZE) {\n            return false;\n        }\n\n        // Ensure the entire packet is provided as expected (header + total encoded data bytes).\n        // `current_packet_offset_for_calc` now holds the total size of header + all encoded data.\n        if (packet_len < current_packet_offset_for_calc) {\n             return false;\n        }\n\n        // Allocate buffer based on the *calculated* maximum required size to ensure sufficient space.\n        size_t desired_alloc_size = calculated_max_decoded_size;\n        if (desired_alloc_size == 0) {\n             resetBuffer();\n             return true;\n        }\n        \n        uint8_t* new_buffer = (uint8_t*)realloc(m_decoded_buffer, desired_alloc_size);\n        if (!new_buffer) {\n            if (m_decoded_buffer) free(m_decoded_buffer);\n            m_decoded_buffer = nullptr;\n            m_current_buffer_pos = 0;\n            m_allocated_capacity = 0;\n            return false;\n        }\n        m_decoded_buffer = new_buffer;\n        m_allocated_capacity = desired_alloc_size;\n        m_current_buffer_pos = 0; // Reset position for new block processing\n\n        size_t current_packet_offset = sizeof(TelemetryBlockHeaderFixed);\n\n        for (uint16_t i = 0; i < block_header->num_entries; ++i) {\n            // These checks are implicitly handled by the initial `current_packet_offset_for_calc` checks,\n            // but are repeated here for robustness as `current_packet_offset` advances.\n            if (current_packet_offset + sizeof(TelemetryEntryHeaderFixed) > packet_len) { resetBuffer(); return false; }\n            const TelemetryEntryHeaderFixed* entry_header = reinterpret_cast<const TelemetryEntryHeaderFixed*>(raw_packet + current_packet_offset);\n            if (current_packet_offset + sizeof(TelemetryEntryHeaderFixed) + entry_header->encoded_data_length > packet_len) { resetBuffer(); return false; }\n\n            const uint8_t* entry_data_ptr = raw_packet + current_packet_offset + sizeof(TelemetryEntryHeaderFixed);\n            size_t bytes_to_read = entry_header->encoded_data_length;\n\n            switch (entry_header->entry_type) {\n                case RAW_DATA_FIXED: {\n                    // FIX: Ensure enough space before copying data.\n                    if (m_current_buffer_pos > m_allocated_capacity - bytes_to_read) {\n                        resetBuffer();\n                        return false;\n                    }\n                    std::memcpy(m_decoded_buffer + m_current_buffer_pos, entry_data_ptr, bytes_to_read);\n                    m_current_buffer_pos += bytes_to_read;\n                    break;\n                }\n                case RLE_DATA_FIXED: {\n                    size_t rle_current_read_offset = 0;\n                    while (rle_current_read_offset + 1 < bytes_to_read) { \n                        uint8_t value_to_repeat = entry_data_ptr[rle_current_read_offset];\n                        uint8_t repeat_count = entry_data_ptr[rle_current_read_offset + 1];\n\n                        // FIX: Explicitly check bounds before writing repeated bytes.\n                        // This is the critical fix for the RLE expansion vulnerability.\n                        if (m_current_buffer_pos > m_allocated_capacity - repeat_count) {\n                            resetBuffer();\n                            return false;\n                        }\n\n                        for (uint8_t k = 0; k < repeat_count; ++k) {\n                            m_decoded_buffer[m_current_buffer_pos + k] = value_to_repeat;\n                        }\n                        m_current_buffer_pos += repeat_count;\n\n                        rle_current_read_offset += 2;\n                    }\n                    break;\n                }\n                default:\n                    resetBuffer();\n                    return false;\n            }\n            current_packet_offset += sizeof(TelemetryEntryHeaderFixed) + bytes_to_read;\n        }\n\n        // Final check: ensure the total size written matches the advertised size from the header.\n        // This helps detect any inconsistencies or truncation.\n        if (m_current_buffer_pos != block_header->total_decoded_size) {\n            resetBuffer(); \n            return false;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getDecodedBuffer() const { return m_decoded_buffer; }\n    size_t getCurrentDecodedSize() const { return m_current_buffer_pos; }\n\nprivate:\n    uint8_t* m_decoded_buffer;\n    size_t   m_current_buffer_pos;\n    size_t   m_allocated_capacity;\n};",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <vector>\n\n#define MAX_UINT32_DIGITS 10\n\nstruct LoggedEvent {\n    uint32_t event_id;\n    char*    parameter_str;\n    size_t   parameter_str_capacity;\n};\n\nsize_t uint32_to_string_vulnerable(uint32_t value, char* buffer) {\n    if (value == 0) {\n        buffer[0] = '0';\n        buffer[1] = '\\0';\n        return 1;\n    }\n\n    int i = 0;\n    char temp_buffer[MAX_UINT32_DIGITS + 1];\n    \n    uint32_t temp_val = value;\n    while (temp_val > 0) {\n        temp_buffer[i++] = (temp_val % 10) + '0';\n        temp_val /= 10;\n    }\n\n    size_t len = i;\n    for (int j = 0; j < len; j++) {\n        buffer[j] = temp_buffer[i - 1 - j];\n    }\n    buffer[len] = '\\0';\n    return len;\n}\n\nclass DiagnosticMessageProcessorVulnerable {\npublic:\n    DiagnosticMessageProcessorVulnerable() {}\n\n    ~DiagnosticMessageProcessorVulnerable() {\n        clearLoggedEvents();\n    }\n\n    void clearLoggedEvents() {\n        for (auto& event : m_logged_events) {\n            if (event.parameter_str) {\n                free(event.parameter_str);\n            }\n        }\n        m_logged_events.clear();\n    }\n\n    bool logNumericEventVulnerable(uint32_t event_id, uint32_t numeric_value) {\n        LoggedEvent new_event;\n        new_event.event_id = event_id;\n        \n        new_event.parameter_str_capacity = MAX_UINT32_DIGITS;\n        new_event.parameter_str = (char*)malloc(new_event.parameter_str_capacity);\n        if (!new_event.parameter_str && new_event.parameter_str_capacity > 0) {\n            return false;\n        }\n\n        size_t actual_len = uint32_to_string_vulnerable(numeric_value, new_event.parameter_str);\n        \n        if (actual_len >= new_event.parameter_str_capacity) {\n            if (new_event.parameter_str) {\n                free(new_event.parameter_str);\n            }\n            return false;\n        }\n\n        m_logged_events.push_back(new_event);\n        return true;\n    }\n\n    const std::vector<LoggedEvent>& getLoggedEvents() const {\n        return m_logged_events;\n    }\n\nprivate:\n    std::vector<LoggedEvent> m_logged_events;\n};",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <vector>\n\n#define MAX_UINT32_STR_LEN (10 + 1)\n\nstruct LoggedEvent {\n    uint32_t event_id;\n    char*    parameter_str;\n    size_t   parameter_str_capacity;\n};\n\nsize_t uint32_to_string_fixed(uint32_t value, char* buffer, size_t buffer_capacity) {\n    if (!buffer || buffer_capacity == 0) {\n        return 0;\n    }\n\n    if (value == 0) {\n        if (buffer_capacity < 2) {\n            return 0;\n        }\n        buffer[0] = '0';\n        buffer[1] = '\\0';\n        return 1;\n    }\n\n    char temp_buffer[MAX_UINT32_STR_LEN];\n    int i = 0;\n    \n    uint32_t temp_val = value;\n    while (temp_val > 0) {\n        if (i >= MAX_UINT32_STR_LEN - 1) {\n            return 0;\n        }\n        temp_buffer[i++] = (temp_val % 10) + '0';\n        temp_val /= 10;\n    }\n\n    size_t len = i;\n    if (len >= buffer_capacity) {\n        return 0;\n    }\n\n    for (int j = 0; j < len; j++) {\n        buffer[j] = temp_buffer[i - 1 - j];\n    }\n    buffer[len] = '\\0';\n    return len;\n}\n\nclass DiagnosticMessageProcessorFixed {\npublic:\n    DiagnosticMessageProcessorFixed() {}\n\n    ~DiagnosticMessageProcessorFixed() {\n        clearLoggedEvents();\n    }\n\n    void clearLoggedEvents() {\n        for (auto& event : m_logged_events) {\n            if (event.parameter_str) {\n                free(event.parameter_str);\n            }\n        }\n        m_logged_events.clear();\n    }\n\n    bool logNumericEventFixed(uint32_t event_id, uint32_t numeric_value) {\n        LoggedEvent new_event;\n        new_event.event_id = event_id;\n        \n        new_event.parameter_str_capacity = MAX_UINT32_STR_LEN;\n        new_event.parameter_str = (char*)malloc(new_event.parameter_str_capacity);\n        if (!new_event.parameter_str && new_event.parameter_str_capacity > 0) {\n            return false;\n        }\n\n        size_t actual_len = uint32_to_string_fixed(numeric_value, new_event.parameter_str, new_event.parameter_str_capacity);\n        \n        if (actual_len == 0 && numeric_value != 0) {\n            if (new_event.parameter_str) {\n                free(new_event.parameter_str);\n            }\n            return false;\n        }\n        \n        m_logged_events.push_back(new_event);\n        return true;\n    }\n\n    const std::vector<LoggedEvent>& getLoggedEvents() const {\n        return m_logged_events;\n    }\n\nprivate:\n    std::vector<LoggedEvent> m_logged_events;\n};",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n\ntypedef struct {\n    uint32_t offset;\n    uint16_t length;\n    uint16_t chunk_id;\n} FirmwareChunkHeader;\n\nclass FirmwareUpdaterVulnerable {\nprivate:\n    uint8_t* m_firmware_image_buffer;\n    size_t   m_allocated_size;\n    uint32_t m_expected_total_firmware_size;\n    bool     m_is_initialized;\n\npublic:\n    FirmwareUpdaterVulnerable() : m_firmware_image_buffer(nullptr), m_allocated_size(0), m_expected_total_firmware_size(0), m_is_initialized(false) {}\n\n    ~FirmwareUpdaterVulnerable() {\n        if (m_firmware_image_buffer) {\n            free(m_firmware_image_buffer);\n            m_firmware_image_buffer = nullptr;\n        }\n    }\n\n    bool initializeUpdater(uint32_t total_firmware_size) {\n        if (total_firmware_size == 0 || total_firmware_size > (1024U * 1024U * 10U)) {\n            return false;\n        }\n        if (m_firmware_image_buffer) {\n            free(m_firmware_image_buffer);\n        }\n        m_firmware_image_buffer = (uint8_t*)malloc(total_firmware_size);\n        if (!m_firmware_image_buffer) {\n            m_allocated_size = 0;\n            m_expected_total_firmware_size = 0;\n            m_is_initialized = false;\n            return false;\n        }\n        m_allocated_size = total_firmware_size;\n        m_expected_total_firmware_size = total_firmware_size;\n        m_is_initialized = true;\n        return true;\n    }\n\n    bool applyFirmwareChunkVulnerable(const uint8_t* raw_chunk_data, size_t raw_chunk_data_len) {\n        if (!m_is_initialized || !m_firmware_image_buffer || raw_chunk_data_len < sizeof(FirmwareChunkHeader)) {\n            return false;\n        }\n\n        const FirmwareChunkHeader* header = reinterpret_cast<const FirmwareChunkHeader*>(raw_chunk_data);\n\n        if (raw_chunk_data_len < (sizeof(FirmwareChunkHeader) + header->length)) {\n            return false;\n        }\n        \n        if (header->offset >= m_expected_total_firmware_size) {\n            return false;\n        }\n\n        const uint8_t* chunk_payload_start = raw_chunk_data + sizeof(FirmwareChunkHeader);\n\n        for (uint16_t i = 0; i < header->length; ++i) {\n            m_firmware_image_buffer[header->offset + i] = chunk_payload_start[i];\n        }\n\n        return true;\n    }\n\n    const uint8_t* getFirmwareBuffer() const {\n        return m_firmware_image_buffer;\n    }\n\n    size_t getAllocatedSize() const {\n        return m_allocated_size;\n    }\n}",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <algorithm>\n\ntypedef struct {\n    uint32_t offset;\n    uint16_t length;\n    uint16_t chunk_id;\n} FirmwareChunkHeader;\n\nclass FirmwareUpdaterFixed {\nprivate:\n    uint8_t* m_firmware_image_buffer;\n    size_t   m_allocated_size;\n    uint32_t m_expected_total_firmware_size;\n    bool     m_is_initialized;\n\npublic:\n    FirmwareUpdaterFixed() : m_firmware_image_buffer(nullptr), m_allocated_size(0), m_expected_total_firmware_size(0), m_is_initialized(false) {}\n\n    ~FirmwareUpdaterFixed() {\n        if (m_firmware_image_buffer) {\n            free(m_firmware_image_buffer);\n            m_firmware_image_buffer = nullptr;\n        }\n    }\n\n    bool initializeUpdater(uint32_t total_firmware_size) {\n        if (total_firmware_size == 0 || total_firmware_size > (1024U * 1024U * 10U)) {\n            return false;\n        }\n        if (m_firmware_image_buffer) {\n            free(m_firmware_image_buffer);\n        }\n        m_firmware_image_buffer = (uint8_t*)malloc(total_firmware_size);\n        if (!m_firmware_image_buffer) {\n            m_allocated_size = 0;\n            m_expected_total_firmware_size = 0;\n            m_is_initialized = false;\n            return false;\n        }\n        m_allocated_size = total_firmware_size;\n        m_expected_total_firmware_size = total_firmware_size;\n        m_is_initialized = true;\n        return true;\n    }\n\n    bool applyFirmwareChunkFixed(const uint8_t* raw_chunk_data, size_t raw_chunk_data_len) {\n        if (!m_is_initialized || !m_firmware_image_buffer || raw_chunk_data_len < sizeof(FirmwareChunkHeader)) {\n            return false;\n        }\n\n        const FirmwareChunkHeader* header = reinterpret_cast<const FirmwareChunkHeader*>(raw_chunk_data);\n\n        if (raw_chunk_data_len < (sizeof(FirmwareChunkHeader) + header->length)) {\n            return false;\n        }\n\n        if (static_cast<size_t>(header->offset) >= m_allocated_size) {\n            return false;\n        }\n        if (header->length > (m_allocated_size - static_cast<size_t>(header->offset))) {\n            return false;\n        }\n\n        const uint8_t* chunk_payload_start = raw_chunk_data + sizeof(FirmwareChunkHeader);\n\n        for (uint16_t i = 0; i < header->length; ++i) {\n            m_firmware_image_buffer[header->offset + i] = chunk_payload_start[i];\n        }\n\n        return true;\n    }\n\n    const uint8_t* getFirmwareBuffer() const {\n        return m_firmware_image_buffer;\n    }\n\n    size_t getAllocatedSize() const {\n        return m_allocated_size;\n    }\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <new>\n\n#pragma pack(push, 1)\nstruct DiagnosticMessageHeader {\n    uint16_t message_id;\n    uint16_t data_length; \n    uint32_t timestamp_ms;\n};\n\nstruct DiagnosticPacketHeader {\n    uint32_t packet_sequence_num;\n    uint16_t num_messages;\n    uint16_t reserved;\n};\n#pragma pack(pop)\n\nclass DiagnosticMessageAggregatorVulnerable {\npublic:\n    DiagnosticMessageAggregatorVulnerable()\n        : m_aggregated_buffer(nullptr), m_current_size(0), m_allocated_capacity(0) {\n        m_allocated_capacity = 4096;\n        m_aggregated_buffer = (uint8_t*)malloc(m_allocated_capacity);\n        if (m_aggregated_buffer == nullptr) {\n            m_allocated_capacity = 0;\n        }\n        m_current_size = 0;\n    }\n\n    ~DiagnosticMessageAggregatorVulnerable() {\n        if (m_aggregated_buffer) {\n            free(m_aggregated_buffer);\n            m_aggregated_buffer = nullptr;\n        }\n    }\n\n    bool appendDiagnosticPacketVulnerable(const uint8_t* raw_packet, size_t packet_len) {\n        if (!raw_packet || packet_len < sizeof(DiagnosticPacketHeader)) {\n            return false;\n        }\n\n        const DiagnosticPacketHeader* packet_header = reinterpret_cast<const DiagnosticPacketHeader*>(raw_packet);\n        size_t current_raw_read_offset = sizeof(DiagnosticPacketHeader);\n\n        for (uint16_t i = 0; i < packet_header->num_messages; ++i) {\n            if (current_raw_read_offset + sizeof(DiagnosticMessageHeader) > packet_len) {\n                return false;\n            }\n\n            const DiagnosticMessageHeader* msg_header = reinterpret_cast<const DiagnosticMessageHeader*>(raw_packet + current_raw_read_offset);\n            uint16_t message_data_len = msg_header->data_length;\n\n            if (current_raw_read_offset + sizeof(DiagnosticMessageHeader) + message_data_len > packet_len) {\n                return false;\n            }\n\n            size_t total_message_storage_size = sizeof(DiagnosticMessageHeader) + message_data_len;\n\n            if (m_current_size > (SIZE_MAX - total_message_storage_size) || \n                m_current_size + total_message_storage_size > m_allocated_capacity) {\n\n                size_t new_capacity = m_allocated_capacity == 0 ? total_message_storage_size : m_allocated_capacity * 2;\n                if (new_capacity < m_current_size + total_message_storage_size) {\n                    new_capacity = m_current_size + total_message_storage_size;\n                }\n                \n                if (new_capacity > (16ULL * 1024 * 1024)) { \n                    if (total_message_storage_size > (16ULL * 1024 * 1024)) {\n                        return false;\n                    }\n                    new_capacity = (16ULL * 1024 * 1024);\n                }\n\n                uint8_t* new_buffer = (uint8_t*)realloc(m_aggregated_buffer, new_capacity);\n                if (!new_buffer) {\n                    if (m_aggregated_buffer) {\n                        free(m_aggregated_buffer);\n                        m_aggregated_buffer = nullptr;\n                    }\n                    m_current_size = 0;\n                    m_allocated_capacity = 0;\n                    return false;\n                }\n                m_aggregated_buffer = new_buffer;\n                m_allocated_capacity = new_capacity;\n            }\n\n            uint8_t* dest_ptr = m_aggregated_buffer + m_current_size;\n            const uint8_t* source_ptr = raw_packet + current_raw_read_offset;\n\n            for (size_t k = 0; k < sizeof(DiagnosticMessageHeader); ++k) {\n                dest_ptr[k] = source_ptr[k];\n            }\n\n            for (size_t k = 0; k < message_data_len; ++k) {\n                dest_ptr[sizeof(DiagnosticMessageHeader) + k] = source_ptr[sizeof(DiagnosticMessageHeader) + k];\n            }\n            \n            \n            m_aggregated_buffer[m_current_size + sizeof(DiagnosticMessageHeader) + message_data_len] = '\\0'; \n\n            m_current_size += total_message_storage_size; \n\n            current_raw_read_offset += sizeof(DiagnosticMessageHeader) + message_data_len;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getAggregatedBuffer() const { return m_aggregated_buffer; }\n    size_t getCurrentSize() const { return m_current_size; }\n    size_t getAllocatedCapacity() const { return m_allocated_capacity; }\n\nprivate:\n    uint8_t* m_aggregated_buffer;\n    size_t   m_current_size;\n    size_t   m_allocated_capacity;\n};",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <new>\n#include <algorithm>\n\n#pragma pack(push, 1)\nstruct DiagnosticMessageHeader {\n    uint16_t message_id;\n    uint16_t data_length; \n    uint32_t timestamp_ms;\n};\n\nstruct DiagnosticPacketHeader {\n    uint32_t packet_sequence_num;\n    uint16_t num_messages;\n    uint16_t reserved;\n};\n#pragma pack(pop)\n\nclass DiagnosticMessageAggregatorFixed {\npublic:\n    DiagnosticMessageAggregatorFixed()\n        : m_aggregated_buffer(nullptr), m_current_size(0), m_allocated_capacity(0) {\n        m_allocated_capacity = 4096;\n        m_aggregated_buffer = (uint8_t*)malloc(m_allocated_capacity);\n        if (m_aggregated_buffer == nullptr) {\n            m_allocated_capacity = 0;\n        }\n        m_current_size = 0;\n    }\n\n    ~DiagnosticMessageAggregatorFixed() {\n        if (m_aggregated_buffer) {\n            free(m_aggregated_buffer);\n            m_aggregated_buffer = nullptr;\n        }\n    }\n\n    bool appendDiagnosticPacketFixed(const uint8_t* raw_packet, size_t packet_len) {\n        if (!raw_packet || packet_len < sizeof(DiagnosticPacketHeader)) {\n            return false;\n        }\n\n        const DiagnosticPacketHeader* packet_header = reinterpret_cast<const DiagnosticPacketHeader*>(raw_packet);\n        size_t current_raw_read_offset = sizeof(DiagnosticPacketHeader);\n\n        for (uint16_t i = 0; i < packet_header->num_messages; ++i) {\n            if (current_raw_read_offset + sizeof(DiagnosticMessageHeader) > packet_len) {\n                return false;\n            }\n\n            const DiagnosticMessageHeader* msg_header = reinterpret_cast<const DiagnosticMessageHeader*>(raw_packet + current_raw_read_offset);\n            uint16_t message_data_len = msg_header->data_length;\n\n            if (current_raw_read_offset + sizeof(DiagnosticMessageHeader) + message_data_len > packet_len) {\n                return false;\n            }\n\n            size_t total_message_storage_size = sizeof(DiagnosticMessageHeader) + message_data_len;\n\n            if (m_current_size > (SIZE_MAX - total_message_storage_size) ||\n                m_current_size + total_message_storage_size > m_allocated_capacity) {\n\n                size_t new_capacity = m_allocated_capacity == 0 ? total_message_storage_size : m_allocated_capacity * 2;\n                if (new_capacity < m_current_size + total_message_storage_size) {\n                    new_capacity = m_current_size + total_message_storage_size;\n                }\n                \n                if (new_capacity > (16ULL * 1024 * 1024)) {\n                    if (total_message_storage_size > (16ULL * 1024 * 1024)) {\n                        return false; \n                    }\n                    new_capacity = (16ULL * 1024 * 1024);\n                }\n\n                uint8_t* new_buffer = (uint8_t*)realloc(m_aggregated_buffer, new_capacity);\n                if (!new_buffer) {\n                    if (m_aggregated_buffer) {\n                        free(m_aggregated_buffer);\n                        m_aggregated_buffer = nullptr;\n                    }\n                    m_current_size = 0;\n                    m_allocated_capacity = 0;\n                    return false;\n                }\n                m_aggregated_buffer = new_buffer;\n                m_allocated_capacity = new_capacity;\n            }\n\n            uint8_t* dest_ptr = m_aggregated_buffer + m_current_size;\n            const uint8_t* source_ptr = raw_packet + current_raw_read_offset;\n\n            for (size_t k = 0; k < sizeof(DiagnosticMessageHeader); ++k) {\n                dest_ptr[k] = source_ptr[k];\n            }\n\n            for (size_t k = 0; k < message_data_len; ++k) {\n                dest_ptr[sizeof(DiagnosticMessageHeader) + k] = source_ptr[sizeof(DiagnosticMessageHeader) + k];\n            }\n            \n            \n\n            m_current_size += total_message_storage_size;\n\n            current_raw_read_offset += sizeof(DiagnosticMessageHeader) + message_data_len;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getAggregatedBuffer() const { return m_aggregated_buffer; }\n    size_t getCurrentSize() const { return m_current_size; }\n    size_t getAllocatedCapacity() const { return m_allocated_capacity; }\n\nprivate:\n    uint8_t* m_aggregated_buffer;\n    size_t   m_current_size;\n    size_t   m_allocated_capacity;\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <vector>\n\n#pragma pack(push, 1)\n\nstruct ConfigPacketHeader {\n    uint32_t magic_id;\n    uint16_t num_entries;\n    uint32_t total_declared_size; \n};\n\nstruct ConfigEntryHeader {\n    uint16_t param_id;\n    uint16_t data_length; \n};\n\n#pragma pack(pop)\n\nclass VehicleConfigStoreVulnerable {\npublic:\n    VehicleConfigStoreVulnerable() : m_config_buffer(nullptr), m_current_buffer_size(0), m_allocated_capacity(0) {}\n\n    ~VehicleConfigStoreVulnerable() {\n        clearConfig();\n    }\n\n    void clearConfig() {\n        if (m_config_buffer) {\n            free(m_config_buffer);\n            m_config_buffer = nullptr;\n        }\n        m_current_buffer_size = 0;\n        m_allocated_capacity = 0;\n    }\n\n    bool processConfigPacketVulnerable(const uint8_t* raw_packet_data, size_t packet_length) {\n        if (!raw_packet_data || packet_length < sizeof(ConfigPacketHeader)) {\n            return false;\n        }\n\n        const ConfigPacketHeader* packet_hdr = reinterpret_cast<const ConfigPacketHeader*>(raw_packet_data);\n\n        if (packet_hdr->magic_id != 0xFEEDC0DE) {\n            return false;\n        }\n\n        if (packet_hdr->total_declared_size == 0) {\n            clearConfig();\n            return true; \n        }\n\n        uint8_t* new_buffer = (uint8_t*)realloc(m_config_buffer, packet_hdr->total_declared_size);\n        if (!new_buffer) {\n            clearConfig();\n            return false;\n        }\n        m_config_buffer = new_buffer;\n        m_allocated_capacity = packet_hdr->total_declared_size;\n        m_current_buffer_size = 0; \n\n        size_t current_read_offset = sizeof(ConfigPacketHeader);\n        size_t current_write_offset = 0;\n\n        for (uint16_t i = 0; i < packet_hdr->num_entries; ++i) {\n            if (current_read_offset + sizeof(ConfigEntryHeader) > packet_length) {\n                clearConfig();\n                return false;\n            }\n\n            const ConfigEntryHeader* entry_hdr = reinterpret_cast<const ConfigEntryHeader*>(raw_packet_data + current_read_offset);\n            uint16_t data_len = entry_hdr->data_length;\n\n            if (current_read_offset + sizeof(ConfigEntryHeader) + data_len > packet_length) {\n                clearConfig();\n                return false;\n            }\n\n            size_t entry_content_size_without_padding = sizeof(ConfigEntryHeader) + data_len;\n            size_t padding_bytes = (4 - (entry_content_size_without_padding % 4)) % 4;\n            if (entry_content_size_without_padding % 4 == 0) {\n                padding_bytes = 0;\n            }\n\n            size_t total_entry_storage_size = entry_content_size_without_padding + padding_bytes;\n            \n            memcpy(m_config_buffer + current_write_offset, entry_hdr, sizeof(ConfigEntryHeader));\n            current_write_offset += sizeof(ConfigEntryHeader);\n\n            memcpy(m_config_buffer + current_write_offset, raw_packet_data + current_read_offset + sizeof(ConfigEntryHeader), data_len);\n            current_write_offset += data_len;\n\n            if (padding_bytes > 0) {\n                memset(m_config_buffer + current_write_offset, 0, padding_bytes);\n                current_write_offset += padding_bytes;\n            }\n\n            current_read_offset += total_entry_storage_size;\n            m_current_buffer_size = current_write_offset; \n        }\n\n        return true;\n    }\n\n    const uint8_t* getConfigBuffer() const {\n        return m_config_buffer;\n    }\n\n    size_t getCurrentBufferSize() const {\n        return m_current_buffer_size;\n    }\n\n    size_t getAllocatedCapacity() const {\n        return m_allocated_capacity;\n    }\n\nprivate:\n    uint8_t* m_config_buffer;\n    size_t m_current_buffer_size;\n    size_t m_allocated_capacity;\n};",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <vector>\n#include <limits>\n\n#pragma pack(push, 1)\n\nstruct ConfigPacketHeader {\n    uint32_t magic_id;\n    uint16_t num_entries;\n    uint32_t total_declared_size; \n};\n\nstruct ConfigEntryHeader {\n    uint16_t param_id;\n    uint16_t data_length; \n};\n\n#pragma pack(pop)\n\nclass VehicleConfigStoreFixed {\npublic:\n    VehicleConfigStoreFixed() : m_config_buffer(nullptr), m_current_buffer_size(0), m_allocated_capacity(0) {}\n\n    ~VehicleConfigStoreFixed() {\n        clearConfig();\n    }\n\n    void clearConfig() {\n        if (m_config_buffer) {\n            free(m_config_buffer);\n            m_config_buffer = nullptr;\n        }\n        m_current_buffer_size = 0;\n        m_allocated_capacity = 0;\n    }\n\n    bool processConfigPacketFixed(const uint8_t* raw_packet_data, size_t packet_length) {\n        if (!raw_packet_data || packet_length < sizeof(ConfigPacketHeader)) {\n            return false;\n        }\n\n        const ConfigPacketHeader* packet_hdr = reinterpret_cast<const ConfigPacketHeader*>(raw_packet_data);\n\n        if (packet_hdr->magic_id != 0xFEEDC0DE) {\n            return false;\n        }\n        \n        if (packet_hdr->num_entries == 0) {\n            clearConfig();\n            return true; \n        }\n\n        size_t current_read_offset_scan = sizeof(ConfigPacketHeader);\n        size_t calculated_actual_payload_size = 0;\n\n        for (uint16_t i = 0; i < packet_hdr->num_entries; ++i) {\n            if (current_read_offset_scan > (packet_length - sizeof(ConfigEntryHeader))) {\n                return false;\n            }\n\n            const ConfigEntryHeader* entry_hdr = reinterpret_cast<const ConfigEntryHeader*>(raw_packet_data + current_read_offset_scan);\n            uint16_t data_len = entry_hdr->data_length;\n\n            if (data_len > (std::numeric_limits<size_t>::max() - sizeof(ConfigEntryHeader))) {\n                return false; \n            }\n            size_t entry_content_size_without_padding = sizeof(ConfigEntryHeader) + data_len;\n\n            size_t padding_bytes = (4 - (entry_content_size_without_padding % 4)) % 4;\n            if (entry_content_size_without_padding % 4 == 0) {\n                padding_bytes = 0;\n            }\n\n            if (entry_content_size_without_padding > (std::numeric_limits<size_t>::max() - padding_bytes)) {\n                return false; \n            }\n            size_t total_entry_storage_size = entry_content_size_without_padding + padding_bytes;\n\n            if (current_read_offset_scan > (packet_length - total_entry_storage_size)) {\n                return false;\n            }\n\n            if (calculated_actual_payload_size > (std::numeric_limits<size_t>::max() - total_entry_storage_size)) {\n                return false; \n            }\n            calculated_actual_payload_size += total_entry_storage_size;\n            \n            current_read_offset_scan += total_entry_storage_size;\n        }\n\n        if (calculated_actual_payload_size != packet_hdr->total_declared_size) {\n            return false; \n        }\n\n        uint8_t* new_buffer = (uint8_t*)realloc(m_config_buffer, calculated_actual_payload_size);\n        if (!new_buffer) {\n            clearConfig();\n            return false;\n        }\n        m_config_buffer = new_buffer;\n        m_allocated_capacity = calculated_actual_payload_size;\n        m_current_buffer_size = 0;\n\n        size_t current_read_offset_copy = sizeof(ConfigPacketHeader);\n        size_t current_write_offset = 0;\n\n        for (uint16_t i = 0; i < packet_hdr->num_entries; ++i) {\n            const ConfigEntryHeader* entry_hdr = reinterpret_cast<const ConfigEntryHeader*>(raw_packet_data + current_read_offset_copy);\n            uint16_t data_len = entry_hdr->data_length;\n\n            size_t entry_content_size_without_padding = sizeof(ConfigEntryHeader) + data_len;\n            size_t padding_bytes = (4 - (entry_content_size_without_padding % 4)) % 4;\n            if (entry_content_size_without_padding % 4 == 0) {\n                padding_bytes = 0;\n            }\n            size_t total_entry_storage_size = entry_content_size_without_padding + padding_bytes;\n\n            if (current_write_offset > (m_allocated_capacity - total_entry_storage_size)) {\n                clearConfig();\n                return false;\n            }\n            \n            memcpy(m_config_buffer + current_write_offset, entry_hdr, sizeof(ConfigEntryHeader));\n            current_write_offset += sizeof(ConfigEntryHeader);\n\n            memcpy(m_config_buffer + current_write_offset, raw_packet_data + current_read_offset_copy + sizeof(ConfigEntryHeader), data_len);\n            current_write_offset += data_len;\n\n            if (padding_bytes > 0) {\n                memset(m_config_buffer + current_write_offset, 0, padding_bytes);\n                current_write_offset += padding_bytes;\n            }\n            \n            current_read_offset_copy += total_entry_storage_size;\n            m_current_buffer_size = current_write_offset;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getConfigBuffer() const {\n        return m_config_buffer;\n    }\n\n    size_t getCurrentBufferSize() const {\n        return m_current_buffer_size;\n    }\n\n    size_t getAllocatedCapacity() const {\n        return m_allocated_capacity;\n    }\n\nprivate:\n    uint8_t* m_config_buffer;\n    size_t m_current_buffer_size;\n    size_t m_allocated_capacity;\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <new>\n\n#pragma pack(push, 1)\n\nstruct DiagnosticReportPacketHeader {\n    uint16_t report_id;\n    uint16_t num_data_elements; \n    uint32_t total_payload_bytes; \n};\n\nstruct DiagnosticDataElement {\n    uint16_t element_tag;\n    uint16_t data_length; \n};\n\nstruct AggregatedDataEntry {\n    uint16_t element_tag;\n    uint16_t actual_data_length; \n};\n\n#pragma pack(pop)\n\nclass DiagnosticDataAggregatorVulnerable {\npublic:\n    DiagnosticDataAggregatorVulnerable() : m_aggregated_buffer(nullptr), m_buffer_capacity(0), m_current_write_offset(0) {}\n\n    ~DiagnosticDataAggregatorVulnerable() {\n        if (m_aggregated_buffer) {\n            free(m_aggregated_buffer);\n            m_aggregated_buffer = nullptr;\n        }\n    }\n\n    bool processDiagnosticReportVulnerable(const uint8_t* raw_packet, size_t packet_length) {\n        if (!raw_packet || packet_length < sizeof(DiagnosticReportPacketHeader)) {\n            return false;\n        }\n\n        const DiagnosticReportPacketHeader* packet_header = reinterpret_cast<const DiagnosticReportPacketHeader*>(raw_packet);\n\n        if (packet_length < (sizeof(DiagnosticReportPacketHeader) + packet_header->total_payload_bytes)) {\n            return false;\n        }\n\n        if (m_aggregated_buffer) {\n            free(m_aggregated_buffer);\n            m_aggregated_buffer = nullptr;\n            m_current_write_offset = 0;\n            m_buffer_capacity = 0;\n        }\n\n        m_buffer_capacity = packet_header->total_payload_bytes; \n        \n        if (m_buffer_capacity == 0 && packet_header->num_data_elements > 0) {\n            return false; \n        }\n\n        m_aggregated_buffer = (uint8_t*)malloc(m_buffer_capacity);\n        if (!m_aggregated_buffer && m_buffer_capacity > 0) {\n            return false; \n        }\n        \n        size_t current_raw_read_offset = sizeof(DiagnosticReportPacketHeader);\n        m_current_write_offset = 0;\n\n        for (uint16_t i = 0; i < packet_header->num_data_elements; ++i) {\n            if (current_raw_read_offset + sizeof(DiagnosticDataElement) > packet_length) {\n                return false;\n            }\n\n            const DiagnosticDataElement* incoming_element_header = \n                reinterpret_cast<const DiagnosticDataElement*>(raw_packet + current_raw_read_offset);\n\n            uint16_t current_data_len = incoming_element_header->data_length;\n\n            if (current_raw_read_offset + sizeof(DiagnosticDataElement) + current_data_len > packet_length) {\n                return false;\n            }\n            \n            size_t space_needed_for_this_entry = sizeof(AggregatedDataEntry) + current_data_len;\n\n            if (m_current_write_offset + space_needed_for_this_entry > m_buffer_capacity) {\n                return false;\n            }\n\n            uint16_t tag_to_copy = incoming_element_header->element_tag;\n            memcpy(m_aggregated_buffer + m_current_write_offset, &tag_to_copy, sizeof(tag_to_copy));\n            m_current_write_offset += sizeof(tag_to_copy);\n\n            uint16_t len_to_copy = incoming_element_header->data_length;\n            memcpy(m_aggregated_buffer + m_current_write_offset, &len_to_copy, sizeof(len_to_copy));\n            m_current_write_offset += sizeof(len_to_copy);\n\n            memcpy(m_aggregated_buffer + m_current_write_offset, \n                   raw_packet + current_raw_read_offset + sizeof(DiagnosticDataElement), \n                   current_data_len);\n            m_current_write_offset += current_data_len;\n\n            current_raw_read_offset += sizeof(DiagnosticDataElement) + current_data_len;\n        }\n\n        if (m_current_write_offset != packet_header->total_payload_bytes + (packet_header->num_data_elements * sizeof(AggregatedDataEntry))) {\n            return false;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getAggregatedBuffer() const { return m_aggregated_buffer; }\n    size_t getBufferCapacity() const { return m_buffer_capacity; }\n    size_t getCurrentWriteOffset() const { return m_current_write_offset; }\n\nprivate:\n    uint8_t* m_aggregated_buffer;\n    size_t m_buffer_capacity;\n    size_t m_current_write_offset;\n};",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <new>\n#include <limits>\n\n#pragma pack(push, 1)\n\nstruct DiagnosticReportPacketHeader {\n    uint16_t report_id;\n    uint16_t num_data_elements;\n    uint32_t total_payload_bytes;\n};\n\nstruct DiagnosticDataElement {\n    uint16_t element_tag;\n    uint16_t data_length;\n};\n\nstruct AggregatedDataEntry {\n    uint16_t element_tag;\n    uint16_t actual_data_length;\n};\n\n#pragma pack(pop)\n\nclass DiagnosticDataAggregatorFixed {\npublic:\n    DiagnosticDataAggregatorFixed() : m_aggregated_buffer(nullptr), m_buffer_capacity(0), m_current_write_offset(0) {}\n\n    ~DiagnosticDataAggregatorFixed() {\n        if (m_aggregated_buffer) {\n            free(m_aggregated_buffer);\n            m_aggregated_buffer = nullptr;\n        }\n    }\n\n    bool processDiagnosticReportFixed(const uint8_t* raw_packet, size_t packet_length) {\n        if (!raw_packet || packet_length < sizeof(DiagnosticReportPacketHeader)) {\n            return false;\n        }\n\n        const DiagnosticReportPacketHeader* packet_header = reinterpret_cast<const DiagnosticReportPacketHeader*>(raw_packet);\n\n        static const uint16_t MAX_ALLOWED_DATA_ELEMENTS = 1000; \n        if (packet_header->num_data_elements > MAX_ALLOWED_DATA_ELEMENTS) {\n            return false;\n        }\n\n        size_t actual_parsed_payload_sum = 0;\n        size_t temp_read_offset = sizeof(DiagnosticReportPacketHeader);\n\n        for (uint16_t i = 0; i < packet_header->num_data_elements; ++i) {\n            if (temp_read_offset + sizeof(DiagnosticDataElement) > packet_length) {\n                return false;\n            }\n            const DiagnosticDataElement* temp_element_header = \n                reinterpret_cast<const DiagnosticDataElement*>(raw_packet + temp_read_offset);\n            \n            uint16_t element_data_len = temp_element_header->data_length;\n\n            if (temp_read_offset + sizeof(DiagnosticDataElement) + element_data_len > packet_length) {\n                return false;\n            }\n\n            if (element_data_len > (std::numeric_limits<size_t>::max() - actual_parsed_payload_sum)) {\n                 return false;\n            }\n            actual_parsed_payload_sum += element_data_len;\n            temp_read_offset += sizeof(DiagnosticDataElement) + element_data_len;\n        }\n\n        if (actual_parsed_payload_sum != packet_header->total_payload_bytes) {\n            return false;\n        }\n\n        size_t metadata_overhead_per_element = sizeof(AggregatedDataEntry);\n        \n        if (packet_header->num_data_elements > (std::numeric_limits<size_t>::max() / metadata_overhead_per_element)) {\n            return false;\n        }\n        size_t total_metadata_overhead = static_cast<size_t>(packet_header->num_data_elements) * metadata_overhead_per_element;\n\n        if (packet_header->total_payload_bytes > (std::numeric_limits<size_t>::max() - total_metadata_overhead)) {\n            return false;\n        }\n        size_t required_internal_buffer_size = packet_header->total_payload_bytes + total_metadata_overhead;\n\n        if (m_aggregated_buffer) {\n            free(m_aggregated_buffer);\n            m_aggregated_buffer = nullptr;\n            m_current_write_offset = 0;\n            m_buffer_capacity = 0;\n        }\n\n        if (required_internal_buffer_size == 0) {\n            m_aggregated_buffer = nullptr;\n            m_buffer_capacity = 0;\n            return true;\n        }\n\n        m_aggregated_buffer = (uint8_t*)malloc(required_internal_buffer_size);\n        if (!m_aggregated_buffer) {\n            return false;\n        }\n        m_buffer_capacity = required_internal_buffer_size;\n        \n        size_t current_raw_read_offset = sizeof(DiagnosticReportPacketHeader);\n        m_current_write_offset = 0;\n\n        for (uint16_t i = 0; i < packet_header->num_data_elements; ++i) {\n            const DiagnosticDataElement* incoming_element_header = \n                reinterpret_cast<const DiagnosticDataElement*>(raw_packet + current_raw_read_offset);\n            uint16_t current_data_len = incoming_element_header->data_length;\n\n            size_t space_needed_for_this_entry = sizeof(AggregatedDataEntry) + current_data_len;\n            if (m_current_write_offset > m_buffer_capacity - space_needed_for_this_entry) {\n                return false; \n            }\n\n            uint16_t tag_to_copy = incoming_element_header->element_tag;\n            memcpy(m_aggregated_buffer + m_current_write_offset, &tag_to_copy, sizeof(tag_to_copy));\n            m_current_write_offset += sizeof(tag_to_copy);\n\n            uint16_t len_to_copy = incoming_element_header->data_length;\n            memcpy(m_aggregated_buffer + m_current_write_offset, &len_to_copy, sizeof(len_to_copy));\n            m_current_write_offset += sizeof(len_to_copy);\n\n            memcpy(m_aggregated_buffer + m_current_write_offset, \n                   raw_packet + current_raw_read_offset + sizeof(DiagnosticDataElement), \n                   current_data_len);\n            m_current_write_offset += current_data_len;\n\n            current_raw_read_offset += sizeof(DiagnosticDataElement) + current_data_len;\n        }\n\n        if (m_current_write_offset != m_buffer_capacity) {\n            return false;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getAggregatedBuffer() const { return m_aggregated_buffer; }\n    size_t getBufferCapacity() const { return m_buffer_capacity; }\n    size_t getCurrentWriteOffset() const { return m_current_write_offset; }\n\nprivate:\n    uint8_t* m_aggregated_buffer;\n    size_t m_buffer_capacity;\n    size_t m_current_write_offset;\n};",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <vector>\n#include <cstring> \n\nstruct TelemetryParameterVulnerable {\n    uint16_t id;\n    const char* value_str;\n};\n\nclass TelemetryMessageBuilderVulnerable {\npublic:\n    TelemetryMessageBuilderVulnerable() : m_message_buffer(nullptr), m_buffer_size(0) {}\n\n    ~TelemetryMessageBuilderVulnerable() {\n        if (m_message_buffer) {\n            free(m_message_buffer);\n        }\n    }\n\n    void addParameter(uint16_t id, const char* value) {\n        if (value) {\n            m_parameters.push_back({id, value});\n        }\n    }\n\n    bool buildMessageVulnerable() {\n        if (m_message_buffer) {\n            free(m_message_buffer);\n            m_message_buffer = nullptr;\n            m_buffer_size = 0;\n        }\n\n        size_t calculated_total_len = 0;\n        for (const auto& param : m_parameters) {\n            // VULNERABILITY: Calculated length does NOT account for the null terminator\n            // that will be written for each string parameter. strlen() returns the length\n            // WITHOUT the null terminator. Each string requires strlen() + 1 byte for null termination.\n            calculated_total_len += sizeof(param.id) + strlen(param.value_str);\n        }\n\n        if (m_parameters.empty()) {\n            return true;\n        }\n\n        if (calculated_total_len == 0) {\n            // This case might be an error if parameters exist but total length is 0.\n            // For example, if all strings are empty and only IDs are present.\n            return false;\n        }\n\n        m_message_buffer = (uint8_t*)malloc(calculated_total_len);\n        if (!m_message_buffer) {\n            return false;\n        }\n        m_buffer_size = calculated_total_len;\n\n        size_t current_offset = 0;\n        for (const auto& param : m_parameters) {\n            // Write parameter ID (manual byte copy)\n            uint16_t network_order_id = param.id; \n            for (size_t i = 0; i < sizeof(network_order_id); ++i) {\n                // Basic bounds check, but the main vulnerability is in calculation of m_buffer_size\n                if (current_offset + i >= m_buffer_size) {\n                    free(m_message_buffer);\n                    m_message_buffer = nullptr;\n                    m_buffer_size = 0;\n                    return false;\n                }\n                m_message_buffer[current_offset + i] = ((uint8_t*)&network_order_id)[i];\n            }\n            current_offset += sizeof(network_order_id);\n\n            // Write parameter value string (includes null terminator)\n            size_t value_len = strlen(param.value_str);\n            for (size_t i = 0; i <= value_len; ++i) { // Loop includes the null terminator (i <= value_len)\n                // VULNERABILITY HERE: If buffer is exactly sized for `value_len` and this is the last item,\n                // `current_offset + i` will access `m_buffer_size` (out-of-bounds) when `i == value_len`,\n                // causing a heap-based buffer overflow for each string's null terminator.\n                if (current_offset + i >= m_buffer_size) {\n                    free(m_message_buffer);\n                    m_message_buffer = nullptr;\n                    m_buffer_size = 0;\n                    return false;\n                }\n                m_message_buffer[current_offset + i] = param.value_str[i];\n            }\n            current_offset += (value_len + 1); // Advance offset including null terminator\n        }\n\n        // This check comes *after* the potential overflow has already occurred.\n        if (current_offset > m_buffer_size) {\n            free(m_message_buffer);\n            m_message_buffer = nullptr;\n            m_buffer_size = 0;\n            return false;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getMessageBuffer() const {\n        return m_message_buffer;\n    }\n\n    size_t getBufferSize() const {\n        return m_buffer_size;\n    }\n\nprivate:\n    std::vector<TelemetryParameterVulnerable> m_parameters;\n    uint8_t* m_message_buffer;\n    size_t m_buffer_size;\n};",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <vector>\n#include <cstring> \n#include <limits>  \n\nstruct TelemetryParameterFixed {\n    uint16_t id;\n    const char* value_str;\n};\n\nclass TelemetryMessageBuilderFixed {\npublic:\n    TelemetryMessageBuilderFixed() : m_message_buffer(nullptr), m_buffer_size(0) {}\n\n    ~TelemetryMessageBuilderFixed() {\n        if (m_message_buffer) {\n            free(m_message_buffer);\n        }\n    }\n\n    void addParameter(uint16_t id, const char* value) {\n        if (value) {\n            m_parameters.push_back({id, value});\n        }\n    }\n\n    bool buildMessageFixed() {\n        if (m_message_buffer) {\n            free(m_message_buffer);\n            m_message_buffer = nullptr;\n            m_buffer_size = 0;\n        }\n\n        size_t calculated_total_len = 0;\n        for (const auto& param : m_parameters) {\n            size_t current_param_entry_size;\n            size_t string_len = strlen(param.value_str);\n\n            // FIX: Check for overflow before adding components to current_param_entry_size\n            if (string_len > std::numeric_limits<size_t>::max() - sizeof(param.id) - 1) {\n                return false; \n            }\n            // FIX: Account for the null terminator (+1) for each string.\n            current_param_entry_size = sizeof(param.id) + string_len + 1;\n\n            // FIX: Check for overflow when summing up total length\n            if (calculated_total_len > std::numeric_limits<size_t>::max() - current_param_entry_size) {\n                return false; \n            }\n            calculated_total_len += current_param_entry_size;\n        }\n\n        if (m_parameters.empty()) {\n            if (calculated_total_len != 0) {\n                return false;\n            }\n            return true;\n        }\n\n        if (calculated_total_len == 0) {\n            return false;\n        }\n\n        m_message_buffer = (uint8_t*)malloc(calculated_total_len);\n        if (!m_message_buffer) {\n            return false;\n        }\n        m_buffer_size = calculated_total_len;\n\n        size_t current_offset = 0;\n        for (const auto& param : m_parameters) {\n            // Write parameter ID (manual byte copy)\n            uint16_t network_order_id = param.id; \n            \n            // FIX: Bounds check before writing ID\n            if (current_offset > m_buffer_size - sizeof(network_order_id)) {\n                free(m_message_buffer); m_message_buffer = nullptr; m_buffer_size = 0;\n                return false;\n            }\n            for (size_t i = 0; i < sizeof(network_order_id); ++i) {\n                m_message_buffer[current_offset + i] = ((uint8_t*)&network_order_id)[i];\n            }\n            current_offset += sizeof(network_order_id);\n\n            // Write parameter value string (includes null terminator)\n            size_t value_len = strlen(param.value_str);\n            \n            // FIX: Explicit bounds check before writing string + null terminator\n            if (current_offset > m_buffer_size - (value_len + 1)) {\n                free(m_message_buffer); m_message_buffer = nullptr; m_buffer_size = 0;\n                return false;\n            }\n            for (size_t i = 0; i <= value_len; ++i) {\n                m_message_buffer[current_offset + i] = param.value_str[i];\n            }\n            current_offset += (value_len + 1);\n        }\n\n        if (current_offset != m_buffer_size) {\n            free(m_message_buffer);\n            m_message_buffer = nullptr;\n            m_buffer_size = 0;\n            return false;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getMessageBuffer() const {\n        return m_message_buffer;\n    }\n\n    size_t getBufferSize() const {\n        return m_buffer_size;\n    }\n\nprivate:\n    std::vector<TelemetryParameterFixed> m_parameters;\n    uint8_t* m_message_buffer;\n    size_t m_buffer_size;\n};",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <new>\n\n#pragma pack(push, 1)\nstruct CalibrationPointWireFormat {\n    uint16_t id;\n    uint32_t value;\n};\n#pragma pack(pop)\n\nstruct CalibrationPointStorage {\n    uint16_t id;\n    uint32_t value;\n};\n\nclass CalibrationManagerVulnerable {\npublic:\n    CalibrationManagerVulnerable() : m_calibration_data(nullptr), m_num_stored_points(0) {}\n\n    ~CalibrationManagerVulnerable() {\n        if (m_calibration_data) {\n            free(m_calibration_data);\n            m_calibration_data = nullptr;\n        }\n    }\n\n    bool processCalibrationPacketVulnerable(const uint8_t* raw_packet, size_t packet_len) {\n        if (!raw_packet || packet_len < sizeof(uint16_t)) {\n            return false;\n        }\n\n        uint16_t num_points = *reinterpret_cast<const uint16_t*>(raw_packet);\n        size_t expected_packet_payload_len = (size_t)num_points * sizeof(CalibrationPointWireFormat);\n        size_t total_expected_packet_len = sizeof(uint16_t) + expected_packet_payload_len;\n\n        if (packet_len < total_expected_packet_len) {\n            return false;\n        }\n\n        if (m_calibration_data) {\n            free(m_calibration_data);\n            m_calibration_data = nullptr;\n        }\n\n        size_t allocation_size_bytes = (size_t)num_points * sizeof(CalibrationPointWireFormat);\n        \n        m_calibration_data = (CalibrationPointStorage*)malloc(allocation_size_bytes);\n        if (!m_calibration_data && allocation_size_bytes > 0) {\n            m_num_stored_points = 0;\n            return false;\n        }\n\n        const uint8_t* current_read_ptr = raw_packet + sizeof(uint16_t);\n        \n        for (uint16_t i = 0; i < num_points; ++i) {\n            memcpy(&m_calibration_data[i], current_read_ptr, sizeof(CalibrationPointWireFormat));\n            current_read_ptr += sizeof(CalibrationPointWireFormat);\n        }\n\n        m_num_stored_points = num_points;\n        return true;\n    }\n\n    const CalibrationPointStorage* getCalibrationData() const {\n        return m_calibration_data;\n    }\n\n    uint16_t getNumStoredPoints() const {\n        return m_num_stored_points;\n    }\n\nprivate:\n    CalibrationPointStorage* m_calibration_data;\n    uint16_t m_num_stored_points;\n};",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <new>\n\n#pragma pack(push, 1)\nstruct CalibrationPointWireFormatFixed {\n    uint16_t id;\n    uint32_t value;\n};\n#pragma pack(pop)\n\nstruct CalibrationPointStorageFixed {\n    uint16_t id;\n    uint32_t value;\n};\n\nclass CalibrationManagerFixed {\npublic:\n    CalibrationManagerFixed() : m_calibration_data(nullptr), m_num_stored_points(0) {}\n\n    ~CalibrationManagerFixed() {\n        if (m_calibration_data) {\n            free(m_calibration_data);\n            m_calibration_data = nullptr;\n        }\n    }\n\n    bool processCalibrationPacketFixed(const uint8_t* raw_packet, size_t packet_len) {\n        if (!raw_packet || packet_len < sizeof(uint16_t)) {\n            return false;\n        }\n\n        uint16_t num_points = *reinterpret_cast<const uint16_t*>(raw_packet);\n        size_t expected_packet_payload_len = (size_t)num_points * sizeof(CalibrationPointWireFormatFixed);\n        size_t total_expected_packet_len = sizeof(uint16_t) + expected_packet_payload_len;\n\n        if (packet_len < total_expected_packet_len) {\n            return false;\n        }\n\n        if (m_calibration_data) {\n            free(m_calibration_data);\n            m_calibration_data = nullptr;\n        }\n\n        size_t allocation_size_bytes = (size_t)num_points * sizeof(CalibrationPointStorageFixed);\n        \n        m_calibration_data = (CalibrationPointStorageFixed*)malloc(allocation_size_bytes);\n        if (!m_calibration_data && allocation_size_bytes > 0) {\n            m_num_stored_points = 0;\n            return false;\n        }\n\n        const uint8_t* current_read_ptr = raw_packet + sizeof(uint16_t);\n        \n        for (uint16_t i = 0; i < num_points; ++i) {\n            CalibrationPointWireFormatFixed temp_wire_point;\n            memcpy(&temp_wire_point, current_read_ptr, sizeof(CalibrationPointWireFormatFixed));\n\n            m_calibration_data[i].id = temp_wire_point.id;\n            m_calibration_data[i].value = temp_wire_point.value;\n            \n            current_read_ptr += sizeof(CalibrationPointWireFormatFixed);\n        }\n\n        m_num_stored_points = num_points;\n        return true;\n    }\n\n    const CalibrationPointStorageFixed* getCalibrationData() const {\n        return m_calibration_data;\n    }\n\n    uint16_t getNumStoredPoints() const {\n        return m_num_stored_points;\n}\n\nprivate:\n    CalibrationPointStorageFixed* m_calibration_data;\n    uint16_t m_num_stored_points;\n};",
    "analysis": ""
  },
  {
    "cwe_id": "122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <limits>\n\n#define DTC_ALIGNMENT_BYTES 4\n\n#pragma pack(push, 1)\nstruct DTCHeader {\n    uint16_t dtc_id;\n    uint16_t data_length; \n};\n\nstruct DTCBatchPacket {\n    uint32_t timestamp;\n    uint16_t num_dtc_entries;\n};\n#pragma pack(pop)\n\nclass DiagnosticBufferVulnerable {\nprivate:\n    uint8_t* m_consolidated_buffer;\n    size_t   m_current_write_offset;\n    size_t   m_allocated_capacity;\n\npublic:\n    DiagnosticBufferVulnerable() :\n        m_consolidated_buffer(nullptr),\n        m_current_write_offset(0),\n        m_allocated_capacity(0)\n    {\n        m_allocated_capacity = 1024; \n        m_consolidated_buffer = (uint8_t*)malloc(m_allocated_capacity);\n        if (!m_consolidated_buffer) {\n            m_allocated_capacity = 0;\n        }\n    }\n\n    ~DiagnosticBufferVulnerable() {\n        if (m_consolidated_buffer) {\n            free(m_consolidated_buffer);\n            m_consolidated_buffer = nullptr;\n        }\n    }\n\n    bool addDTCBatchVulnerable(const uint8_t* packet_data, size_t packet_length) {\n        if (!packet_data || packet_length < sizeof(DTCBatchPacket)) {\n            return false;\n        }\n\n        const DTCBatchPacket* batch_hdr = reinterpret_cast<const DTCBatchPacket*>(packet_data);\n        size_t current_packet_read_offset = sizeof(DTCBatchPacket);\n        \n        size_t total_payload_bytes_in_batch = 0;\n\n        for (uint16_t i = 0; i < batch_hdr->num_dtc_entries; ++i) {\n            if (current_packet_read_offset + sizeof(DTCHeader) > packet_length) {\n                return false;\n            }\n            const DTCHeader* dtc_hdr = reinterpret_cast<const DTCHeader*>(packet_data + current_packet_read_offset);\n            \n            uint16_t dtc_data_len = dtc_hdr->data_length;\n\n            size_t entry_total_raw_size = sizeof(DTCHeader) + dtc_data_len;\n\n            if (current_packet_read_offset + entry_total_raw_size > packet_length) {\n                return false;\n            }\n            \n            if (total_payload_bytes_in_batch > SIZE_MAX - entry_total_raw_size) {\n                return false;\n            }\n            // VULNERABILITY:\n            // The sum for allocation calculation 'total_payload_bytes_in_batch' only accounts for the raw data length\n            // (header + data_length), but not the necessary padding that will be added to each entry\n            // for alignment purposes in the consolidated buffer.\n            total_payload_bytes_in_batch += entry_total_raw_size;\n\n            current_packet_read_offset += entry_total_raw_size;\n        }\n\n        size_t required_total_space = m_current_write_offset + total_payload_bytes_in_batch;\n        \n        if (required_total_space > m_allocated_capacity) {\n            size_t new_capacity = m_allocated_capacity * 2;\n            if (new_capacity < required_total_space) {\n                new_capacity = required_total_space;\n            }\n            if (new_capacity > (10 * 1024 * 1024)) {\n                if (required_total_space > (10 * 1024 * 1024)) {\n                    return false;\n                }\n                new_capacity = (10 * 1024 * 1024);\n            }\n\n            uint8_t* new_buffer = (uint8_t*)realloc(m_consolidated_buffer, new_capacity);\n            if (!new_buffer) {\n                free(m_consolidated_buffer);\n                m_consolidated_buffer = nullptr;\n                m_current_write_offset = 0;\n                m_allocated_capacity = 0;\n                return false;\n            }\n            m_consolidated_buffer = new_buffer;\n            m_allocated_capacity = new_capacity;\n        }\n\n        current_packet_read_offset = sizeof(DTCBatchPacket);\n\n        for (uint16_t i = 0; i < batch_hdr->num_dtc_entries; ++i) {\n            const DTCHeader* dtc_hdr = reinterpret_cast<const DTCHeader*>(packet_data + current_packet_read_offset);\n            uint16_t dtc_data_len = dtc_hdr->data_length;\n\n            size_t entry_total_raw_size = sizeof(DTCHeader) + dtc_data_len;\n            // This is the actual size including padding that will be written\n            size_t entry_actual_storage_size = (entry_total_raw_size + DTC_ALIGNMENT_BYTES - 1) & ~(DTC_ALIGNMENT_BYTES - 1);\n            \n            // VULNERABILITY: If the buffer was undersized due to the previous calculation, \n            // the following byte-by-byte copies and padding write operations will go out of bounds.\n            // Copy header bytes manually\n            m_consolidated_buffer[m_current_write_offset] = (uint8_t)(dtc_hdr->dtc_id & 0xFF);\n            m_consolidated_buffer[m_current_write_offset + 1] = (uint8_t)((dtc_hdr->dtc_id >> 8) & 0xFF);\n            m_consolidated_buffer[m_current_write_offset + 2] = (uint8_t)(dtc_hdr->data_length & 0xFF);\n            m_consolidated_buffer[m_current_write_offset + 3] = (uint8_t)((dtc_hdr->data_length >> 8) & 0xFF);\n            \n            // Copy data payload bytes manually\n            const uint8_t* payload_src = packet_data + current_packet_read_offset + sizeof(DTCHeader);\n            for (uint16_t j = 0; j < dtc_data_len; ++j) {\n                m_consolidated_buffer[m_current_write_offset + sizeof(DTCHeader) + j] = payload_src[j];\n            }\n\n            // Fill padding bytes with zeros manually\n            size_t bytes_to_pad = entry_actual_storage_size - entry_total_raw_size;\n            if (bytes_to_pad > 0) {\n                for (size_t k = 0; k < bytes_to_pad; ++k) {\n                    m_consolidated_buffer[m_current_write_offset + entry_total_raw_size + k] = 0;\n                }\n            }\n            \n            m_current_write_offset += entry_actual_storage_size;\n            current_packet_read_offset += entry_total_raw_size;\n        }\n\n        return true;\n    }\n\n    size_t getCurrentBufferSize() const { return m_current_write_offset; }\n    size_t getAllocatedCapacity() const { return m_allocated_capacity; }\n    const uint8_t* getConsolidatedBuffer() const { return m_consolidated_buffer; }\n};\n",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <limits>\n\n#define DTC_ALIGNMENT_BYTES 4\n\n#pragma pack(push, 1)\nstruct DTCHeader {\n    uint16_t dtc_id;\n    uint16_t data_length;\n};\n\nstruct DTCBatchPacket {\n    uint32_t timestamp;\n    uint16_t num_dtc_entries;\n};\n#pragma pack(pop)\n\nclass DiagnosticBufferFixed {\nprivate:\n    uint8_t* m_consolidated_buffer;\n    size_t   m_current_write_offset;\n    size_t   m_allocated_capacity;\n\npublic:\n    DiagnosticBufferFixed() :\n        m_consolidated_buffer(nullptr),\n        m_current_write_offset(0),\n        m_allocated_capacity(0)\n    {\n        m_allocated_capacity = 1024;\n        m_consolidated_buffer = (uint8_t*)malloc(m_allocated_capacity);\n        if (!m_consolidated_buffer) {\n            m_allocated_capacity = 0;\n        }\n    }\n\n    ~DiagnosticBufferFixed() {\n        if (m_consolidated_buffer) {\n            free(m_consolidated_buffer);\n            m_consolidated_buffer = nullptr;\n        }\n    }\n\n    bool addDTCBatchFixed(const uint8_t* packet_data, size_t packet_length) {\n        if (!packet_data || packet_length < sizeof(DTCBatchPacket)) {\n            return false;\n        }\n\n        const DTCBatchPacket* batch_hdr = reinterpret_cast<const DTCBatchPacket*>(packet_data);\n        size_t current_packet_read_offset = sizeof(DTCBatchPacket);\n        \n        size_t total_required_storage_for_batch = 0;\n        \n        static const uint16_t MAX_DTC_ENTRIES = 200; \n        if (batch_hdr->num_dtc_entries > MAX_DTC_ENTRIES) {\n            return false;\n        }\n\n        for (uint16_t i = 0; i < batch_hdr->num_dtc_entries; ++i) {\n            if (current_packet_read_offset > packet_length - sizeof(DTCHeader)) {\n                return false;\n            }\n            const DTCHeader* dtc_hdr = reinterpret_cast<const DTCHeader*>(packet_data + current_packet_read_offset);\n            \n            uint16_t dtc_data_len = dtc_hdr->data_length;\n            \n            if (sizeof(DTCHeader) > std::numeric_limits<size_t>::max() - dtc_data_len) {\n                return false;\n            }\n            size_t entry_total_raw_size = sizeof(DTCHeader) + dtc_data_len;\n\n            if (current_packet_read_offset > packet_length - entry_total_raw_size) {\n                return false;\n            }\n\n            // FIX: Correctly calculate the actual padded size needed for each entry\n            size_t entry_actual_storage_size = (entry_total_raw_size + DTC_ALIGNMENT_BYTES - 1) & ~(DTC_ALIGNMENT_BYTES - 1);\n            \n            // Check for integer overflow before accumulating to total_required_storage_for_batch\n            if (total_required_storage_for_batch > std::numeric_limits<size_t>::max() - entry_actual_storage_size) {\n                return false;\n            }\n            total_required_storage_for_batch += entry_actual_storage_size;\n\n            current_packet_read_offset += entry_total_raw_size;\n        }\n\n        // FIX: Use the correctly calculated 'total_required_storage_for_batch' for buffer sizing.\n        if (m_current_write_offset > std::numeric_limits<size_t>::max() - total_required_storage_for_batch) {\n            return false;\n        }\n        size_t required_total_space = m_current_write_offset + total_required_storage_for_batch;\n        \n        if (required_total_space > m_allocated_capacity) {\n            size_t new_capacity = m_allocated_capacity * 2;\n            if (new_capacity < m_allocated_capacity) { \n                new_capacity = std::numeric_limits<size_t>::max();\n            }\n            if (new_capacity < required_total_space) {\n                new_capacity = required_total_space;\n            }\n            \n            static const size_t MAX_CONSOLIDATED_BUFFER_SIZE = 10 * 1024 * 1024; \n            if (new_capacity > MAX_CONSOLIDATED_BUFFER_SIZE) {\n                if (required_total_space > MAX_CONSOLIDATED_BUFFER_SIZE) {\n                    return false;\n                }\n                new_capacity = MAX_CONSOLIDATED_BUFFER_SIZE;\n            }\n\n            uint8_t* new_buffer = (uint8_t*)realloc(m_consolidated_buffer, new_capacity);\n            if (!new_buffer) {\n                free(m_consolidated_buffer);\n                m_consolidated_buffer = nullptr;\n                m_current_write_offset = 0;\n                m_allocated_capacity = 0;\n                return false;\n            }\n            m_consolidated_buffer = new_buffer;\n            m_allocated_capacity = new_capacity;\n        }\n\n        current_packet_read_offset = sizeof(DTCBatchPacket);\n\n        for (uint16_t i = 0; i < batch_hdr->num_dtc_entries; ++i) {\n            const DTCHeader* dtc_hdr = reinterpret_cast<const DTCHeader*>(packet_data + current_packet_read_offset);\n            uint16_t dtc_data_len = dtc_hdr->data_length;\n\n            size_t entry_total_raw_size = sizeof(DTCHeader) + dtc_data_len;\n            size_t entry_actual_storage_size = (entry_total_raw_size + DTC_ALIGNMENT_BYTES - 1) & ~(DTC_ALIGNMENT_BYTES - 1);\n            \n            // Final check just before writing to ensure we don't exceed buffer bounds\n            if (m_current_write_offset > m_allocated_capacity - entry_actual_storage_size) {\n                return false;\n            }\n\n            // Copy header bytes manually\n            m_consolidated_buffer[m_current_write_offset] = (uint8_t)(dtc_hdr->dtc_id & 0xFF);\n            m_consolidated_buffer[m_current_write_offset + 1] = (uint8_t)((dtc_hdr->dtc_id >> 8) & 0xFF);\n            m_consolidated_buffer[m_current_write_offset + 2] = (uint8_t)(dtc_hdr->data_length & 0xFF);\n            m_consolidated_buffer[m_current_write_offset + 3] = (uint8_t)((dtc_hdr->data_length >> 8) & 0xFF);\n            \n            // Copy data payload bytes manually\n            const uint8_t* payload_src = packet_data + current_packet_read_offset + sizeof(DTCHeader);\n            for (uint16_t j = 0; j < dtc_data_len; ++j) {\n                m_consolidated_buffer[m_current_write_offset + sizeof(DTCHeader) + j] = payload_src[j];\n            }\n\n            // Fill padding bytes with zeros manually\n            size_t bytes_to_pad = entry_actual_storage_size - entry_total_raw_size;\n            if (bytes_to_pad > 0) {\n                for (size_t k = 0; k < bytes_to_pad; ++k) {\n                    m_consolidated_buffer[m_current_write_offset + entry_total_raw_size + k] = 0;\n                }\n            }\n            \n            m_current_write_offset += entry_actual_storage_size;\n            current_packet_read_offset += entry_total_raw_size;\n        }\n\n        if (m_current_write_offset > m_allocated_capacity) {\n            return false;\n        }\n\n        return true;\n    }\n\n    size_t getCurrentBufferSize() const { return m_current_write_offset; }\n    size_t getAllocatedCapacity() const { return m_allocated_capacity; }\n    const uint8_t* getConsolidatedBuffer() const { return m_consolidated_buffer; }\n};\n",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <new>\n\n#pragma pack(push, 1)\nstruct DiagnosticChunkHeaderVulnerable {\n    uint16_t chunk_id;\n    uint16_t chunk_data_length;\n};\n\nstruct DiagnosticPacketHeaderVulnerable {\n    uint32_t packet_sequence_num;\n    uint16_t num_chunks;\n    uint32_t total_expected_chunk_data_bytes;\n};\n#pragma pack(pop)\n\nclass DiagnosticAggregatorVulnerable {\npublic:\n    DiagnosticAggregatorVulnerable() : m_aggregated_data(nullptr), m_allocated_size(0), m_current_write_offset(0) {}\n\n    ~DiagnosticAggregatorVulnerable() {\n        if (m_aggregated_data) {\n            free(m_aggregated_data);\n            m_aggregated_data = nullptr;\n        }\n    }\n\n    bool processDiagnosticPacketVulnerable(const uint8_t* raw_packet_data, size_t packet_len) {\n        if (!raw_packet_data || packet_len < sizeof(DiagnosticPacketHeaderVulnerable)) {\n            return false;\n        }\n\n        const DiagnosticPacketHeaderVulnerable* packet_header = reinterpret_cast<const DiagnosticPacketHeaderVulnerable*>(raw_packet_data);\n\n        if (packet_len < (sizeof(DiagnosticPacketHeaderVulnerable) + packet_header->total_expected_chunk_data_bytes)) {\n            return false;\n        }\n\n        size_t proposed_allocation_size = packet_header->total_expected_chunk_data_bytes;\n        \n        if (m_aggregated_data) {\n            free(m_aggregated_data);\n            m_aggregated_data = nullptr;\n        }\n        m_allocated_size = 0;\n        m_current_write_offset = 0;\n\n        m_aggregated_data = (uint8_t*)malloc(proposed_allocation_size);\n        if (!m_aggregated_data && proposed_allocation_size > 0) {\n            return false;\n        }\n        m_allocated_size = proposed_allocation_size;\n\n        const uint8_t* current_read_ptr = raw_packet_data + sizeof(DiagnosticPacketHeaderVulnerable);\n        size_t remaining_packet_bytes = packet_len - sizeof(DiagnosticPacketHeaderVulnerable);\n\n        for (uint16_t i = 0; i < packet_header->num_chunks; ++i) {\n            if (remaining_packet_bytes < sizeof(DiagnosticChunkHeaderVulnerable)) {\n                if (m_aggregated_data) { free(m_aggregated_data); m_aggregated_data = nullptr; }\n                m_allocated_size = 0;\n                return false;\n            }\n\n            const DiagnosticChunkHeaderVulnerable* chunk_header = reinterpret_cast<const DiagnosticChunkHeaderVulnerable*>(current_read_ptr);\n            uint16_t current_chunk_data_len = chunk_header->chunk_data_length;\n\n            size_t total_chunk_len_in_packet = sizeof(DiagnosticChunkHeaderVulnerable) + current_chunk_data_len;\n\n            if (remaining_packet_bytes < total_chunk_len_in_packet) {\n                if (m_aggregated_data) { free(m_aggregated_data); m_aggregated_data = nullptr; }\n                m_allocated_size = 0;\n                return false;\n            }\n            \n            for (size_t j = 0; j < total_chunk_len_in_packet; ++j) {\n                m_aggregated_data[m_current_write_offset + j] = current_read_ptr[j];\n            }\n            m_current_write_offset += total_chunk_len_in_packet;\n\n            current_read_ptr += total_chunk_len_in_packet;\n            remaining_packet_bytes -= total_chunk_len_in_packet;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getAggregatedData() const {\n        return m_aggregated_data;\n    }\n\n    size_t getAllocatedSize() const {\n        return m_allocated_size;\n    }\n    \n    size_t getCurrentWriteOffset() const {\n        return m_current_write_offset;\n    }\n\nprivate:\n    uint8_t* m_aggregated_data;\n    size_t m_allocated_size;\n    size_t m_current_write_offset;\n};\n",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <new>\n#include <limits>\n\n#pragma pack(push, 1)\nstruct DiagnosticChunkHeaderFixed {\n    uint16_t chunk_id;\n    uint16_t chunk_data_length;\n};\n\nstruct DiagnosticPacketHeaderFixed {\n    uint32_t packet_sequence_num;\n    uint16_t num_chunks;\n    uint32_t total_expected_chunk_data_bytes;\n};\n#pragma pack(pop)\n\nclass DiagnosticAggregatorFixed {\npublic:\n    DiagnosticAggregatorFixed() : m_aggregated_data(nullptr), m_allocated_size(0), m_current_write_offset(0) {}\n\n    ~DiagnosticAggregatorFixed() {\n        if (m_aggregated_data) {\n            free(m_aggregated_data);\n            m_aggregated_data = nullptr;\n        }\n    }\n\n    bool processDiagnosticPacketFixed(const uint8_t* raw_packet_data, size_t packet_len) {\n        if (!raw_packet_data || packet_len < sizeof(DiagnosticPacketHeaderFixed)) {\n            return false;\n        }\n\n        const DiagnosticPacketHeaderFixed* packet_header = reinterpret_cast<const DiagnosticPacketHeaderFixed*>(raw_packet_data);\n\n        size_t total_required_aggregated_size = 0;\n        static const uint32_t MAX_AGGREGATED_DATA_SIZE = 128 * 1024;\n\n        if (packet_header->num_chunks > (std::numeric_limits<size_t>::max() / sizeof(DiagnosticChunkHeaderFixed))) {\n            return false;\n        }\n        total_required_aggregated_size = (size_t)packet_header->num_chunks * sizeof(DiagnosticChunkHeaderFixed);\n\n        if (packet_header->total_expected_chunk_data_bytes > (std::numeric_limits<size_t>::max() - total_required_aggregated_size)) {\n            return false;\n        }\n        total_required_aggregated_size += packet_header->total_expected_chunk_data_bytes;\n\n        if (total_required_aggregated_size > MAX_AGGREGATED_DATA_SIZE) {\n            return false;\n        }\n\n        size_t expected_packet_payload_size = 0;\n        if (packet_header->num_chunks > (std::numeric_limits<size_t>::max() / sizeof(DiagnosticChunkHeaderFixed))) {\n            return false;\n        }\n        expected_packet_payload_size = (size_t)packet_header->num_chunks * sizeof(DiagnosticChunkHeaderFixed);\n        if (packet_header->total_expected_chunk_data_bytes > (std::numeric_limits<size_t>::max() - expected_packet_payload_size)) {\n            return false;\n        }\n        expected_packet_payload_size += packet_header->total_expected_chunk_data_bytes;\n\n        if (packet_len < (sizeof(DiagnosticPacketHeaderFixed) + expected_packet_payload_size)) {\n             return false;\n        }\n\n        if (m_aggregated_data) {\n            free(m_aggregated_data);\n            m_aggregated_data = nullptr;\n        }\n        m_allocated_size = 0;\n        m_current_write_offset = 0;\n        \n        m_aggregated_data = (uint8_t*)malloc(total_required_aggregated_size);\n        if (!m_aggregated_data && total_required_aggregated_size > 0) {\n            return false;\n        }\n        m_allocated_size = total_required_aggregated_size;\n\n        const uint8_t* current_read_ptr = raw_packet_data + sizeof(DiagnosticPacketHeaderFixed);\n        size_t remaining_packet_bytes = packet_len - sizeof(DiagnosticPacketHeaderFixed);\n\n        for (uint16_t i = 0; i < packet_header->num_chunks; ++i) {\n            if (remaining_packet_bytes < sizeof(DiagnosticChunkHeaderFixed)) {\n                if (m_aggregated_data) { free(m_aggregated_data); m_aggregated_data = nullptr; }\n                m_allocated_size = 0;\n                return false;\n            }\n\n            const DiagnosticChunkHeaderFixed* chunk_header = reinterpret_cast<const DiagnosticChunkHeaderFixed*>(current_read_ptr);\n            uint16_t current_chunk_data_len = chunk_header->chunk_data_length;\n\n            size_t total_chunk_len_in_packet = sizeof(DiagnosticChunkHeaderFixed) + current_chunk_data_len;\n\n            if (remaining_packet_bytes < total_chunk_len_in_packet) {\n                if (m_aggregated_data) { free(m_aggregated_data); m_aggregated_data = nullptr; }\n                m_allocated_size = 0;\n                return false;\n            }\n\n            if (m_current_write_offset > (std::numeric_limits<size_t>::max() - total_chunk_len_in_packet) ||\n                m_current_write_offset + total_chunk_len_in_packet > m_allocated_size) {\n                if (m_aggregated_data) { free(m_aggregated_data); m_aggregated_data = nullptr; }\n                m_allocated_size = 0;\n                return false;\n            }\n            \n            for (size_t j = 0; j < total_chunk_len_in_packet; ++j) {\n                m_aggregated_data[m_current_write_offset + j] = current_read_ptr[j];\n            }\n            m_current_write_offset += total_chunk_len_in_packet;\n\n            current_read_ptr += total_chunk_len_in_packet;\n            remaining_packet_bytes -= total_chunk_len_in_packet;\n        }\n        \n        if (m_current_write_offset != m_allocated_size && total_required_aggregated_size > 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getAggregatedData() const {\n        return m_aggregated_data;\n    }\n\n    size_t getAllocatedSize() const {\n        return m_allocated_size;\n    }\n\n    size_t getCurrentWriteOffset() const {\n        return m_current_write_offset;\n    }\n\nprivate:\n    uint8_t* m_aggregated_data;\n    size_t m_allocated_size;\n    size_t m_current_write_offset;\n};",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n\n#pragma pack(push, 1)\nstruct UpdateChunkHeader {\n    uint32_t chunk_id;\n    uint32_t offset;    \n    uint32_t length;    \n    uint32_t crc;\n};\n#pragma pack(pop)\n\nclass ECUFlashUpdaterVulnerable {\npublic:\n    ECUFlashUpdaterVulnerable(size_t staging_buffer_capacity) {\n        if (staging_buffer_capacity > 0) {\n            m_staging_buffer = (uint8_t*)malloc(staging_buffer_capacity);\n            if (m_staging_buffer) {\n                m_capacity = staging_buffer_capacity;\n            } else {\n                m_capacity = 0;\n            }\n        } else {\n            m_capacity = 0;\n            m_staging_buffer = nullptr;\n        }\n    }\n\n    ~ECUFlashUpdaterVulnerable() {\n        if (m_staging_buffer) {\n            free(m_staging_buffer);\n        }\n    }\n\n    bool processUpdateChunkVulnerable(const uint8_t* raw_chunk_packet, size_t packet_len) {\n        if (!m_staging_buffer || !raw_chunk_packet || packet_len < sizeof(UpdateChunkHeader)) {\n            return false;\n        }\n\n        const UpdateChunkHeader* header = reinterpret_cast<const UpdateChunkHeader*>(raw_chunk_packet);\n\n        const uint8_t* chunk_data_payload = raw_chunk_packet + sizeof(UpdateChunkHeader);\n        size_t actual_chunk_data_len = packet_len - sizeof(UpdateChunkHeader);\n\n        if (actual_chunk_data_len != header->length) {\n            return false;\n        }\n\n        uint32_t end_address = header->offset + header->length; \n\n        if (end_address > m_capacity) {\n            return false;\n        }\n\n        uint8_t* dest_ptr = m_staging_buffer + header->offset;\n\n        memcpy(dest_ptr, chunk_data_payload, header->length);\n\n        return true;\n    }\n\n    size_t getCapacity() const { return m_capacity; }\n    const uint8_t* getStagingBuffer() const { return m_staging_buffer; }\n\nprivate:\n    uint8_t* m_staging_buffer;\n    size_t m_capacity;\n}",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <limits>\n\n#pragma pack(push, 1)\nstruct UpdateChunkHeader {\n    uint32_t chunk_id;\n    uint32_t offset;    \n    uint32_t length;    \n    uint32_t crc;\n};\n#pragma pack(pop)\n\nclass ECUFlashUpdaterFixed {\npublic:\n    ECUFlashUpdaterFixed(size_t staging_buffer_capacity) {\n        if (staging_buffer_capacity > 0) {\n            m_staging_buffer = (uint8_t*)malloc(staging_buffer_capacity);\n            if (m_staging_buffer) {\n                m_capacity = staging_buffer_capacity;\n            } else {\n                m_capacity = 0;\n            }\n        } else {\n            m_capacity = 0;\n            m_staging_buffer = nullptr;\n        }\n    }\n\n    ~ECUFlashUpdaterFixed() {\n        if (m_staging_buffer) {\n            free(m_staging_buffer);\n        }\n    }\n\n    bool processUpdateChunkFixed(const uint8_t* raw_chunk_packet, size_t packet_len) {\n        if (!m_staging_buffer || !raw_chunk_packet || packet_len < sizeof(UpdateChunkHeader)) {\n            return false;\n        }\n\n        const UpdateChunkHeader* header = reinterpret_cast<const UpdateChunkHeader*>(raw_chunk_packet);\n\n        const uint8_t* chunk_data_payload = raw_chunk_packet + sizeof(UpdateChunkHeader);\n        size_t actual_chunk_data_len = packet_len - sizeof(UpdateChunkHeader);\n\n        if (actual_chunk_data_len != static_cast<size_t>(header->length)) {\n            return false;\n        }\n\n        size_t start_pos = static_cast<size_t>(header->offset);\n        size_t write_length = static_cast<size_t>(header->length);\n\n        if (start_pos > std::numeric_limits<size_t>::max() - write_length) {\n            return false; \n        }\n\n        size_t end_pos = start_pos + write_length;\n\n        if (end_pos > m_capacity) {\n            return false;\n        }\n\n        uint8_t* dest_ptr = m_staging_buffer + start_pos;\n\n        memcpy(dest_ptr, chunk_data_payload, write_length);\n\n        return true;\n    }\n\n    size_t getCapacity() const { return m_capacity; }\n    const uint8_t* getStagingBuffer() const { return m_staging_buffer; }\n\nprivate:\n    uint8_t* m_staging_buffer;\n    size_t m_capacity;\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <vector>\n#include <numeric>\n#include <algorithm>\n#include <limits> \n\n#pragma pack(push, 1)\nstruct DiagnosticResponseHeader {\n    uint16_t total_payload_length; \n    uint8_t  response_code;\n    uint8_t  num_items;\n};\n\nstruct DiagnosticItemHeader {\n    uint16_t item_id;\n    uint16_t item_data_length; \n};\n#pragma pack(pop)\n\nstruct DiagnosticItem {\n    uint16_t id;\n    std::vector<uint8_t> data;\n};\n\nclass DiagnosticMessageAssemblerVulnerable {\npublic:\n    DiagnosticMessageAssemblerVulnerable() : m_buffer(nullptr), m_buffer_len(0) {}\n\n    ~DiagnosticMessageAssemblerVulnerable() {\n        if (m_buffer) {\n            free(m_buffer);\n        }\n    }\n\n    void addItem(uint16_t id, const uint8_t* data, size_t data_len) {\n        DiagnosticItem item;\n        item.id = id;\n        if (data && data_len > 0) {\n            item.data.assign(data, data + data_len);\n        }\n        m_items.push_back(item);\n    }\n\n    bool assembleMessageVulnerable() {\n        if (m_buffer) {\n            free(m_buffer);\n            m_buffer = nullptr;\n            m_buffer_len = 0;\n        }\n\n        if (m_items.empty()) {\n            return false;\n        }\n\n        size_t items_headers_size = m_items.size() * sizeof(DiagnosticItemHeader);\n        size_t items_data_size = 0;\n\n        for (const auto& item : m_items) {\n            items_data_size += item.data.size();\n        }\n\n        uint16_t total_payload_length_for_header = static_cast<uint16_t>(items_headers_size + items_data_size);\n\n        m_buffer_len = sizeof(DiagnosticResponseHeader) + total_payload_length_for_header;\n        m_buffer = (uint8_t*)malloc(m_buffer_len);\n        if (!m_buffer) {\n            return false;\n        }\n\n        DiagnosticResponseHeader* response_header = reinterpret_cast<DiagnosticResponseHeader*>(m_buffer);\n        response_header->total_payload_length = total_payload_length_for_header;\n        response_header->response_code = 0x01; \n        response_header->num_items = static_cast<uint8_t>(m_items.size()); \n\n        size_t current_offset = sizeof(DiagnosticResponseHeader);\n\n        for (const auto& item : m_items) {\n            if (current_offset + sizeof(DiagnosticItemHeader) > m_buffer_len) {\n                free(m_buffer); m_buffer = nullptr; m_buffer_len = 0;\n                return false;\n            }\n\n            DiagnosticItemHeader* item_header = reinterpret_cast<DiagnosticItemHeader*>(m_buffer + current_offset);\n            item_header->item_id = item.id;\n            item_header->item_data_length = static_cast<uint16_t>(item.data.size()); \n            \n            current_offset += sizeof(DiagnosticItemHeader);\n\n            for (size_t i = 0; i < item.data.size(); ++i) {\n                m_buffer[current_offset + i] = item.data[i];\n            }\n            current_offset += item.data.size();\n        }\n\n        if (current_offset > m_buffer_len) {\n            free(m_buffer); m_buffer = nullptr; m_buffer_len = 0;\n            return false;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getMessageBuffer() const {\n        return m_buffer;\n    }\n\n    size_t getMessageLength() const {\n        return m_buffer_len;\n    }\n\nprivate:\n    std::vector<DiagnosticItem> m_items;\n    uint8_t* m_buffer;\n    size_t m_buffer_len;\n};",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <vector>\n#include <numeric>\n#include <algorithm>\n#include <limits> \n\n#pragma pack(push, 1)\nstruct DiagnosticResponseHeader {\n    uint16_t total_payload_length; \n    uint8_t  response_code;\n    uint8_t  num_items;\n};\n\nstruct DiagnosticItemHeader {\n    uint16_t item_id;\n    uint16_t item_data_length; \n};\n#pragma pack(pop)\n\nstruct DiagnosticItem {\n    uint16_t id;\n    std::vector<uint8_t> data;\n};\n\nclass DiagnosticMessageAssemblerFixed {\npublic:\n    DiagnosticMessageAssemblerFixed() : m_buffer(nullptr), m_buffer_len(0) {}\n\n    ~DiagnosticMessageAssemblerFixed() {\n        if (m_buffer) {\n            free(m_buffer);\n        }\n    }\n\n    void addItem(uint16_t id, const uint8_t* data, size_t data_len) {\n        DiagnosticItem item;\n        item.id = id;\n        if (data && data_len > 0) {\n            item.data.assign(data, data + data_len);\n        }\n        m_items.push_back(item);\n    }\n\n    bool assembleMessageFixed() {\n        if (m_buffer) {\n            free(m_buffer);\n            m_buffer = nullptr;\n            m_buffer_len = 0;\n        }\n\n        if (m_items.empty()) {\n            return false;\n        }\n\n        size_t items_headers_size = m_items.size() * sizeof(DiagnosticItemHeader);\n        size_t items_data_size = 0;\n\n        for (const auto& item : m_items) {\n            if (item.data.size() > std::numeric_limits<uint16_t>::max()) {\n                return false; \n            }\n            if (items_data_size > std::numeric_limits<size_t>::max() - item.data.size()) {\n                return false; \n            }\n            items_data_size += item.data.size();\n        }\n        \n        if (items_headers_size > std::numeric_limits<size_t>::max() - items_data_size) {\n            return false; \n        }\n        size_t actual_total_payload_size = items_headers_size + items_data_size;\n\n        if (actual_total_payload_size > std::numeric_limits<uint16_t>::max()) {\n            return false; \n        }\n        uint16_t total_payload_length_for_header = static_cast<uint16_t>(actual_total_payload_size);\n\n        if (sizeof(DiagnosticResponseHeader) > std::numeric_limits<size_t>::max() - actual_total_payload_size) {\n             return false;\n        }\n        m_buffer_len = sizeof(DiagnosticResponseHeader) + actual_total_payload_size;\n        m_buffer = (uint8_t*)malloc(m_buffer_len);\n        if (!m_buffer) {\n            return false;\n        }\n\n        DiagnosticResponseHeader* response_header = reinterpret_cast<DiagnosticResponseHeader*>(m_buffer);\n        response_header->total_payload_length = total_payload_length_for_header; \n        response_header->response_code = 0x01; \n        \n        if (m_items.size() > std::numeric_limits<uint8_t>::max()) {\n            free(m_buffer); m_buffer = nullptr; m_buffer_len = 0;\n            return false; \n        }\n        response_header->num_items = static_cast<uint8_t>(m_items.size()); \n\n        size_t current_offset = sizeof(DiagnosticResponseHeader);\n\n        for (const auto& item : m_items) {\n            size_t current_item_total_size = sizeof(DiagnosticItemHeader) + item.data.size();\n\n            if (m_buffer_len < current_offset || m_buffer_len - current_offset < current_item_total_size) {\n                free(m_buffer); m_buffer = nullptr; m_buffer_len = 0;\n                return false;\n            }\n\n            DiagnosticItemHeader* item_header = reinterpret_cast<DiagnosticItemHeader*>(m_buffer + current_offset);\n            item_header->item_id = item.id;\n            item_header->item_data_length = static_cast<uint16_t>(item.data.size()); \n            \n            current_offset += sizeof(DiagnosticItemHeader);\n\n            for (size_t i = 0; i < item.data.size(); ++i) {\n                if (current_offset + i >= m_buffer_len) {\n                    free(m_buffer); m_buffer = nullptr; m_buffer_len = 0;\n                    return false; \n                }\n                m_buffer[current_offset + i] = item.data[i]; \n            }\n            current_offset += item.data.size();\n        }\n\n        if (current_offset != m_buffer_len) {\n            free(m_buffer); m_buffer = nullptr; m_buffer_len = 0;\n            return false;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getMessageBuffer() const {\n        return m_buffer;\n    }\n\n    size_t getMessageLength() const {\n        return m_buffer_len;\n    }\n\nprivate:\n    std::vector<DiagnosticItem> m_items;\n    uint8_t* m_buffer;\n    size_t m_buffer_len;\n};",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n\n#pragma pack(push, 1)\nstruct MessageHeader {\n    uint16_t message_type;\n    uint16_t data_length; \n};\n#pragma pack(pop)\n\n#define MAX_MESSAGE_PAYLOAD_DATA_SIZE 256\n#define MESSAGE_SLOT_TOTAL_SIZE (sizeof(MessageHeader) + MAX_MESSAGE_PAYLOAD_DATA_SIZE)\n#define MAX_MESSAGE_POOL_SLOTS 10\n\nclass MessageBufferPoolVulnerable {\npublic:\n    MessageBufferPoolVulnerable() : m_buffer_pool(nullptr) {\n        m_buffer_pool = (uint8_t*)malloc(MAX_MESSAGE_POOL_SLOTS * MESSAGE_SLOT_TOTAL_SIZE);\n        if (m_buffer_pool == nullptr) {\n            // In a real system, robust error handling or throw an exception\n        }\n    }\n\n    ~MessageBufferPoolVulnerable() {\n        if (m_buffer_pool) {\n            free(m_buffer_pool);\n            m_buffer_pool = nullptr;\n        }\n    }\n\n    bool storeMessageVulnerable(uint32_t slot_index, const uint8_t* raw_message_data, size_t raw_data_len) {\n        if (slot_index >= MAX_MESSAGE_POOL_SLOTS) {\n            return false; \n        }\n        if (!raw_message_data || raw_data_len < sizeof(MessageHeader)) {\n            return false; \n        }\n        if (!m_buffer_pool) {\n            return false; \n        }\n\n        const MessageHeader* header = reinterpret_cast<const MessageHeader*>(raw_message_data);\n        uint16_t incoming_payload_len = header->data_length;\n\n        if (raw_data_len < sizeof(MessageHeader) + incoming_payload_len) {\n            return false;\n        }\n\n        uint8_t* target_slot_ptr = m_buffer_pool + (slot_index * MESSAGE_SLOT_TOTAL_SIZE);\n\n        // Copy the MessageHeader into the designated slot\n        for (size_t i = 0; i < sizeof(MessageHeader); ++i) {\n            target_slot_ptr[i] = raw_message_data[i];\n        }\n\n        // VULNERABILITY: The loop copies 'incoming_payload_len' bytes from the source\n        // into the current message slot's payload area. However, there is no check\n        // to ensure that 'incoming_payload_len' does not exceed 'MAX_MESSAGE_PAYLOAD_DATA_SIZE'.\n        // If an attacker provides a 'raw_message_data' where 'header->data_length'\n        // is greater than MAX_MESSAGE_PAYLOAD_DATA_SIZE, this loop will write past the\n        // end of the current message's allocated slot, overflowing into the next slot\n        // in the heap-allocated pool or beyond the pool's boundaries.\n        const uint8_t* source_payload_ptr = raw_message_data + sizeof(MessageHeader);\n        for (uint16_t i = 0; i < incoming_payload_len; ++i) {\n            target_slot_ptr[sizeof(MessageHeader) + i] = source_payload_ptr[i];\n        }\n        \n        return true;\n    }\n\n    const uint8_t* getMessageSlot(uint32_t slot_index) const {\n        if (slot_index >= MAX_MESSAGE_POOL_SLOTS || !m_buffer_pool) {\n            return nullptr;\n        }\n        return m_buffer_pool + (slot_index * MESSAGE_SLOT_TOTAL_SIZE);\n    }\n\nprivate:\n    uint8_t* m_buffer_pool; \n};\n",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n\n#pragma pack(push, 1)\nstruct MessageHeaderFixed {\n    uint16_t message_type;\n    uint16_t data_length;\n};\n#pragma pack(pop)\n\n#define MAX_MESSAGE_PAYLOAD_DATA_SIZE 256\n#define MESSAGE_SLOT_TOTAL_SIZE (sizeof(MessageHeaderFixed) + MAX_MESSAGE_PAYLOAD_DATA_SIZE)\n#define MAX_MESSAGE_POOL_SLOTS 10\n\nclass MessageBufferPoolFixed {\npublic:\n    MessageBufferPoolFixed() : m_buffer_pool(nullptr) {\n        m_buffer_pool = (uint8_t*)malloc(MAX_MESSAGE_POOL_SLOTS * MESSAGE_SLOT_TOTAL_SIZE);\n        if (m_buffer_pool == nullptr) {\n            // In a real system, robust error handling or throw an exception\n        }\n    }\n\n    ~MessageBufferPoolFixed() {\n        if (m_buffer_pool) {\n            free(m_buffer_pool);\n            m_buffer_pool = nullptr;\n        }\n    }\n\n    bool storeMessageFixed(uint32_t slot_index, const uint8_t* raw_message_data, size_t raw_data_len) {\n        if (slot_index >= MAX_MESSAGE_POOL_SLOTS) {\n            return false;\n        }\n        if (!raw_message_data || raw_data_len < sizeof(MessageHeaderFixed)) {\n            return false;\n        }\n        if (!m_buffer_pool) {\n            return false;\n        }\n\n        const MessageHeaderFixed* header = reinterpret_cast<const MessageHeaderFixed*>(raw_message_data);\n        uint16_t incoming_payload_len = header->data_length;\n\n        // FIX: Validate that the incoming payload length does not exceed the maximum\n        // allowed payload size for a single message slot. This prevents writing\n        // past the allocated boundary of the current slot.\n        if (incoming_payload_len > MAX_MESSAGE_PAYLOAD_DATA_SIZE) {\n            return false; // Reject message as its payload is too large for the slot\n        }\n\n        // Ensure raw_data_len provides enough data for the advertised header + payload.\n        // This check is now robust as 'incoming_payload_len' has been validated.\n        if (raw_data_len < sizeof(MessageHeaderFixed) + incoming_payload_len) {\n            return false;\n        }\n\n        uint8_t* target_slot_ptr = m_buffer_pool + (slot_index * MESSAGE_SLOT_TOTAL_SIZE);\n\n        // Copy the MessageHeader (fixed size)\n        for (size_t i = 0; i < sizeof(MessageHeaderFixed); ++i) {\n            target_slot_ptr[i] = raw_message_data[i];\n        }\n\n        // Copy the payload based on the now-validated 'incoming_payload_len'.\n        // Since 'incoming_payload_len' is guaranteed to be <= MAX_MESSAGE_PAYLOAD_DATA_SIZE,\n        // this copy operation will now safely fit within the allocated slot.\n        const uint8_t* source_payload_ptr = raw_message_data + sizeof(MessageHeaderFixed);\n        for (uint16_t i = 0; i < incoming_payload_len; ++i) {\n            target_slot_ptr[sizeof(MessageHeaderFixed) + i] = source_payload_ptr[i];\n        }\n        \n        return true;\n    }\n\n    const uint8_t* getMessageSlot(uint32_t slot_index) const {\n        if (slot_index >= MAX_MESSAGE_POOL_SLOTS || !m_buffer_pool) {\n            return nullptr;\n        }\n        return m_buffer_pool + (slot_index * MESSAGE_SLOT_TOTAL_SIZE);\n    }\n\nprivate:\n    uint8_t* m_buffer_pool;\n};",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <new>\n\n#pragma pack(push, 1)\nstruct DataRecordHeader {\n    uint16_t record_id;\n    uint16_t record_length; \n};\n\nstruct DataBatchHeader {\n    uint32_t batch_id;\n    uint16_t num_records;\n    uint32_t total_batch_payload_size;\n};\n#pragma pack(pop)\n\nclass AutomotiveDataProcessorVulnerable {\npublic:\n    AutomotiveDataProcessorVulnerable()\n        : m_processed_data_buffer(nullptr), m_buffer_capacity(0), m_current_processed_size(0) {}\n\n    ~AutomotiveDataProcessorVulnerable() {\n        if (m_processed_data_buffer) {\n            free(m_processed_data_buffer);\n            m_processed_data_buffer = nullptr;\n        }\n    }\n\n    bool processDataBatchVulnerable(const uint8_t* raw_batch_data, size_t batch_data_len) {\n        if (!raw_batch_data || batch_data_len < sizeof(DataBatchHeader)) {\n            return false;\n        }\n\n        const DataBatchHeader* batch_header = reinterpret_cast<const DataBatchHeader*>(raw_batch_data);\n\n        if (batch_data_len < sizeof(DataBatchHeader) + batch_header->total_batch_payload_size) {\n            return false;\n        }\n\n        if (m_processed_data_buffer) {\n            free(m_processed_data_buffer);\n        }\n        m_processed_data_buffer = (uint8_t*)malloc(batch_header->total_batch_payload_size);\n        if (!m_processed_data_buffer && batch_header->total_batch_payload_size > 0) {\n            m_buffer_capacity = 0;\n            m_current_processed_size = 0;\n            return false;\n        }\n        m_buffer_capacity = batch_header->total_batch_payload_size;\n        m_current_processed_size = 0;\n\n        const uint8_t* current_read_ptr = raw_batch_data + sizeof(DataBatchHeader);\n        size_t remaining_raw_data = batch_data_len - sizeof(DataBatchHeader);\n        \n        uint16_t current_payload_offset = 0; \n\n        for (uint16_t i = 0; i < batch_header->num_records; ++i) {\n            if (remaining_raw_data < sizeof(DataRecordHeader)) {\n                return false;\n            }\n\n            const DataRecordHeader* record_header = reinterpret_cast<const DataRecordHeader*>(current_read_ptr);\n            uint16_t record_len = record_header->record_length;\n\n            size_t total_record_in_raw = sizeof(DataRecordHeader) + record_len;\n\n            if (remaining_raw_data < total_record_in_raw) {\n                return false;\n            }\n            \n            std::memcpy(m_processed_data_buffer + current_payload_offset, \n                        current_read_ptr + sizeof(DataRecordHeader), \n                        record_len);\n            \n            current_payload_offset += record_len; \n\n            current_read_ptr += total_record_in_raw;\n            remaining_raw_data -= total_record_in_raw;\n        }\n        \n        m_current_processed_size = current_payload_offset; \n\n        return true;\n    }\n\n    const uint8_t* getProcessedData() const { return m_processed_data_buffer; }\n    size_t getBufferCapacity() const { return m_buffer_capacity; }\n    size_t getCurrentProcessedSize() const { return m_current_processed_size; }\n\nprivate:\n    uint8_t* m_processed_data_buffer;\n    size_t m_buffer_capacity;\n    size_t m_current_processed_size;\n};",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <new>\n#include <limits>\n\n#pragma pack(push, 1)\nstruct DataRecordHeaderFixed {\n    uint16_t record_id;\n    uint16_t record_length; \n};\n\nstruct DataBatchHeaderFixed {\n    uint32_t batch_id;\n    uint16_t num_records;\n    uint32_t total_batch_payload_size;\n};\n#pragma pack(pop)\n\nclass AutomotiveDataProcessorFixed {\npublic:\n    AutomotiveDataProcessorFixed()\n        : m_processed_data_buffer(nullptr), m_buffer_capacity(0), m_current_processed_size(0) {}\n\n    ~AutomotiveDataProcessorFixed() {\n        if (m_processed_data_buffer) {\n            free(m_processed_data_buffer);\n            m_processed_data_buffer = nullptr;\n        }\n    }\n\n    bool processDataBatchFixed(const uint8_t* raw_batch_data, size_t batch_data_len) {\n        if (!raw_batch_data || batch_data_len < sizeof(DataBatchHeaderFixed)) {\n            return false;\n        }\n\n        const DataBatchHeaderFixed* batch_header = reinterpret_cast<const DataBatchHeaderFixed*>(raw_batch_data);\n\n        if (batch_data_len < sizeof(DataBatchHeaderFixed) + batch_header->total_batch_payload_size) {\n            return false;\n        }\n        \n        const uint32_t MAX_PAYLOAD_SIZE = 16 * 1024 * 1024;\n        if (batch_header->total_batch_payload_size > MAX_PAYLOAD_SIZE) {\n            return false;\n        }\n\n        if (m_processed_data_buffer) {\n            free(m_processed_data_buffer);\n        }\n        m_processed_data_buffer = (uint8_t*)malloc(batch_header->total_batch_payload_size);\n        if (!m_processed_data_buffer && batch_header->total_batch_payload_size > 0) {\n            m_buffer_capacity = 0;\n            m_current_processed_size = 0;\n            return false;\n        }\n        m_buffer_capacity = batch_header->total_batch_payload_size;\n        m_current_processed_size = 0;\n\n        const uint8_t* current_read_ptr = raw_batch_data + sizeof(DataBatchHeaderFixed);\n        size_t remaining_raw_data = batch_data_len - sizeof(DataBatchHeaderFixed);\n        \n        size_t current_payload_offset = 0; \n\n        for (uint16_t i = 0; i < batch_header->num_records; ++i) {\n            if (remaining_raw_data < sizeof(DataRecordHeaderFixed)) {\n                return false;\n            }\n\n            const DataRecordHeaderFixed* record_header = reinterpret_cast<const DataRecordHeaderFixed*>(current_read_ptr);\n            uint16_t record_len = record_header->record_length;\n\n            size_t total_record_in_raw = sizeof(DataRecordHeaderFixed) + record_len;\n\n            if (remaining_raw_data < total_record_in_raw) {\n                return false;\n            }\n\n            if (current_payload_offset > std::numeric_limits<size_t>::max() - record_len || \n                current_payload_offset + record_len > m_buffer_capacity) {\n                return false; \n            }\n            \n            std::memcpy(m_processed_data_buffer + current_payload_offset,\n                        current_read_ptr + sizeof(DataRecordHeaderFixed),\n                        record_len);\n            \n            current_payload_offset += record_len;\n\n            current_read_ptr += total_record_in_raw;\n            remaining_raw_data -= total_record_in_raw;\n        }\n        \n        if (current_payload_offset != batch_header->total_batch_payload_size) {\n            return false;\n        }\n\n        m_current_processed_size = current_payload_offset;\n\n        return true;\n    }\n\n    const uint8_t* getProcessedData() const { return m_processed_data_buffer; }\n    size_t getBufferCapacity() const { return m_buffer_capacity; }\n    size_t getCurrentProcessedSize() const { return m_current_processed_size; }\n\nprivate:\n    uint8_t* m_processed_data_buffer;\n    size_t m_buffer_capacity;\n    size_t m_current_processed_size;\n};",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <new>\n\n#pragma pack(push, 1)\nstruct DataRecorderConfigPacketVulnerable {\n    uint16_t packet_id;\n    uint16_t num_events_to_record;\n    uint16_t max_event_payload_size;\n    uint8_t  reserved[4];\n};\n#pragma pack(pop)\n\nclass AutomotiveDataRecorderVulnerable {\npublic:\n    AutomotiveDataRecorderVulnerable() : m_event_data_buffer(nullptr), m_buffer_capacity_bytes(0) {}\n\n    ~AutomotiveDataRecorderVulnerable() {\n        if (m_event_data_buffer) {\n            free(m_event_data_buffer);\n            m_event_data_buffer = nullptr;\n        }\n    }\n\n    bool configureRecorderVulnerable(const uint8_t* raw_config_packet, size_t packet_len) {\n        if (!raw_config_packet || packet_len < sizeof(DataRecorderConfigPacketVulnerable)) {\n            return false;\n        }\n\n        const DataRecorderConfigPacketVulnerable* config =\n            reinterpret_cast<const DataRecorderConfigPacketVulnerable*>(raw_config_packet);\n\n        uint16_t requested_num_events = config->num_events_to_record;\n        uint16_t requested_payload_size = config->max_event_payload_size;\n\n        if (requested_num_events == 0 || requested_payload_size == 0) {\n            if (m_event_data_buffer) {\n                free(m_event_data_buffer);\n                m_event_data_buffer = nullptr;\n            }\n            m_buffer_capacity_bytes = 0;\n            return true;\n        }\n\n        size_t total_allocation_size = requested_num_events * requested_payload_size;\n        \n        if (m_event_data_buffer) {\n            free(m_event_data_buffer);\n            m_event_data_buffer = nullptr;\n        }\n\n        m_event_data_buffer = (uint8_t*)malloc(total_allocation_size);\n        if (!m_event_data_buffer && total_allocation_size > 0) {\n            m_buffer_capacity_bytes = 0;\n            return false;\n        }\n        m_buffer_capacity_bytes = total_allocation_size;\n\n        for (uint16_t event_idx = 0; event_idx < requested_num_events; ++event_idx) {\n            size_t start_offset_for_event = (size_t)event_idx * requested_payload_size;\n            \n            for (uint16_t byte_idx = 0; byte_idx < requested_payload_size; ++byte_idx) {\n                m_event_data_buffer[start_offset_for_event + byte_idx] = (uint8_t)(event_idx % 256);\n            }\n        }\n        \n        return true;\n    }\n\n    uint8_t* getEventDataBuffer() const { return m_event_data_buffer; }\n    size_t getBufferCapacity() const { return m_buffer_capacity_bytes; }\n\nprivate:\n    uint8_t* m_event_data_buffer;\n    size_t   m_buffer_capacity_bytes;\n};",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <new>\n#include <limits> \n\n#pragma pack(push, 1)\nstruct DataRecorderConfigPacketFixed {\n    uint16_t packet_id;\n    uint16_t num_events_to_record;\n    uint16_t max_event_payload_size;\n    uint8_t  reserved[4];\n};\n#pragma pack(pop)\n\nclass AutomotiveDataRecorderFixed {\npublic:\n    AutomotiveDataRecorderFixed() : m_event_data_buffer(nullptr), m_buffer_capacity_bytes(0) {}\n\n    ~AutomotiveDataRecorderFixed() {\n        if (m_event_data_buffer) {\n            free(m_event_data_buffer);\n            m_event_data_buffer = nullptr;\n        }\n    }\n\n    bool configureRecorderFixed(const uint8_t* raw_config_packet, size_t packet_len) {\n        if (!raw_config_packet || packet_len < sizeof(DataRecorderConfigPacketFixed)) {\n            return false;\n        }\n\n        const DataRecorderConfigPacketFixed* config =\n            reinterpret_cast<const DataRecorderConfigPacketFixed*>(raw_config_packet);\n\n        uint16_t requested_num_events = config->num_events_to_record;\n        uint16_t requested_payload_size = config->max_event_payload_size;\n\n        if (requested_num_events == 0 || requested_payload_size == 0) {\n            if (m_event_data_buffer) {\n                free(m_event_data_buffer);\n                m_event_data_buffer = nullptr;\n            }\n            m_buffer_capacity_bytes = 0;\n            return true;\n        }\n\n        if (requested_payload_size != 0 &&\n            requested_num_events > (std::numeric_limits<size_t>::max() / requested_payload_size)) {\n            return false;\n        }\n        size_t total_allocation_size = (size_t)requested_num_events * requested_payload_size;\n        \n        if (m_event_data_buffer) {\n            free(m_event_data_buffer);\n            m_event_data_buffer = nullptr;\n        }\n\n        m_event_data_buffer = (uint8_t*)malloc(total_allocation_size);\n        if (!m_event_data_buffer && total_allocation_size > 0) {\n            m_buffer_capacity_bytes = 0;\n            return false;\n        }\n        m_buffer_capacity_bytes = total_allocation_size;\n\n        for (uint16_t event_idx = 0; event_idx < requested_num_events; ++event_idx) {\n            size_t start_offset_for_event = (size_t)event_idx * requested_payload_size;\n            \n            if (start_offset_for_event > (m_buffer_capacity_bytes - requested_payload_size)) {\n                return false;\n            }\n\n            for (uint16_t byte_idx = 0; byte_idx < requested_payload_size; ++byte_idx) {\n                m_event_data_buffer[start_offset_for_event + byte_idx] = (uint8_t)(event_idx % 256);\n            }\n        }\n        \n        return true;\n    }\n\n    uint8_t* getEventDataBuffer() const { return m_event_data_buffer; }\n    size_t getBufferCapacity() const { return m_buffer_capacity_bytes; }\n\nprivate:\n    uint8_t* m_event_data_buffer;\n    size_t   m_buffer_capacity_bytes;\n};",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n\n#pragma pack(push, 1)\nstruct LogEntryHeaderVulnerable {\n    uint16_t log_id;\n    uint16_t message_len;\n};\n#pragma pack(pop)\n\n#pragma pack(push, 1)\nstruct LogBatchHeaderVulnerable {\n    uint32_t batch_timestamp;\n    uint16_t num_entries;\n};\n#pragma pack(pop)\n\nclass DiagnosticLogAggregatorVulnerable {\nprivate:\n    uint8_t* m_aggregated_buffer;\n    size_t   m_allocated_capacity;\n    size_t   m_current_fill_size;\n\npublic:\n    DiagnosticLogAggregatorVulnerable() : m_aggregated_buffer(nullptr), m_allocated_capacity(0), m_current_fill_size(0) {}\n\n    ~DiagnosticLogAggregatorVulnerable() {\n        if (m_aggregated_buffer) {\n            free(m_aggregated_buffer);\n        }\n    }\n\n    void reset() {\n        if (m_aggregated_buffer) {\n            free(m_aggregated_buffer);\n            m_aggregated_buffer = nullptr;\n        }\n        m_allocated_capacity = 0;\n        m_current_fill_size = 0;\n    }\n\n    bool processLogBatchVulnerable(const uint8_t* raw_batch_packet, size_t packet_length) {\n        reset();\n\n        if (!raw_batch_packet || packet_length < sizeof(LogBatchHeaderVulnerable)) {\n            return false;\n        }\n\n        const LogBatchHeaderVulnerable* batch_hdr = reinterpret_cast<const LogBatchHeaderVulnerable*>(raw_batch_packet);\n        size_t current_packet_offset = sizeof(LogBatchHeaderVulnerable);\n\n        if (batch_hdr->num_entries == 0) {\n            return true;\n        }\n\n        size_t total_messages_data_length = 0;\n\n        for (uint16_t i = 0; i < batch_hdr->num_entries; ++i) {\n            if (current_packet_offset + sizeof(LogEntryHeaderVulnerable) > packet_length) {\n                return false;\n            }\n\n            const LogEntryHeaderVulnerable* entry_hdr = reinterpret_cast<const LogEntryHeaderVulnerable*>(raw_batch_packet + current_packet_offset);\n            \n            if (current_packet_offset + sizeof(LogEntryHeaderVulnerable) + entry_hdr->message_len > packet_length) {\n                return false;\n            }\n\n            if (total_messages_data_length > (SIZE_MAX - entry_hdr->message_len)) {\n                return false;\n            }\n            total_messages_data_length += entry_hdr->message_len;\n\n            current_packet_offset += sizeof(LogEntryHeaderVulnerable) + entry_hdr->message_len;\n        }\n\n        m_aggregated_buffer = (uint8_t*)malloc(total_messages_data_length);\n        if (!m_aggregated_buffer && total_messages_data_length > 0) {\n            return false;\n        }\n        m_allocated_capacity = total_messages_data_length;\n        m_current_fill_size = 0;\n\n        current_packet_offset = sizeof(LogBatchHeaderVulnerable);\n\n        for (uint16_t i = 0; i < batch_hdr->num_entries; ++i) {\n            const LogEntryHeaderVulnerable* entry_hdr = reinterpret_cast<const LogEntryHeaderVulnerable*>(raw_batch_packet + current_packet_offset);\n            uint16_t entry_total_raw_size = sizeof(LogEntryHeaderVulnerable) + entry_hdr->message_len;\n            \n            for (size_t k = 0; k < entry_total_raw_size; ++k) {\n                m_aggregated_buffer[m_current_fill_size + k] = raw_batch_packet[current_packet_offset + k];\n            }\n            m_current_fill_size += entry_total_raw_size;\n            current_packet_offset += entry_total_raw_size;\n        }\n\n        return true;\n    }\n\n    size_t getAggregatedSize() const { return m_current_fill_size; }\n    const uint8_t* getAggregatedBuffer() const { return m_aggregated_buffer; }\n};\n",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <limits>\n\n#pragma pack(push, 1)\nstruct LogEntryHeaderFixed {\n    uint16_t log_id;\n    uint16_t message_len;\n};\n#pragma pack(pop)\n\n#pragma pack(push, 1)\nstruct LogBatchHeaderFixed {\n    uint32_t batch_timestamp;\n    uint16_t num_entries;\n};\n#pragma pack(pop)\n\nclass DiagnosticLogAggregatorFixed {\nprivate:\n    uint8_t* m_aggregated_buffer;\n    size_t   m_allocated_capacity;\n    size_t   m_current_fill_size;\n\npublic:\n    DiagnosticLogAggregatorFixed() : m_aggregated_buffer(nullptr), m_allocated_capacity(0), m_current_fill_size(0) {}\n\n    ~DiagnosticLogAggregatorFixed() {\n        if (m_aggregated_buffer) {\n            free(m_aggregated_buffer);\n        }\n    }\n\n    void reset() {\n        if (m_aggregated_buffer) {\n            free(m_aggregated_buffer);\n            m_aggregated_buffer = nullptr;\n        }\n        m_allocated_capacity = 0;\n        m_current_fill_size = 0;\n    }\n\n    bool processLogBatchFixed(const uint8_t* raw_batch_packet, size_t packet_length) {\n        reset();\n\n        if (!raw_batch_packet || packet_length < sizeof(LogBatchHeaderFixed)) {\n            return false;\n        }\n\n        const LogBatchHeaderFixed* batch_hdr = reinterpret_cast<const LogBatchHeaderFixed*>(raw_batch_packet);\n        size_t current_packet_offset = sizeof(LogBatchHeaderFixed);\n\n        if (batch_hdr->num_entries == 0) {\n            return true;\n        }\n\n        size_t total_required_buffer_size = 0;\n\n        for (uint16_t i = 0; i < batch_hdr->num_entries; ++i) {\n            if (current_packet_offset > packet_length - sizeof(LogEntryHeaderFixed)) {\n                return false;\n            }\n\n            const LogEntryHeaderFixed* entry_hdr = reinterpret_cast<const LogEntryHeaderFixed*>(raw_batch_packet + current_packet_offset);\n            \n            if (sizeof(LogEntryHeaderFixed) > std::numeric_limits<size_t>::max() - entry_hdr->message_len) {\n                return false;\n            }\n            size_t entry_total_raw_size = sizeof(LogEntryHeaderFixed) + entry_hdr->message_len;\n\n            if (current_packet_offset > packet_length - entry_total_raw_size) {\n                return false;\n            }\n\n            if (total_required_buffer_size > std::numeric_limits<size_t>::max() - entry_total_raw_size) {\n                return false;\n            }\n            total_required_buffer_size += entry_total_raw_size;\n\n            current_packet_offset += entry_total_raw_size;\n        }\n\n        if (current_packet_offset != packet_length) {\n            return false;\n        }\n\n        m_aggregated_buffer = (uint8_t*)malloc(total_required_buffer_size);\n        if (!m_aggregated_buffer && total_required_buffer_size > 0) {\n            return false;\n        }\n        m_allocated_capacity = total_required_buffer_size;\n        m_current_fill_size = 0;\n\n        current_packet_offset = sizeof(LogBatchHeaderFixed);\n\n        for (uint16_t i = 0; i < batch_hdr->num_entries; ++i) {\n            const LogEntryHeaderFixed* entry_hdr = reinterpret_cast<const LogEntryHeaderFixed*>(raw_batch_packet + current_packet_offset);\n            size_t entry_total_raw_size = sizeof(LogEntryHeaderFixed) + entry_hdr->message_len;\n            \n            if (m_current_fill_size > m_allocated_capacity - entry_total_raw_size) {\n                reset();\n                return false;\n            }\n            \n            for (size_t k = 0; k < entry_total_raw_size; ++k) {\n                m_aggregated_buffer[m_current_fill_size + k] = raw_batch_packet[current_packet_offset + k];\n            }\n            m_current_fill_size += entry_total_raw_size;\n            current_packet_offset += entry_total_raw_size;\n        }\n\n        if (m_current_fill_size != m_allocated_capacity) {\n            reset();\n            return false;\n        }\n\n        return true;\n    }\n\n    size_t getAggregatedSize() const { return m_current_fill_size; }\n    const uint8_t* getAggregatedBuffer() const { return m_aggregated_buffer; }\n};\n",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <new>\n#include <vector>\n\n#pragma pack(push, 1)\nstruct ConfigPacketHeader {\n    uint16_t num_config_entries;\n    uint32_t total_payload_bytes;\n};\n\nstruct ConfigEntryHeader {\n    uint16_t entry_id;\n    uint16_t entry_data_len;\n};\n#pragma pack(pop)\n\nclass VehicleConfigServiceVulnerable {\npublic:\n    VehicleConfigServiceVulnerable() : m_config_data_buffer(nullptr), m_allocated_capacity(0) {}\n\n    ~VehicleConfigServiceVulnerable() {\n        if (m_config_data_buffer) {\n            free(m_config_data_buffer);\n        }\n    }\n\n    bool processConfigUpdateVulnerable(const uint8_t* raw_packet, size_t packet_len) {\n        if (!raw_packet || packet_len < sizeof(ConfigPacketHeader)) {\n            return false;\n        }\n\n        const ConfigPacketHeader* packet_header = reinterpret_cast<const ConfigPacketHeader*>(raw_packet);\n\n        if (packet_len < sizeof(ConfigPacketHeader) + packet_header->total_payload_bytes) {\n            return false;\n        }\n\n        if (m_config_data_buffer) {\n            free(m_config_data_buffer);\n            m_config_data_buffer = nullptr;\n        }\n\n        m_config_data_buffer = (uint8_t*)malloc(packet_header->total_payload_bytes);\n        if (!m_config_data_buffer && packet_header->total_payload_bytes > 0) {\n            m_allocated_capacity = 0;\n            return false;\n        }\n        m_allocated_capacity = packet_header->total_payload_bytes;\n\n        const uint8_t* current_read_ptr = raw_packet + sizeof(ConfigPacketHeader);\n        size_t remaining_packet_bytes = packet_len - sizeof(ConfigPacketHeader);\n        size_t current_buffer_write_offset = 0;\n\n        for (uint16_t i = 0; i < packet_header->num_config_entries; ++i) {\n            if (remaining_packet_bytes < sizeof(ConfigEntryHeader)) {\n                return false;\n            }\n\n            const ConfigEntryHeader* entry_header = reinterpret_cast<const ConfigEntryHeader*>(current_read_ptr);\n            uint16_t entry_data_length = entry_header->entry_data_len;\n\n            if (remaining_packet_bytes < sizeof(ConfigEntryHeader) + entry_data_length) {\n                return false;\n            }\n\n            std::memcpy(m_config_data_buffer + current_buffer_write_offset,\n                        current_read_ptr + sizeof(ConfigEntryHeader),\n                        entry_data_length);\n\n            current_buffer_write_offset += entry_data_length;\n\n            current_read_ptr += sizeof(ConfigEntryHeader) + entry_data_length;\n            remaining_packet_bytes -= (sizeof(ConfigEntryHeader) + entry_data_length);\n        }\n\n        if (current_buffer_write_offset > m_allocated_capacity) {\n            free(m_config_data_buffer);\n            m_config_data_buffer = nullptr;\n            m_allocated_capacity = 0;\n            return false;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getConfigDataBuffer() const {\n        return m_config_data_buffer;\n    }\n\n    size_t getAllocatedCapacity() const {\n        return m_allocated_capacity;\n    }\n\nprivate:\n    uint8_t* m_config_data_buffer;\n    size_t   m_allocated_capacity;\n};",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <new>\n#include <vector>\n#include <numeric>\n#include <limits>\n\n#pragma pack(push, 1)\nstruct ConfigPacketHeaderFixed {\n    uint16_t num_config_entries;\n    uint32_t total_payload_bytes;\n};\n\nstruct ConfigEntryHeaderFixed {\n    uint16_t entry_id;\n    uint16_t entry_data_len;\n};\n#pragma pack(pop)\n\nclass VehicleConfigServiceFixed {\npublic:\n    VehicleConfigServiceFixed() : m_config_data_buffer(nullptr), m_allocated_capacity(0) {}\n\n    ~VehicleConfigServiceFixed() {\n        if (m_config_data_buffer) {\n            free(m_config_data_buffer);\n        }\n    }\n\n    bool processConfigUpdateFixed(const uint8_t* raw_packet, size_t packet_len) {\n        if (!raw_packet || packet_len < sizeof(ConfigPacketHeaderFixed)) {\n            return false;\n        }\n\n        const ConfigPacketHeaderFixed* packet_header = reinterpret_cast<const ConfigPacketHeaderFixed*>(raw_packet);\n\n        if (packet_len < sizeof(ConfigPacketHeaderFixed) + packet_header->total_payload_bytes) {\n            return false;\n        }\n\n        size_t calculated_actual_payload_size = 0;\n        const uint8_t* scan_ptr = raw_packet + sizeof(ConfigPacketHeaderFixed);\n        size_t remaining_scan_bytes = packet_len - sizeof(ConfigPacketHeaderFixed);\n\n        for (uint16_t i = 0; i < packet_header->num_config_entries; ++i) {\n            if (remaining_scan_bytes < sizeof(ConfigEntryHeaderFixed)) {\n                return false;\n            }\n\n            const ConfigEntryHeaderFixed* entry_header_scan = reinterpret_cast<const ConfigEntryHeaderFixed*>(scan_ptr);\n            uint16_t entry_data_length = entry_header_scan->entry_data_len;\n\n            if (calculated_actual_payload_size > std::numeric_limits<size_t>::max() - entry_data_length) {\n                return false;\n            }\n            calculated_actual_payload_size += entry_data_length;\n\n            size_t total_entry_size_in_packet = sizeof(ConfigEntryHeaderFixed) + entry_data_length;\n\n            if (remaining_scan_bytes < total_entry_size_in_packet) {\n                return false;\n            }\n            scan_ptr += total_entry_size_in_packet;\n            remaining_scan_bytes -= total_entry_size_in_packet;\n        }\n\n        if (calculated_actual_payload_size != packet_header->total_payload_bytes) {\n            return false;\n        }\n\n        if (m_config_data_buffer) {\n            free(m_config_data_buffer);\n            m_config_data_buffer = nullptr;\n        }\n\n        if (calculated_actual_payload_size > 0) {\n            m_config_data_buffer = (uint8_t*)malloc(calculated_actual_payload_size);\n            if (!m_config_data_buffer) {\n                m_allocated_capacity = 0;\n                return false;\n            }\n        } else {\n            m_config_data_buffer = nullptr;\n        }\n        m_allocated_capacity = calculated_actual_payload_size;\n\n        const uint8_t* current_read_ptr = raw_packet + sizeof(ConfigPacketHeaderFixed);\n        size_t remaining_packet_bytes_for_copy = packet_len - sizeof(ConfigPacketHeaderFixed);\n        size_t current_buffer_write_offset = 0;\n\n        for (uint16_t i = 0; i < packet_header->num_config_entries; ++i) {\n            if (remaining_packet_bytes_for_copy < sizeof(ConfigEntryHeaderFixed)) {\n                return false;\n            }\n\n            const ConfigEntryHeaderFixed* entry_header = reinterpret_cast<const ConfigEntryHeaderFixed*>(current_read_ptr);\n            uint16_t entry_data_length = entry_header->entry_data_len;\n\n            size_t total_entry_size_in_packet = sizeof(ConfigEntryHeaderFixed) + entry_data_length;\n\n            if (remaining_packet_bytes_for_copy < total_entry_size_in_packet) {\n                return false;\n            }\n            \n            if (current_buffer_write_offset > std::numeric_limits<size_t>::max() - entry_data_length ||\n                current_buffer_write_offset + entry_data_length > m_allocated_capacity) {\n                return false;\n            }\n\n            std::memcpy(m_config_data_buffer + current_buffer_write_offset,\n                        current_read_ptr + sizeof(ConfigEntryHeaderFixed),\n                        entry_data_length);\n\n            current_buffer_write_offset += entry_data_length;\n\n            current_read_ptr += total_entry_size_in_packet;\n            remaining_packet_bytes_for_copy -= total_entry_size_in_packet;\n        }\n\n        if (current_buffer_write_offset != m_allocated_capacity) {\n            return false;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getConfigDataBuffer() const {\n        return m_config_data_buffer;\n    }\n\n    size_t getAllocatedCapacity() const {\n        return m_allocated_capacity;\n    }\n\nprivate:\n    uint8_t* m_config_data_buffer;\n    size_t   m_allocated_capacity;\n};",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <new>\n\n#pragma pack(push, 1)\n\nstruct ConfigPacketHeaderVulnerable {\n    uint16_t packet_id;\n    uint16_t num_settings;        \n    uint32_t total_config_data_len; \n};\n\nstruct AppSettingEntryVulnerable {\n    uint16_t setting_id;\n    uint16_t value_len;          \n    uint32_t value_offset_in_packet; \n};\n\n#pragma pack(pop)\n\nclass VehicleAppConfigManagerVulnerable {\npublic:\n    VehicleAppConfigManagerVulnerable() : m_config_buffer(nullptr), m_buffer_capacity(0) {}\n\n    ~VehicleAppConfigManagerVulnerable() {\n        if (m_config_buffer) {\n            free(m_config_buffer);\n        }\n    }\n\n    bool loadConfigVulnerable(const uint8_t* raw_packet, size_t packet_len) {\n        if (!raw_packet || packet_len < sizeof(ConfigPacketHeaderVulnerable)) {\n            return false;\n        }\n\n        const ConfigPacketHeaderVulnerable* header = reinterpret_cast<const ConfigPacketHeaderVulnerable*>(raw_packet);\n\n        if (m_config_buffer) {\n            free(m_config_buffer);\n            m_config_buffer = nullptr;\n            m_buffer_capacity = 0;\n        }\n\n        m_buffer_capacity = header->total_config_data_len;\n        if (m_buffer_capacity == 0 && header->num_settings > 0) {\n            return false;\n        }\n        \n        m_config_buffer = (uint8_t*)malloc(m_buffer_capacity);\n        if (!m_config_buffer && m_buffer_capacity > 0) {\n            return false;\n        }\n        \n        size_t current_buffer_write_offset = 0;\n        size_t current_packet_read_offset = sizeof(ConfigPacketHeaderVulnerable);\n\n        for (uint16_t i = 0; i < header->num_settings; ++i) {\n            if (current_packet_read_offset + sizeof(AppSettingEntryVulnerable) > packet_len) {\n                if (m_config_buffer) { free(m_config_buffer); m_config_buffer = nullptr; }\n                m_buffer_capacity = 0;\n                return false;\n            }\n\n            const AppSettingEntryVulnerable* entry = reinterpret_cast<const AppSettingEntryVulnerable*>(raw_packet + current_packet_read_offset);\n\n            if (entry->value_offset_in_packet == 0 ||\n                entry->value_offset_in_packet + entry->value_len > packet_len) {\n                if (m_config_buffer) { free(m_config_buffer); m_config_buffer = nullptr; }\n                m_buffer_capacity = 0;\n                return false;\n            }\n            \n            const uint8_t* value_source_ptr = raw_packet + entry->value_offset_in_packet;\n            uint16_t value_len = entry->value_len;\n\n            for (uint16_t k = 0; k < value_len; ++k) {\n                m_config_buffer[current_buffer_write_offset + k] = value_source_ptr[k];\n            }\n            current_buffer_write_offset += value_len;\n            \n            current_packet_read_offset += sizeof(AppSettingEntryVulnerable);\n        }\n\n        return true;\n    }\n\n    const uint8_t* getConfigBuffer() const { return m_config_buffer; }\n    size_t getBufferCapacity() const { return m_buffer_capacity; }\n\nprivate:\n    uint8_t* m_config_buffer;\n    size_t m_buffer_capacity;\n};",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <new>\n#include <limits>\n\n#pragma pack(push, 1)\n\nstruct ConfigPacketHeaderFixed {\n    uint16_t packet_id;\n    uint16_t num_settings;\n    uint32_t total_config_data_len;\n};\n\nstruct AppSettingEntryFixed {\n    uint16_t setting_id;\n    uint16_t value_len;\n    uint32_t value_offset_in_packet;\n};\n\n#pragma pack(pop)\n\nclass VehicleAppConfigManagerFixed {\npublic:\n    VehicleAppConfigManagerFixed() : m_config_buffer(nullptr), m_buffer_capacity(0) {}\n\n    ~VehicleAppConfigManagerFixed() {\n        if (m_config_buffer) {\n            free(m_config_buffer);\n        }\n    }\n\n    bool loadConfigFixed(const uint8_t* raw_packet, size_t packet_len) {\n        if (!raw_packet || packet_len < sizeof(ConfigPacketHeaderFixed)) {\n            return false;\n        }\n\n        const ConfigPacketHeaderFixed* header = reinterpret_cast<const ConfigPacketHeaderFixed*>(raw_packet);\n\n        if (m_config_buffer) {\n            free(m_config_buffer);\n            m_config_buffer = nullptr;\n            m_buffer_capacity = 0;\n        }\n\n        size_t calculated_total_data_len = 0;\n        size_t temp_packet_read_offset = sizeof(ConfigPacketHeaderFixed);\n\n        static const uint16_t MAX_ALLOWED_SETTINGS = 500; \n        if (header->num_settings > MAX_ALLOWED_SETTINGS) {\n            return false;\n        }\n\n        for (uint16_t i = 0; i < header->num_settings; ++i) {\n            if (temp_packet_read_offset + sizeof(AppSettingEntryFixed) > packet_len) {\n                return false;\n            }\n\n            const AppSettingEntryFixed* entry = reinterpret_cast<const AppSettingEntryFixed*>(raw_packet + temp_packet_read_offset);\n\n            if (entry->value_offset_in_packet == 0 ||\n                entry->value_offset_in_packet + entry->value_len > packet_len) {\n                return false;\n            }\n            \n            if (entry->value_len > (std::numeric_limits<size_t>::max() - calculated_total_data_len)) {\n                return false;\n            }\n            calculated_total_data_len += entry->value_len;\n            temp_packet_read_offset += sizeof(AppSettingEntryFixed);\n        }\n\n        if (calculated_total_data_len != header->total_config_data_len) {\n            return false;\n        }\n\n        m_buffer_capacity = calculated_total_data_len;\n        \n        if (m_buffer_capacity == 0 && header->num_settings > 0) {\n             return false;\n        }\n\n        if (m_buffer_capacity > 0) {\n            m_config_buffer = (uint8_t*)malloc(m_buffer_capacity);\n            if (!m_config_buffer) {\n                m_buffer_capacity = 0;\n                return false;\n            }\n        } else {\n            m_config_buffer = nullptr;\n        }\n        \n        size_t current_buffer_write_offset = 0;\n        size_t current_packet_read_offset = sizeof(ConfigPacketHeaderFixed);\n\n        for (uint16_t i = 0; i < header->num_settings; ++i) {\n            if (current_packet_read_offset + sizeof(AppSettingEntryFixed) > packet_len) {\n                if (m_config_buffer) { free(m_config_buffer); m_config_buffer = nullptr; }\n                m_buffer_capacity = 0;\n                return false;\n            }\n\n            const AppSettingEntryFixed* entry = reinterpret_cast<const AppSettingEntryFixed*>(raw_packet + current_packet_read_offset);\n            \n            if (entry->value_offset_in_packet == 0 ||\n                entry->value_offset_in_packet + entry->value_len > packet_len) {\n                if (m_config_buffer) { free(m_config_buffer); m_config_buffer = nullptr; }\n                m_buffer_capacity = 0;\n                return false;\n            }\n            \n            const uint8_t* value_source_ptr = raw_packet + entry->value_offset_in_packet;\n            uint16_t value_len = entry->value_len;\n\n            if (current_buffer_write_offset > (std::numeric_limits<size_t>::max() - value_len) ||\n                current_buffer_write_offset + value_len > m_buffer_capacity) {\n                if (m_config_buffer) { free(m_config_buffer); m_config_buffer = nullptr; }\n                m_buffer_capacity = 0;\n                return false;\n            }\n\n            for (uint16_t k = 0; k < value_len; ++k) {\n                m_config_buffer[current_buffer_write_offset + k] = value_source_ptr[k];\n            }\n            current_buffer_write_offset += value_len;\n            \n            current_packet_read_offset += sizeof(AppSettingEntryFixed);\n        }\n        \n        if (current_buffer_write_offset != m_buffer_capacity) {\n            if (m_config_buffer) { free(m_config_buffer); m_config_buffer = nullptr; }\n            m_buffer_capacity = 0;\n            return false;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getConfigBuffer() const { return m_config_buffer; }\n    size_t getBufferCapacity() const { return m_buffer_capacity; }\n\nprivate:\n    uint8_t* m_config_buffer;\n    size_t m_buffer_capacity;\n};",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n\n#pragma pack(push, 1)\nstruct DiagnosticFieldExternal {\n    uint16_t field_id;\n    uint8_t field_type;\n    uint16_t payload_length;\n};\n#pragma pack(pop)\n\nclass DynamicDiagnosticDataStoreVulnerable {\nprivate:\n    uint8_t* m_data_buffer;\n    size_t m_current_size;\n    size_t m_allocated_capacity;\n\npublic:\n    DynamicDiagnosticDataStoreVulnerable() : m_data_buffer(nullptr), m_current_size(0), m_allocated_capacity(0) {}\n\n    ~DynamicDiagnosticDataStoreVulnerable() {\n        if (m_data_buffer) {\n            free(m_data_buffer);\n            m_data_buffer = nullptr;\n        }\n    }\n\n    bool ensureCapacity(size_t required_additional_bytes) {\n        if (required_additional_bytes == 0) {\n            return true;\n        }\n        \n        size_t new_total_size = m_current_size + required_additional_bytes;\n        \n        if (new_total_size < m_current_size) {\n            return false;\n        }\n\n        if (new_total_size > m_allocated_capacity) {\n            size_t realloc_size = new_total_size + 1024;\n            if (realloc_size < new_total_size) {\n                 return false;\n            }\n\n            uint8_t* new_buffer = (uint8_t*)realloc(m_data_buffer, realloc_size);\n            if (!new_buffer) {\n                return false;\n            }\n            m_data_buffer = new_buffer;\n            m_allocated_capacity = realloc_size;\n        }\n        return true;\n    }\n\n    bool appendFieldVulnerable(const uint8_t* raw_field_data, size_t raw_data_len) {\n        if (!raw_field_data || raw_data_len < sizeof(DiagnosticFieldExternal)) {\n            return false;\n        }\n\n        const DiagnosticFieldExternal* field_header = reinterpret_cast<const DiagnosticFieldExternal*>(raw_field_data);\n        uint16_t payload_len = field_header->payload_length;\n\n        if (raw_data_len < (sizeof(DiagnosticFieldExternal) + payload_len)) {\n            return false;\n        }\n\n        if (!ensureCapacity(payload_len)) {\n            return false;\n        }\n\n        size_t bytes_to_copy = sizeof(DiagnosticFieldExternal) + payload_len;\n\n        for (size_t i = 0; i < bytes_to_copy; ++i) {\n            m_data_buffer[m_current_size + i] = raw_field_data[i];\n        }\n\n        m_current_size += bytes_to_copy;\n\n        return true;\n    }\n\n    const uint8_t* getDataBuffer() const { return m_data_buffer; }\n    size_t getCurrentSize() const { return m_current_size; }\n    size_t getAllocatedCapacity() const { return m_allocated_capacity; }\n};",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <limits>\n\n#pragma pack(push, 1)\nstruct DiagnosticFieldExternalFixed {\n    uint16_t field_id;\n    uint8_t field_type;\n    uint16_t payload_length;\n};\n#pragma pack(pop)\n\nclass DynamicDiagnosticDataStoreFixed {\nprivate:\n    uint8_t* m_data_buffer;\n    size_t m_current_size;\n    size_t m_allocated_capacity;\n\npublic:\n    DynamicDiagnosticDataStoreFixed() : m_data_buffer(nullptr), m_current_size(0), m_allocated_capacity(0) {}\n\n    ~DynamicDiagnosticDataStoreFixed() {\n        if (m_data_buffer) {\n            free(m_data_buffer);\n            m_data_buffer = nullptr;\n        }\n    }\n\n    bool ensureCapacity(size_t required_additional_bytes) {\n        if (required_additional_bytes == 0) {\n            return true;\n        }\n        \n        if (m_current_size > (std::numeric_limits<size_t>::max() - required_additional_bytes)) {\n            return false;\n        }\n        size_t new_total_size = m_current_size + required_additional_bytes;\n        \n        if (new_total_size > m_allocated_capacity) {\n            size_t realloc_size;\n            static const size_t BUFFER_PADDING = 1024;\n            if (new_total_size > (std::numeric_limits<size_t>::max() - BUFFER_PADDING)) {\n                realloc_size = std::numeric_limits<size_t>::max();\n            } else {\n                realloc_size = new_total_size + BUFFER_PADDING;\n            }\n\n            uint8_t* new_buffer = (uint8_t*)realloc(m_data_buffer, realloc_size);\n            if (!new_buffer) {\n                return false;\n            }\n            m_data_buffer = new_buffer;\n            m_allocated_capacity = realloc_size;\n        }\n        return true;\n    }\n\n    bool appendFieldFixed(const uint8_t* raw_field_data, size_t raw_data_len) {\n        if (!raw_field_data || raw_data_len < sizeof(DiagnosticFieldExternalFixed)) {\n            return false;\n        }\n\n        const DiagnosticFieldExternalFixed* field_header = reinterpret_cast<const DiagnosticFieldExternalFixed*>(raw_field_data);\n        uint16_t payload_len = field_header->payload_length;\n\n        static const uint16_t MAX_PAYLOAD_LEN = 4000;\n        if (payload_len > MAX_PAYLOAD_LEN) {\n            return false;\n        }\n\n        if (sizeof(DiagnosticFieldExternalFixed) > (std::numeric_limits<size_t>::max() - payload_len)) {\n            return false;\n        }\n        size_t bytes_to_copy = sizeof(DiagnosticFieldExternalFixed) + payload_len;\n\n        if (raw_data_len < bytes_to_copy) {\n            return false;\n        }\n\n        if (!ensureCapacity(bytes_to_copy)) {\n            return false;\n        }\n\n        if (m_current_size > (m_allocated_capacity - bytes_to_copy)) {\n            return false;\n        }\n\n        for (size_t i = 0; i < bytes_to_copy; ++i) {\n            m_data_buffer[m_current_size + i] = raw_field_data[i];\n        }\n\n        m_current_size += bytes_to_copy;\n\n        return true;\n    }\n\n    const uint8_t* getDataBuffer() const { return m_data_buffer; }\n    size_t getCurrentSize() const { return m_current_size; }\n    size_t getAllocatedCapacity() const { return m_allocated_capacity; }\n};",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <new>\n#include <limits>\n\n#pragma pack(push, 1)\n\nstruct MeasurementPacketHeaderVulnerable {\n    uint32_t packet_id;\n    uint32_t total_decoded_samples;\n    uint16_t num_encoded_blocks;\n};\n\nstruct EncodedBlockHeaderVulnerable {\n    uint8_t  encoding_type;\n    uint16_t encoded_data_length;\n};\n\n#pragma pack(pop)\n\nenum EncodingTypeVulnerable : uint8_t {\n    REPEAT_VALUE_VULNERABLE = 0x01,\n    RAW_VALUES_VULNERABLE   = 0x02\n};\n\n#define MAX_DECODED_FLOAT_SAMPLES_VULNERABLE (250 * 1024)\n\nclass SensorDataDecoderVulnerable {\npublic:\n    SensorDataDecoderVulnerable() : m_decoded_samples(nullptr), m_current_sample_count(0), m_allocated_capacity_samples(0) {}\n\n    ~SensorDataDecoderVulnerable() {\n        if (m_decoded_samples) {\n            free(m_decoded_samples);\n        }\n    }\n\n    void resetBuffer() {\n        if (m_decoded_samples) {\n            free(m_decoded_samples);\n            m_decoded_samples = nullptr;\n        }\n        m_current_sample_count = 0;\n        m_allocated_capacity_samples = 0;\n    }\n\n    bool processMeasurementPacketVulnerable(const uint8_t* raw_packet, size_t packet_len) {\n        if (!raw_packet || packet_len < sizeof(MeasurementPacketHeaderVulnerable)) {\n            return false;\n        }\n\n        const MeasurementPacketHeaderVulnerable* packet_header =\n            reinterpret_cast<const MeasurementPacketHeaderVulnerable*>(raw_packet);\n\n        if (packet_header->total_decoded_samples == 0 || \n            packet_header->total_decoded_samples > MAX_DECODED_FLOAT_SAMPLES_VULNERABLE) {\n            return false;\n        }\n        \n        size_t desired_alloc_samples = packet_header->total_decoded_samples;\n        \n        float* new_samples = (float*)realloc(m_decoded_samples, desired_alloc_samples * sizeof(float));\n        if (!new_samples) {\n            resetBuffer();\n            return false;\n        }\n        m_decoded_samples = new_samples;\n        m_allocated_capacity_samples = desired_alloc_samples;\n        m_current_sample_count = 0;\n\n        size_t current_packet_offset = sizeof(MeasurementPacketHeaderVulnerable);\n\n        for (uint16_t i = 0; i < packet_header->num_encoded_blocks; ++i) {\n            if (current_packet_offset + sizeof(EncodedBlockHeaderVulnerable) > packet_len) {\n                resetBuffer();\n                return false;\n            }\n\n            const EncodedBlockHeaderVulnerable* block_header =\n                reinterpret_cast<const EncodedBlockHeaderVulnerable*>(raw_packet + current_packet_offset);\n            \n            if (current_packet_offset + sizeof(EncodedBlockHeaderVulnerable) + block_header->encoded_data_length > packet_len) {\n                resetBuffer();\n                return false;\n            }\n\n            const uint8_t* block_data_ptr = raw_packet + current_packet_offset + sizeof(EncodedBlockHeaderVulnerable);\n            size_t bytes_to_read = block_header->encoded_data_length;\n\n            switch (block_header->encoding_type) {\n                case REPEAT_VALUE_VULNERABLE: {\n                    if (bytes_to_read < sizeof(float) + sizeof(uint16_t)) {\n                        resetBuffer();\n                        return false;\n                    }\n                    float value_to_repeat;\n                    uint16_t repeat_count;\n                    std::memcpy(&value_to_repeat, block_data_ptr, sizeof(float));\n                    std::memcpy(&repeat_count, block_data_ptr + sizeof(float), sizeof(uint16_t));\n                    \n                    for (uint16_t k = 0; k < repeat_count; ++k) {\n                        m_decoded_samples[m_current_sample_count++] = value_to_repeat;\n                    }\n                    break;\n                }\n                case RAW_VALUES_VULNERABLE: {\n                    if (bytes_to_read % sizeof(float) != 0) {\n                        resetBuffer();\n                        return false;\n                    }\n                    size_t num_raw_samples = bytes_to_read / sizeof(float);\n                    \n                    if (m_current_sample_count > m_allocated_capacity_samples - num_raw_samples) {\n                        resetBuffer();\n                        return false;\n                    }\n                    \n                    for (size_t k = 0; k < num_raw_samples; ++k) {\n                        std::memcpy(&m_decoded_samples[m_current_sample_count + k], block_data_ptr + (k * sizeof(float)), sizeof(float));\n                    }\n                    m_current_sample_count += num_raw_samples;\n                    break;\n                }\n                default:\n                    resetBuffer();\n                    return false;\n            }\n            current_packet_offset += sizeof(EncodedBlockHeaderVulnerable) + bytes_to_read;\n        }\n\n        if (m_current_sample_count != packet_header->total_decoded_samples) {\n            resetBuffer(); \n            return false;\n        }\n\n        return true;\n    }\n\n    const float* getDecodedSamples() const { return m_decoded_samples; }\n    size_t getCurrentSampleCount() const { return m_current_sample_count; }\n\nprivate:\n    float* m_decoded_samples;\n    size_t m_current_sample_count;\n    size_t m_allocated_capacity_samples;\n};",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <new>\n#include <limits>\n#include <algorithm>\n\n#pragma pack(push, 1)\n\nstruct MeasurementPacketHeaderFixed {\n    uint32_t packet_id;\n    uint32_t total_decoded_samples;\n    uint16_t num_encoded_blocks;\n};\n\nstruct EncodedBlockHeaderFixed {\n    uint8_t  encoding_type;\n    uint16_t encoded_data_length;\n};\n\n#pragma pack(pop)\n\nenum EncodingTypeFixed : uint8_t {\n    REPEAT_VALUE_FIXED = 0x01,\n    RAW_VALUES_FIXED   = 0x02\n};\n\n#define MAX_DECODED_FLOAT_SAMPLES_FIXED (250 * 1024)\n\nclass SensorDataDecoderFixed {\npublic:\n    SensorDataDecoderFixed() : m_decoded_samples(nullptr), m_current_sample_count(0), m_allocated_capacity_samples(0) {}\n\n    ~SensorDataDecoderFixed() {\n        if (m_decoded_samples) {\n            free(m_decoded_samples);\n        }\n    }\n\n    void resetBuffer() {\n        if (m_decoded_samples) {\n            free(m_decoded_samples);\n            m_decoded_samples = nullptr;\n        }\n        m_current_sample_count = 0;\n        m_allocated_capacity_samples = 0;\n    }\n\n    bool processMeasurementPacketFixed(const uint8_t* raw_packet, size_t packet_len) {\n        if (!raw_packet || packet_len < sizeof(MeasurementPacketHeaderFixed)) {\n            return false;\n        }\n\n        const MeasurementPacketHeaderFixed* packet_header =\n            reinterpret_cast<const MeasurementPacketHeaderFixed*>(raw_packet);\n\n        size_t calculated_total_samples_required = 0;\n        size_t current_packet_offset_for_calc = sizeof(MeasurementPacketHeaderFixed);\n\n        for (uint16_t i = 0; i < packet_header->num_encoded_blocks; ++i) {\n            if (current_packet_offset_for_calc + sizeof(EncodedBlockHeaderFixed) > packet_len) {\n                return false; \n            }\n\n            const EncodedBlockHeaderFixed* block_header_calc =\n                reinterpret_cast<const EncodedBlockHeaderFixed*>(raw_packet + current_packet_offset_for_calc);\n            \n            if (current_packet_offset_for_calc + sizeof(EncodedBlockHeaderFixed) + block_header_calc->encoded_data_length > packet_len) {\n                return false;\n            }\n            \n            size_t samples_for_this_block = 0;\n            switch (block_header_calc->encoding_type) {\n                case REPEAT_VALUE_FIXED: {\n                    if (block_header_calc->encoded_data_length < sizeof(float) + sizeof(uint16_t)) {\n                        return false;\n                    }\n                    uint16_t repeat_count;\n                    std::memcpy(&repeat_count, raw_packet + current_packet_offset_for_calc + sizeof(EncodedBlockHeaderFixed) + sizeof(float), sizeof(uint16_t));\n                    samples_for_this_block = repeat_count;\n                    break;\n                }\n                case RAW_VALUES_FIXED: {\n                    if (block_header_calc->encoded_data_length % sizeof(float) != 0) {\n                        return false;\n                    }\n                    samples_for_this_block = block_header_calc->encoded_data_length / sizeof(float);\n                    break;\n                }\n                default:\n                    return false;\n            }\n\n            if (calculated_total_samples_required > std::numeric_limits<size_t>::max() - samples_for_this_block) {\n                return false;\n            }\n            calculated_total_samples_required += samples_for_this_block;\n\n            current_packet_offset_for_calc += sizeof(EncodedBlockHeaderFixed) + block_header_calc->encoded_data_length;\n        }\n\n        if (packet_header->total_decoded_samples != calculated_total_samples_required) {\n            return false;\n        }\n        \n        if (calculated_total_samples_required == 0 || calculated_total_samples_required > MAX_DECODED_FLOAT_SAMPLES_FIXED) {\n            return false;\n        }\n\n        if (packet_len < current_packet_offset_for_calc) {\n             return false;\n        }\n\n        size_t desired_alloc_samples = calculated_total_samples_required;\n        \n        float* new_samples = (float*)realloc(m_decoded_samples, desired_alloc_samples * sizeof(float));\n        if (!new_samples) {\n            resetBuffer();\n            return false;\n        }\n        m_decoded_samples = new_samples;\n        m_allocated_capacity_samples = desired_alloc_samples;\n        m_current_sample_count = 0;\n\n        size_t current_packet_offset = sizeof(MeasurementPacketHeaderFixed);\n\n        for (uint16_t i = 0; i < packet_header->num_encoded_blocks; ++i) {\n            if (current_packet_offset + sizeof(EncodedBlockHeaderFixed) > packet_len) { resetBuffer(); return false; }\n            const EncodedBlockHeaderFixed* block_header =\n                reinterpret_cast<const EncodedBlockHeaderFixed*>(raw_packet + current_packet_offset);\n            if (current_packet_offset + sizeof(EncodedBlockHeaderFixed) + block_header->encoded_data_length > packet_len) { resetBuffer(); return false; }\n\n            const uint8_t* block_data_ptr = raw_packet + current_packet_offset + sizeof(EncodedBlockHeaderFixed);\n            size_t bytes_to_read = block_header->encoded_data_length;\n\n            switch (block_header->encoding_type) {\n                case REPEAT_VALUE_FIXED: {\n                    if (bytes_to_read < sizeof(float) + sizeof(uint16_t)) {\n                        resetBuffer();\n                        return false;\n                    }\n                    float value_to_repeat;\n                    uint16_t repeat_count;\n                    std::memcpy(&value_to_repeat, block_data_ptr, sizeof(float));\n                    std::memcpy(&repeat_count, block_data_ptr + sizeof(float), sizeof(uint16_t));\n                    \n                    if (m_current_sample_count > m_allocated_capacity_samples - repeat_count) {\n                        resetBuffer();\n                        return false;\n                    }\n\n                    for (uint16_t k = 0; k < repeat_count; ++k) {\n                        m_decoded_samples[m_current_sample_count++] = value_to_repeat;\n                    }\n                    break;\n                }\n                case RAW_VALUES_FIXED: {\n                    if (bytes_to_read % sizeof(float) != 0) {\n                        resetBuffer();\n                        return false;\n                    }\n                    size_t num_raw_samples = bytes_to_read / sizeof(float);\n                    \n                    if (m_current_sample_count > m_allocated_capacity_samples - num_raw_samples) {\n                        resetBuffer();\n                        return false;\n                    }\n                    \n                    for (size_t k = 0; k < num_raw_samples; ++k) {\n                        if ((k * sizeof(float)) > std::numeric_limits<size_t>::max() - sizeof(float) ||\n                            (k * sizeof(float)) + sizeof(float) > bytes_to_read) {\n                            resetBuffer();\n                            return false;\n                        }\n                        std::memcpy(&m_decoded_samples[m_current_sample_count + k], block_data_ptr + (k * sizeof(float)), sizeof(float));\n                    }\n                    m_current_sample_count += num_raw_samples;\n                    break;\n                }\n                default:\n                    resetBuffer();\n                    return false;\n            }\n            current_packet_offset += sizeof(EncodedBlockHeaderFixed) + bytes_to_read;\n        }\n\n        if (m_current_sample_count != calculated_total_samples_required) {\n            resetBuffer(); \n            return false;\n        }\n        if (m_current_sample_count != packet_header->total_decoded_samples) {\n            resetBuffer();\n            return false;\n        }\n\n        return true;\n    }\n\n    const float* getDecodedSamples() const { return m_decoded_samples; }\n    size_t getCurrentSampleCount() const { return m_current_sample_count; }\n\nprivate:\n    float* m_decoded_samples;\n    size_t m_current_sample_count;\n    size_t m_allocated_capacity_samples;\n};",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <vector>\n#include <numeric>\n#include <chrono>\n\n#define MAX_CONSOLIDATED_BUFFER_CAPACITY 1024 * 1024\n\n#pragma pack(push, 1)\n\nstruct RawDataFrameHeader {\n    uint16_t frame_id;\n    uint16_t payload_length;\n};\n\n#pragma pack(pop)\n\nstruct RecorderEntryHeader {\n    uint32_t internal_timestamp_ms;\n    uint16_t frame_id;\n    uint16_t payload_length;\n};\n\nuint32_t get_current_mock_timestamp() {\n    return static_cast<uint32_t>(std::chrono::duration_cast<std::chrono::milliseconds>(\n        std::chrono::system_clock::now().time_since_epoch()\n    ).count());\n}\n\nclass VehicleDataRecorderVulnerable {\npublic:\n    VehicleDataRecorderVulnerable() : m_consolidated_buffer(nullptr), m_current_fill_size(0), m_allocated_capacity(0) {}\n\n    ~VehicleDataRecorderVulnerable() {\n        if (m_consolidated_buffer) {\n            free(m_consolidated_buffer);\n        }\n    }\n\n    bool consolidateDataFramesVulnerable(const uint8_t* raw_packet_data, size_t packet_length) {\n        if (!raw_packet_data || packet_length < sizeof(RawDataFrameHeader)) {\n            return false;\n        }\n\n        if (m_consolidated_buffer) {\n            free(m_consolidated_buffer);\n            m_consolidated_buffer = nullptr;\n        }\n        m_current_fill_size = 0;\n        m_allocated_capacity = 0;\n\n        size_t current_read_offset = 0;\n        size_t total_calculated_size_for_allocation = 0;\n        \n        std::vector<std::pair<RawDataFrameHeader, const uint8_t*>> frames_to_process;\n\n        while (current_read_offset + sizeof(RawDataFrameHeader) <= packet_length) {\n            const RawDataFrameHeader* frame_hdr = reinterpret_cast<const RawDataFrameHeader*>(raw_packet_data + current_read_offset);\n\n            if (current_read_offset + sizeof(RawDataFrameHeader) + frame_hdr->payload_length > packet_length) {\n                return false;\n            }\n            \n            if (total_calculated_size_for_allocation > SIZE_MAX - (sizeof(RawDataFrameHeader) + frame_hdr->payload_length)) {\n                return false;\n            }\n            total_calculated_size_for_allocation += sizeof(RawDataFrameHeader) + frame_hdr->payload_length;\n            \n            frames_to_process.push_back({*frame_hdr, raw_packet_data + current_read_offset + sizeof(RawDataFrameHeader)});\n            current_read_offset += sizeof(RawDataFrameHeader) + frame_hdr->payload_length;\n        }\n\n        if (total_calculated_size_for_allocation > MAX_CONSOLIDATED_BUFFER_CAPACITY) {\n            return false;\n        }\n\n        m_consolidated_buffer = (uint8_t*)malloc(total_calculated_size_for_allocation);\n        if (!m_consolidated_buffer && total_calculated_size_for_allocation > 0) {\n            return false;\n        }\n        m_allocated_capacity = total_calculated_size_for_allocation;\n\n        for (const auto& frame_pair : frames_to_process) {\n            const RawDataFrameHeader& raw_hdr = frame_pair.first;\n            const uint8_t* raw_payload_ptr = frame_pair.second;\n\n            size_t actual_entry_size = sizeof(RecorderEntryHeader) + raw_hdr.payload_length;\n\n            if (m_current_fill_size + actual_entry_size > m_allocated_capacity) {\n                free(m_consolidated_buffer);\n                m_consolidated_buffer = nullptr;\n                m_current_fill_size = 0;\n                m_allocated_capacity = 0;\n                return false;\n            }\n\n            RecorderEntryHeader* recorder_hdr = reinterpret_cast<RecorderEntryHeader*>(m_consolidated_buffer + m_current_fill_size);\n            recorder_hdr->internal_timestamp_ms = get_current_mock_timestamp();\n            recorder_hdr->frame_id = raw_hdr.frame_id;\n            recorder_hdr->payload_length = raw_hdr.payload_length;\n            \n            m_current_fill_size += sizeof(RecorderEntryHeader);\n\n            for (uint16_t i = 0; i < raw_hdr.payload_length; ++i) {\n                m_consolidated_buffer[m_current_fill_size + i] = raw_payload_ptr[i];\n            }\n            m_current_fill_size += raw_hdr.payload_length;\n        }\n\n        return true;\n    }\n\n    size_t getConsolidatedDataSize() const {\n        return m_current_fill_size;\n    }\n\n    const uint8_t* getConsolidatedBuffer() const {\n        return m_consolidated_buffer;\n    }\n\n    size_t getAllocatedCapacity() const {\n        return m_allocated_capacity;\n    }\n\nprivate:\n    uint8_t* m_consolidated_buffer;\n    size_t   m_current_fill_size;\n    size_t   m_allocated_capacity;\n};",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <vector>\n#include <numeric>\n#include <chrono>\n#include <limits>\n\n#define MAX_CONSOLIDATED_BUFFER_CAPACITY 1024 * 1024\n\n#pragma pack(push, 1)\n\nstruct RawDataFrameHeader {\n    uint16_t frame_id;\n    uint16_t payload_length;\n};\n\n#pragma pack(pop)\n\nstruct RecorderEntryHeader {\n    uint32_t internal_timestamp_ms;\n    uint16_t frame_id;\n    uint16_t payload_length;\n};\n\nuint32_t get_current_mock_timestamp() {\n    return static_cast<uint32_t>(std::chrono::duration_cast<std::chrono::milliseconds>(\n        std::chrono::system_clock::now().time_since_epoch()\n    ).count());\n}\n\nclass VehicleDataRecorderFixed {\npublic:\n    VehicleDataRecorderFixed() : m_consolidated_buffer(nullptr), m_current_fill_size(0), m_allocated_capacity(0) {}\n\n    ~VehicleDataRecorderFixed() {\n        if (m_consolidated_buffer) {\n            free(m_consolidated_buffer);\n        }\n    }\n\n    bool consolidateDataFramesFixed(const uint8_t* raw_packet_data, size_t packet_length) {\n        if (!raw_packet_data || packet_length < sizeof(RawDataFrameHeader)) {\n            return false;\n        }\n\n        if (m_consolidated_buffer) {\n            free(m_consolidated_buffer);\n            m_consolidated_buffer = nullptr;\n        }\n        m_current_fill_size = 0;\n        m_allocated_capacity = 0;\n\n        size_t current_read_offset = 0;\n        size_t total_calculated_size_for_allocation = 0;\n        \n        std::vector<std::pair<RawDataFrameHeader, const uint8_t*>> frames_to_process;\n\n        while (current_read_offset + sizeof(RawDataFrameHeader) <= packet_length) {\n            const RawDataFrameHeader* frame_hdr = reinterpret_cast<const RawDataFrameHeader*>(raw_packet_data + current_read_offset);\n\n            if (current_read_offset + sizeof(RawDataFrameHeader) + frame_hdr->payload_length > packet_length) {\n                return false;\n            }\n            \n            size_t size_of_current_entry_in_consolidated_buffer = sizeof(RecorderEntryHeader) + frame_hdr->payload_length;\n\n            if (total_calculated_size_for_allocation > std::numeric_limits<size_t>::max() - size_of_current_entry_in_consolidated_buffer) {\n                return false;\n            }\n            total_calculated_size_for_allocation += size_of_current_entry_in_consolidated_buffer;\n            \n            frames_to_process.push_back({*frame_hdr, raw_packet_data + current_read_offset + sizeof(RawDataFrameHeader)});\n            current_read_offset += sizeof(RawDataFrameHeader) + frame_hdr->payload_length;\n        }\n\n        if (total_calculated_size_for_allocation > MAX_CONSOLIDATED_BUFFER_CAPACITY) {\n            return false;\n        }\n\n        m_consolidated_buffer = (uint8_t*)malloc(total_calculated_size_for_allocation);\n        if (!m_consolidated_buffer && total_calculated_size_for_allocation > 0) {\n            return false;\n        }\n        m_allocated_capacity = total_calculated_size_for_allocation;\n\n        for (const auto& frame_pair : frames_to_process) {\n            const RawDataFrameHeader& raw_hdr = frame_pair.first;\n            const uint8_t* raw_payload_ptr = frame_pair.second;\n\n            size_t actual_entry_size = sizeof(RecorderEntryHeader) + raw_hdr.payload_length;\n\n            if (m_current_fill_size > m_allocated_capacity - actual_entry_size) {\n                free(m_consolidated_buffer);\n                m_consolidated_buffer = nullptr;\n                m_current_fill_size = 0;\n                m_allocated_capacity = 0;\n                return false;\n            }\n\n            RecorderEntryHeader* recorder_hdr = reinterpret_cast<RecorderEntryHeader*>(m_consolidated_buffer + m_current_fill_size);\n            recorder_hdr->internal_timestamp_ms = get_current_mock_timestamp();\n            recorder_hdr->frame_id = raw_hdr.frame_id;\n            recorder_hdr->payload_length = raw_hdr.payload_length;\n            \n            m_current_fill_size += sizeof(RecorderEntryHeader);\n\n            for (uint16_t i = 0; i < raw_hdr.payload_length; ++i) {\n                if (m_current_fill_size + i >= m_allocated_capacity) {\n                    free(m_consolidated_buffer);\n                    m_consolidated_buffer = nullptr;\n                    m_current_fill_size = 0;\n                    m_allocated_capacity = 0;\n                    return false;\n                }\n                m_consolidated_buffer[m_current_fill_size + i] = raw_payload_ptr[i];\n            }\n            m_current_fill_size += raw_hdr.payload_length;\n        }\n\n        return true;\n    }\n\n    size_t getConsolidatedDataSize() const {\n        return m_current_fill_size;\n    }\n\n    const uint8_t* getConsolidatedBuffer() const {\n        return m_consolidated_buffer;\n    }\n\n    size_t getAllocatedCapacity() const {\n        return m_allocated_capacity;\n    }\n\nprivate:\n    uint8_t* m_consolidated_buffer;\n    size_t   m_current_fill_size;\n    size_t   m_allocated_capacity;\n};",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <new>\n#include <limits>\n\n#pragma pack(push, 1)\nstruct StoredDiagnosticEntryVulnerable {\n    uint32_t timestamp;\n    uint16_t item_type;\n    uint16_t item_data_length;\n};\n#pragma pack(pop)\n\n#define DIAG_ENTRY_ALIGNMENT_VULNERABLE 8\n\nclass DiagnosticLogAggregatorVulnerable {\nprivate:\n    uint8_t* m_log_buffer;\n    size_t   m_current_data_size;\n    size_t   m_allocated_capacity;\n\n    bool resizeBuffer(size_t required_capacity) {\n        if (required_capacity <= m_allocated_capacity) {\n            return true;\n        }\n\n        size_t new_capacity = m_allocated_capacity * 2;\n        if (new_capacity < required_capacity) {\n            new_capacity = required_capacity;\n        }\n\n        static const size_t MAX_TOTAL_LOG_SIZE = 10 * 1024 * 1024;\n        if (new_capacity > MAX_TOTAL_LOG_SIZE) {\n            if (required_capacity > MAX_TOTAL_LOG_SIZE) {\n                return false;\n            }\n            new_capacity = MAX_TOTAL_LOG_SIZE;\n        }\n        \n        uint8_t* new_buffer = (uint8_t*)realloc(m_log_buffer, new_capacity);\n        if (!new_buffer) {\n            if (m_log_buffer) {\n                free(m_log_buffer);\n                m_log_buffer = nullptr;\n            }\n            m_current_data_size = 0;\n            m_allocated_capacity = 0;\n            return false;\n        }\n        m_log_buffer = new_buffer;\n        m_allocated_capacity = new_capacity;\n        return true;\n    }\n\npublic:\n    DiagnosticLogAggregatorVulnerable() : m_log_buffer(nullptr), m_current_data_size(0), m_allocated_capacity(0) {\n        m_allocated_capacity = 1024;\n        m_log_buffer = (uint8_t*)malloc(m_allocated_capacity);\n        if (!m_log_buffer) {\n            m_allocated_capacity = 0;\n        }\n    }\n\n    ~DiagnosticLogAggregatorVulnerable() {\n        if (m_log_buffer) {\n            free(m_log_buffer);\n            m_log_buffer = nullptr;\n        }\n    }\n\n    bool addDiagnosticItemVulnerable(uint32_t timestamp, uint16_t item_type, const uint8_t* data_payload, uint16_t data_len) {\n        if (!data_payload && data_len > 0) {\n            return false;\n        }\n\n        size_t base_entry_storage_size = sizeof(StoredDiagnosticEntryVulnerable) + data_len;\n\n        if (m_current_data_size > (std::numeric_limits<size_t>::max() - base_entry_storage_size)) {\n            return false;\n        }\n        size_t required_total_space = m_current_data_size + base_entry_storage_size;\n\n        if (!resizeBuffer(required_total_space)) {\n            return false;\n        }\n        \n        StoredDiagnosticEntryVulnerable entry_header;\n        entry_header.timestamp = timestamp;\n        entry_header.item_type = item_type;\n        entry_header.item_data_length = data_len;\n\n        size_t actual_padded_entry_size = (base_entry_storage_size + DIAG_ENTRY_ALIGNMENT_VULNERABLE - 1) & ~(DIAG_ENTRY_ALIGNMENT_VULNERABLE - 1);\n\n        memcpy(m_log_buffer + m_current_data_size, &entry_header, sizeof(StoredDiagnosticEntryVulnerable));\n        m_current_data_size += sizeof(StoredDiagnosticEntryVulnerable);\n\n        if (data_len > 0) {\n            memcpy(m_log_buffer + m_current_data_size, data_payload, data_len);\n            m_current_data_size += data_len;\n        }\n\n        size_t bytes_to_pad = actual_padded_entry_size - base_entry_storage_size;\n        if (bytes_to_pad > 0) {\n            memset(m_log_buffer + m_current_data_size, 0, bytes_to_pad);\n            m_current_data_size += bytes_to_pad;\n        }\n\n        return true;\n    }\n\n    size_t getCurrentDataSize() const { return m_current_data_size; }\n    size_t getAllocatedCapacity() const { return m_allocated_capacity; }\n    const uint8_t* getLogBuffer() const { return m_log_buffer; }\n};",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <new>\n#include <limits>\n#include <algorithm>\n\n#pragma pack(push, 1)\nstruct StoredDiagnosticEntryFixed {\n    uint32_t timestamp;\n    uint16_t item_type;\n    uint16_t item_data_length;\n};\n#pragma pack(pop)\n\n#define DIAG_ENTRY_ALIGNMENT_FIXED 8\n\nclass DiagnosticLogAggregatorFixed {\nprivate:\n    uint8_t* m_log_buffer;\n    size_t   m_current_data_size;\n    size_t   m_allocated_capacity;\n\n    bool resizeBuffer(size_t required_capacity) {\n        if (required_capacity <= m_allocated_capacity) {\n            return true;\n        }\n\n        size_t new_capacity = m_allocated_capacity * 2;\n        if (m_allocated_capacity > 0 && new_capacity / 2 != m_allocated_capacity) {\n             new_capacity = std::numeric_limits<size_t>::max();\n        }\n\n        if (new_capacity < required_capacity) {\n            new_capacity = required_capacity;\n        }\n\n        static const size_t MAX_TOTAL_LOG_SIZE = 10 * 1024 * 1024;\n        if (new_capacity > MAX_TOTAL_LOG_SIZE) {\n            if (required_capacity > MAX_TOTAL_LOG_SIZE) {\n                return false;\n            }\n            new_capacity = MAX_TOTAL_LOG_SIZE;\n        }\n        \n        uint8_t* new_buffer = (uint8_t*)realloc(m_log_buffer, new_capacity);\n        if (!new_buffer) {\n            if (m_log_buffer) {\n                free(m_log_buffer);\n                m_log_buffer = nullptr;\n            }\n            m_current_data_size = 0;\n            m_allocated_capacity = 0;\n            return false;\n        }\n        m_log_buffer = new_buffer;\n        m_allocated_capacity = new_capacity;\n        return true;\n    }\n\npublic:\n    DiagnosticLogAggregatorFixed() : m_log_buffer(nullptr), m_current_data_size(0), m_allocated_capacity(0) {\n        m_allocated_capacity = 1024;\n        m_log_buffer = (uint8_t*)malloc(m_allocated_capacity);\n        if (!m_log_buffer) {\n            m_allocated_capacity = 0;\n        }\n    }\n\n    ~DiagnosticLogAggregatorFixed() {\n        if (m_log_buffer) {\n            free(m_log_buffer);\n            m_log_buffer = nullptr;\n        }\n    }\n\n    bool addDiagnosticItemFixed(uint32_t timestamp, uint16_t item_type, const uint8_t* data_payload, uint16_t data_len) {\n        if (!data_payload && data_len > 0) {\n            return false;\n        }\n\n        if (data_len > (std::numeric_limits<uint16_t>::max() - sizeof(StoredDiagnosticEntryFixed))) {\n            return false;\n        }\n        size_t base_entry_storage_size = sizeof(StoredDiagnosticEntryFixed) + data_len;\n\n        size_t actual_padded_entry_size;\n        if (base_entry_storage_size > (std::numeric_limits<size_t>::max() - (DIAG_ENTRY_ALIGNMENT_FIXED - 1))) {\n            return false;\n        }\n        actual_padded_entry_size = (base_entry_storage_size + DIAG_ENTRY_ALIGNMENT_FIXED - 1) & ~(DIAG_ENTRY_ALIGNMENT_FIXED - 1);\n        \n        if (base_entry_storage_size > 0 && actual_padded_entry_size == 0) {\n            return false;\n        }\n\n        if (m_current_data_size > (std::numeric_limits<size_t>::max() - actual_padded_entry_size)) {\n            return false;\n        }\n        size_t required_total_space = m_current_data_size + actual_padded_entry_size;\n\n        if (!resizeBuffer(required_total_space)) {\n            return false;\n        }\n        \n        if (m_current_data_size > (m_allocated_capacity - actual_padded_entry_size)) {\n            return false;\n        }\n\n        StoredDiagnosticEntryFixed entry_header;\n        entry_header.timestamp = timestamp;\n        entry_header.item_type = item_type;\n        entry_header.item_data_length = data_len;\n\n        memcpy(m_log_buffer + m_current_data_size, &entry_header, sizeof(StoredDiagnosticEntryFixed));\n        m_current_data_size += sizeof(StoredDiagnosticEntryFixed);\n\n        if (data_len > 0) {\n            memcpy(m_log_buffer + m_current_data_size, data_payload, data_len);\n            m_current_data_size += data_len;\n        }\n\n        size_t bytes_to_pad = actual_padded_entry_size - base_entry_storage_size;\n        if (bytes_to_pad > 0) {\n            if (m_current_data_size > (m_allocated_capacity - bytes_to_pad)) {\n                return false;\n            }\n            memset(m_log_buffer + m_current_data_size, 0, bytes_to_pad);\n            m_current_data_size += bytes_to_pad;\n        }\n        \n        if (m_current_data_size > m_allocated_capacity) {\n            return false;\n        }\n\n        return true;\n    }\n\n    size_t getCurrentDataSize() const { return m_current_data_size; }\n    size_t getAllocatedCapacity() const { return m_allocated_capacity; }\n    const uint8_t* getLogBuffer() const { return m_log_buffer; }\n};",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <limits>\n\n#pragma pack(push, 1)\nstruct EventLogHeader {\n    uint16_t event_id;\n    uint16_t event_data_length;\n    uint32_t timestamp;\n};\n#pragma pack(pop)\n\n#define INITIAL_LOG_BUFFER_SIZE 4096\n#define MAX_LOG_BUFFER_SIZE (512 * 1024)\n\nclass VehicleEventLoggerVulnerable {\npublic:\n    VehicleEventLoggerVulnerable() : m_log_buffer(nullptr), m_current_offset(0), m_allocated_capacity(0) {\n        m_log_buffer = (uint8_t*)malloc(INITIAL_LOG_BUFFER_SIZE);\n        if (m_log_buffer) {\n            m_allocated_capacity = INITIAL_LOG_BUFFER_SIZE;\n        }\n    }\n\n    ~VehicleEventLoggerVulnerable() {\n        if (m_log_buffer) {\n            free(m_log_buffer);\n            m_log_buffer = nullptr;\n        }\n    }\n\n    bool addEventEntryVulnerable(const uint8_t* raw_event_data, size_t raw_event_len) {\n        if (!raw_event_data || raw_event_len < sizeof(EventLogHeader)) {\n            return false;\n        }\n\n        const EventLogHeader* header = reinterpret_cast<const EventLogHeader*>(raw_event_data);\n        uint16_t declared_data_len = header->event_data_length;\n\n        size_t total_entry_size = sizeof(EventLogHeader) + declared_data_len;\n        \n        if (raw_event_len < total_entry_size) {\n            return false;\n        }\n\n        // VULNERABILITY: The 'total_entry_size' is calculated based on 'declared_data_len'.\n        // However, for a specific event ID, the system implicitly adds a fixed-size diagnostic block.\n        // This additional size is NOT accounted for in 'total_entry_size' before reallocation.\n        // Thus, the allocated buffer might be undersized for certain event types.\n        size_t required_capacity = m_current_offset + total_entry_size;\n\n        if (required_capacity > m_allocated_capacity) {\n            size_t new_capacity = m_allocated_capacity * 2;\n            if (new_capacity < required_capacity) {\n                new_capacity = required_capacity;\n            }\n            if (new_capacity > MAX_LOG_BUFFER_SIZE) {\n                if (required_capacity > MAX_LOG_BUFFER_SIZE) {\n                    return false;\n                }\n                new_capacity = MAX_LOG_BUFFER_SIZE;\n            }\n\n            uint8_t* new_buffer = (uint8_t*)realloc(m_log_buffer, new_capacity);\n            if (!new_buffer) {\n                return false;\n            }\n            m_log_buffer = new_buffer;\n            m_allocated_capacity = new_capacity;\n        }\n\n        // Copy header and declared data length payload. This copy is within bounds if total_entry_size is reasonable.\n        memcpy(m_log_buffer + m_current_offset, raw_event_data, total_entry_size);\n\n        // VULNERABILITY: For specific event ID, an additional fixed-size diagnostic block is written.\n        // This write goes beyond the buffer allocated based on 'total_entry_size', leading to a heap overflow.\n        const uint16_t DIAG_EVENT_ID = 0x0ABC;\n        const size_t DIAG_BLOCK_SIZE = 16;\n\n        if (header->event_id == DIAG_EVENT_ID) {\n            // This memset attempts to write DIAG_BLOCK_SIZE bytes starting from\n            // m_current_offset + total_entry_size, which is the boundary of the allocated space.\n            // This causes a heap buffer overflow.\n            memset(m_log_buffer + m_current_offset + total_entry_size, 0xFF, DIAG_BLOCK_SIZE);\n            m_current_offset += DIAG_BLOCK_SIZE; // Incorrectly increments offset, exacerbating potential issues.\n        }\n        \n        m_current_offset += total_entry_size;\n        \n        return true;\n    }\n\n    const uint8_t* getLogBuffer() const { return m_log_buffer; }\n    size_t getCurrentOffset() const { return m_current_offset; }\n    size_t getAllocatedCapacity() const { return m_allocated_capacity; }\n\nprivate:\n    uint8_t* m_log_buffer;\n    size_t m_current_offset;\n    size_t m_allocated_capacity;\n};\n",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <limits>\n\n#pragma pack(push, 1)\nstruct EventLogHeader {\n    uint16_t event_id;\n    uint16_t event_data_length;\n    uint32_t timestamp;\n};\n#pragma pack(pop)\n\n#define INITIAL_LOG_BUFFER_SIZE 4096\n#define MAX_LOG_BUFFER_SIZE (512 * 1024)\n\nclass VehicleEventLoggerFixed {\npublic:\n    VehicleEventLoggerFixed() : m_log_buffer(nullptr), m_current_offset(0), m_allocated_capacity(0) {\n        m_log_buffer = (uint8_t*)malloc(INITIAL_LOG_BUFFER_SIZE);\n        if (m_log_buffer) {\n            m_allocated_capacity = INITIAL_LOG_BUFFER_SIZE;\n        }\n    }\n\n    ~VehicleEventLoggerFixed() {\n        if (m_log_buffer) {\n            free(m_log_buffer);\n            m_log_buffer = nullptr;\n        }\n    }\n\n    bool addEventEntryFixed(const uint8_t* raw_event_data, size_t raw_event_len) {\n        if (!raw_event_data || raw_event_len < sizeof(EventLogHeader)) {\n            return false;\n        }\n\n        const EventLogHeader* header = reinterpret_cast<const EventLogHeader*>(raw_event_data);\n        uint16_t declared_data_len = header->event_data_length;\n\n        if (declared_data_len > (std::numeric_limits<size_t>::max() - sizeof(EventLogHeader))) {\n            return false;\n        }\n        size_t base_entry_size = sizeof(EventLogHeader) + declared_data_len;\n        \n        if (raw_event_len < base_entry_size) {\n            return false;\n        }\n\n        // FIX: Account for the additional diagnostic block size in the total required size\n        const uint16_t DIAG_EVENT_ID = 0x0ABC;\n        const size_t DIAG_BLOCK_SIZE = 16;\n        size_t additional_bytes = 0;\n\n        if (header->event_id == DIAG_EVENT_ID) {\n            additional_bytes = DIAG_BLOCK_SIZE;\n        }\n\n        if (base_entry_size > (std::numeric_limits<size_t>::max() - additional_bytes)) {\n            return false;\n        }\n        size_t total_required_for_entry = base_entry_size + additional_bytes;\n        \n        if (m_current_offset > (MAX_LOG_BUFFER_SIZE - total_required_for_entry)) {\n            return false;\n        }\n\n        size_t required_capacity = m_current_offset + total_required_for_entry;\n\n        if (required_capacity > m_allocated_capacity) {\n            size_t new_capacity = m_allocated_capacity * 2;\n            if (new_capacity == 0) {\n                new_capacity = INITIAL_LOG_BUFFER_SIZE;\n            }\n            if (new_capacity < m_allocated_capacity) {\n                new_capacity = std::numeric_limits<size_t>::max();\n            }\n            if (new_capacity < required_capacity) {\n                new_capacity = required_capacity;\n            }\n            if (new_capacity > MAX_LOG_BUFFER_SIZE) {\n                new_capacity = MAX_LOG_BUFFER_SIZE;\n            }\n            \n            if (required_capacity > new_capacity) {\n                return false;\n            }\n\n            uint8_t* new_buffer = (uint8_t*)realloc(m_log_buffer, new_capacity);\n            if (!new_buffer && new_capacity > 0) {\n                return false;\n            }\n            m_log_buffer = new_buffer;\n            m_allocated_capacity = new_capacity;\n        }\n\n        memcpy(m_log_buffer + m_current_offset, raw_event_data, base_entry_size);\n\n        if (additional_bytes > 0) {\n            // The capacity check earlier (required_capacity > m_allocated_capacity) ensures this is safe\n            // if all calculations are correct, but this defensive check is good.\n            if (m_current_offset + base_entry_size > m_allocated_capacity - additional_bytes) {\n                 return false;\n            }\n            memset(m_log_buffer + m_current_offset + base_entry_size, 0xFF, additional_bytes);\n        }\n        \n        m_current_offset += total_required_for_entry;\n        \n        return true;\n    }\n\n    const uint8_t* getLogBuffer() const { return m_log_buffer; }\n    size_t getCurrentOffset() const { return m_current_offset; }\n    size_t getAllocatedCapacity() const { return m_allocated_capacity; }\n\nprivate:\n    uint8_t* m_log_buffer;\n    size_t m_current_offset;\n    size_t m_allocated_capacity;\n};\n",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <limits>\n\n#define SENSOR_READING_PAYLOAD_SIZE 256 \n\n#pragma pack(push, 1)\nstruct SensorBlockHeaderVulnerable {\n    uint16_t block_id;\n    uint16_t num_readings;\n};\n#pragma pack(pop)\n\nclass VehicleDataRecorderVulnerable {\npublic:\n    VehicleDataRecorderVulnerable() : m_recorded_data(nullptr), m_current_allocated_capacity(0), m_current_filled_size(0) {}\n\n    ~VehicleDataRecorderVulnerable() {\n        if (m_recorded_data) {\n            free(m_recorded_data);\n        }\n    }\n\n    bool recordSensorBlockVulnerable(const uint8_t* raw_block, size_t raw_block_len) {\n        if (!raw_block || raw_block_len < sizeof(SensorBlockHeaderVulnerable)) {\n            return false;\n        }\n\n        const SensorBlockHeaderVulnerable* header = reinterpret_cast<const SensorBlockHeaderVulnerable*>(raw_block);\n\n        uint16_t calculated_payload_len_for_alloc = header->num_readings * SENSOR_READING_PAYLOAD_SIZE; \n\n        size_t block_total_size_with_header = sizeof(SensorBlockHeaderVulnerable) + (size_t)header->num_readings * SENSOR_READING_PAYLOAD_SIZE;\n\n        if (raw_block_len < block_total_size_with_header) {\n            return false;\n        }\n\n        size_t new_required_capacity = m_current_filled_size + sizeof(SensorBlockHeaderVulnerable) + calculated_payload_len_for_alloc;\n\n        uint8_t* temp_buffer = (uint8_t*)realloc(m_recorded_data, new_required_capacity);\n        if (!temp_buffer && new_required_capacity > 0) {\n            return false;\n        }\n        m_recorded_data = temp_buffer;\n        m_current_allocated_capacity = new_required_capacity;\n\n        size_t dest_offset = m_current_filled_size;\n        const uint8_t* source_ptr = raw_block;\n        \n        size_t bytes_to_copy_this_block = block_total_size_with_header;\n\n        for (size_t i = 0; i < bytes_to_copy_this_block; ++i) {\n            m_recorded_data[dest_offset + i] = source_ptr[i]; \n        }\n\n        m_current_filled_size += bytes_to_copy_this_block;\n\n        return true;\n    }\n\n    const uint8_t* getRecordedData() const { return m_recorded_data; }\n    size_t getCurrentRecordedSize() const { return m_current_filled_size; }\n    size_t getAllocatedCapacity() const { return m_current_allocated_capacity; }\n\nprivate:\n    uint8_t* m_recorded_data;\n    size_t   m_current_allocated_capacity;\n    size_t   m_current_filled_size;\n}",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <limits>\n\n#define SENSOR_READING_PAYLOAD_SIZE 256 \n\n#pragma pack(push, 1)\nstruct SensorBlockHeaderFixed {\n    uint16_t block_id;\n    uint16_t num_readings;\n};\n#pragma pack(pop)\n\nclass VehicleDataRecorderFixed {\npublic:\n    VehicleDataRecorderFixed() : m_recorded_data(nullptr), m_current_allocated_capacity(0), m_current_filled_size(0) {}\n\n    ~VehicleDataRecorderFixed() {\n        if (m_recorded_data) {\n            free(m_recorded_data);\n        }\n    }\n\n    bool recordSensorBlockFixed(const uint8_t* raw_block, size_t raw_block_len) {\n        if (!raw_block || raw_block_len < sizeof(SensorBlockHeaderFixed)) {\n            return false;\n        }\n\n        const SensorBlockHeaderFixed* header = reinterpret_cast<const SensorBlockHeaderFixed*>(raw_block);\n\n        if (SENSOR_READING_PAYLOAD_SIZE != 0 && header->num_readings > (std::numeric_limits<size_t>::max() / SENSOR_READING_PAYLOAD_SIZE)) {\n            return false;\n        }\n        size_t calculated_payload_len = (size_t)header->num_readings * SENSOR_READING_PAYLOAD_SIZE;\n\n        if (sizeof(SensorBlockHeaderFixed) > std::numeric_limits<size_t>::max() - calculated_payload_len) {\n            return false;\n        }\n        size_t block_total_size_with_header = sizeof(SensorBlockHeaderFixed) + calculated_payload_len;\n\n        if (raw_block_len < block_total_size_with_header) {\n            return false;\n        }\n\n        if (m_current_filled_size > std::numeric_limits<size_t>::max() - block_total_size_with_header) {\n            return false;\n        }\n        size_t new_required_capacity = m_current_filled_size + block_total_size_with_header;\n\n        if (new_required_capacity == 0 && (header->num_readings > 0 || m_current_filled_size > 0)) {\n            return false;\n        }\n\n        uint8_t* temp_buffer = (uint8_t*)realloc(m_recorded_data, new_required_capacity);\n        if (!temp_buffer && new_required_capacity > 0) {\n            if (m_recorded_data) {\n                free(m_recorded_data);\n                m_recorded_data = nullptr;\n            }\n            m_current_allocated_capacity = 0;\n            m_current_filled_size = 0;\n            return false;\n        }\n        m_recorded_data = temp_buffer;\n        m_current_allocated_capacity = new_required_capacity;\n\n        size_t dest_offset = m_current_filled_size;\n        const uint8_t* source_ptr = raw_block;\n        \n        size_t bytes_to_copy_this_block = block_total_size_with_header;\n\n        if (bytes_to_copy_this_block > m_current_allocated_capacity - dest_offset) {\n            return false;\n        }\n\n        for (size_t i = 0; i < bytes_to_copy_this_block; ++i) {\n            m_recorded_data[dest_offset + i] = source_ptr[i];\n        }\n\n        m_current_filled_size += bytes_to_copy_this_block;\n\n        return true;\n    }\n\n    const uint8_t* getRecordedData() const { return m_recorded_data; }\n    size_t getCurrentRecordedSize() const { return m_current_filled_size; }\n    size_t getAllocatedCapacity() const { return m_current_allocated_capacity; }\n\nprivate:\n    uint8_t* m_recorded_data;\n    size_t   m_current_allocated_capacity;\n    size_t   m_current_filled_size;\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n\n#pragma pack(push, 1)\nstruct TelemetryPacketHeader {\n    uint16_t packet_id;\n    uint16_t payload_len; \n};\n#pragma pack(pop)\n\nclass TelemetryRingBufferVulnerable {\nprivate:\n    uint8_t* m_buffer;\n    size_t   m_capacity;\n    size_t   m_head_write_ptr; \n    size_t   m_total_data_stored; \n\npublic:\n    TelemetryRingBufferVulnerable(size_t capacity) :\n        m_buffer(nullptr), m_capacity(capacity), m_head_write_ptr(0), m_total_data_stored(0) {\n        if (m_capacity > 0) {\n            m_buffer = (uint8_t*)malloc(m_capacity);\n            if (!m_buffer) {\n                m_capacity = 0;\n            }\n        }\n    }\n\n    ~TelemetryRingBufferVulnerable() {\n        if (m_buffer) {\n            free(m_buffer);\n        }\n    }\n\n    bool addPacketVulnerable(const uint8_t* packet_data, size_t data_len) {\n        if (!m_buffer || m_capacity == 0 || !packet_data || data_len < sizeof(TelemetryPacketHeader)) {\n            return false;\n        }\n\n        const TelemetryPacketHeader* header = reinterpret_cast<const TelemetryPacketHeader*>(packet_data);\n        uint16_t declared_payload_len = header->payload_len;\n        size_t total_packet_size = sizeof(TelemetryPacketHeader) + declared_payload_len;\n\n        if (data_len < total_packet_size) {\n            return false;\n        }\n\n        if (total_packet_size > m_capacity) {\n            return false;\n        }\n\n        memcpy(m_buffer + m_head_write_ptr, packet_data, total_packet_size);\n\n        m_head_write_ptr = (m_head_write_ptr + total_packet_size) % m_capacity;\n        if (m_total_data_stored + total_packet_size > m_capacity) {\n            m_total_data_stored = m_capacity;\n        } else {\n            m_total_data_stored += total_packet_size;\n        }\n\n        return true;\n    }\n\n    size_t getCapacity() const { return m_capacity; }\n    size_t getCurrentHead() const { return m_head_write_ptr; }\n    size_t getTotalStored() const { return m_total_data_stored; }\n    const uint8_t* getBuffer() const { return m_buffer; }\n}",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n\n#pragma pack(push, 1)\nstruct TelemetryPacketHeader {\n    uint16_t packet_id;\n    uint16_t payload_len; \n};\n#pragma pack(pop)\n\nclass TelemetryRingBufferFixed {\nprivate:\n    uint8_t* m_buffer;\n    size_t   m_capacity;\n    size_t   m_head_write_ptr; \n    size_t   m_total_data_stored; \n\npublic:\n    TelemetryRingBufferFixed(size_t capacity) :\n        m_buffer(nullptr), m_capacity(capacity), m_head_write_ptr(0), m_total_data_stored(0) {\n        if (m_capacity > 0) {\n            m_buffer = (uint8_t*)malloc(m_capacity);\n            if (!m_buffer) {\n                m_capacity = 0;\n            }\n        }\n    }\n\n    ~TelemetryRingBufferFixed() {\n        if (m_buffer) {\n            free(m_buffer);\n        }\n    }\n\n    bool addPacketFixed(const uint8_t* packet_data, size_t data_len) {\n        if (!m_buffer || m_capacity == 0 || !packet_data || data_len < sizeof(TelemetryPacketHeader)) {\n            return false;\n        }\n\n        const TelemetryPacketHeader* header = reinterpret_cast<const TelemetryPacketHeader*>(packet_data);\n        uint16_t declared_payload_len = header->payload_len;\n        size_t total_packet_size = sizeof(TelemetryPacketHeader) + declared_payload_len;\n\n        if (data_len < total_packet_size) {\n            return false;\n        }\n\n        if (total_packet_size > m_capacity) {\n            return false;\n        }\n        \n        size_t contiguous_space_left = m_capacity - m_head_write_ptr;\n\n        if (total_packet_size <= contiguous_space_left) {\n            memcpy(m_buffer + m_head_write_ptr, packet_data, total_packet_size);\n        } else {\n            size_t bytes_to_end = contiguous_space_left;\n            size_t bytes_from_start = total_packet_size - bytes_to_end;\n\n            memcpy(m_buffer + m_head_write_ptr, packet_data, bytes_to_end);\n            memcpy(m_buffer, packet_data + bytes_to_end, bytes_from_start);\n        }\n\n        m_head_write_ptr = (m_head_write_ptr + total_packet_size) % m_capacity;\n        \n        if (m_total_data_stored + total_packet_size > m_capacity) {\n            m_total_data_stored = m_capacity;\n        } else {\n            m_total_data_stored += total_packet_size;\n        }\n\n        return true;\n    }\n\n    size_t getCapacity() const { return m_capacity; }\n    size_t getCurrentHead() const { return m_head_write_ptr; }\n    size_t getTotalStored() const { return m_total_data_stored; }\n    const uint8_t* getBuffer() const { return m_buffer; }\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <limits>\n\n#pragma pack(push, 1)\nstruct ConfigPacketHeader {\n    uint16_t packet_id;\n    uint16_t num_params;\n    uint32_t declared_total_data_len;\n};\n\nstruct ParameterEntryHeader {\n    uint16_t param_id;\n    uint16_t param_value_len;\n};\n#pragma pack(pop)\n\nclass FirmwareConfigUpdaterVulnerable {\nprivate:\n    uint8_t* m_config_data_buffer;\n    size_t   m_buffer_capacity;\n    size_t   m_current_data_size;\n\npublic:\n    FirmwareConfigUpdaterVulnerable() : m_config_data_buffer(nullptr), m_buffer_capacity(0), m_current_data_size(0) {}\n    ~FirmwareConfigUpdaterVulnerable() {\n        if (m_config_data_buffer) {\n            free(m_config_data_buffer);\n        }\n    }\n\n    bool processConfigPacketVulnerable(const uint8_t* raw_packet, size_t packet_len) {\n        if (!raw_packet || packet_len < sizeof(ConfigPacketHeader)) {\n            return false;\n        }\n\n        const ConfigPacketHeader* header = reinterpret_cast<const ConfigPacketHeader*>(raw_packet);\n        if (header->packet_id != 0xFE01) {\n            return false;\n        }\n\n        if (m_config_data_buffer) {\n            free(m_config_data_buffer);\n            m_config_data_buffer = nullptr;\n        }\n        m_buffer_capacity = 0;\n        m_current_data_size = 0;\n\n        m_buffer_capacity = header->declared_total_data_len;\n        if (m_buffer_capacity > 0) {\n            m_config_data_buffer = (uint8_t*)malloc(m_buffer_capacity);\n            if (!m_config_data_buffer) {\n                m_buffer_capacity = 0;\n                return false;\n            }\n        } else {\n            m_config_data_buffer = nullptr;\n            if (header->num_params > 0) {\n                return false;\n            }\n        }\n\n        size_t current_packet_offset = sizeof(ConfigPacketHeader);\n\n        for (uint16_t i = 0; i < header->num_params; ++i) {\n            if (current_packet_offset > (std::numeric_limits<size_t>::max() - sizeof(ParameterEntryHeader)) ||\n                current_packet_offset + sizeof(ParameterEntryHeader) > packet_len) {\n                if (m_config_data_buffer) free(m_config_data_buffer);\n                m_config_data_buffer = nullptr;\n                m_buffer_capacity = 0;\n                m_current_data_size = 0;\n                return false;\n            }\n            const ParameterEntryHeader* param_entry_header = reinterpret_cast<const ParameterEntryHeader*>(raw_packet + current_packet_offset);\n\n            uint16_t param_value_len = param_entry_header->param_value_len;\n            size_t   param_data_source_offset = current_packet_offset + sizeof(ParameterEntryHeader);\n\n            if (param_data_source_offset > (std::numeric_limits<size_t>::max() - param_value_len) ||\n                param_data_source_offset + param_value_len > packet_len) {\n                if (m_config_data_buffer) free(m_config_data_buffer);\n                m_config_data_buffer = nullptr;\n                m_buffer_capacity = 0;\n                m_current_data_size = 0;\n                return false;\n            }\n\n            for (uint16_t k = 0; k < param_value_len; ++k) {\n                if (m_config_data_buffer) {\n                    m_config_data_buffer[m_current_data_size + k] = raw_packet[param_data_source_offset + k];\n                }\n            }\n            m_current_data_size += param_value_len;\n            \n            current_packet_offset += sizeof(ParameterEntryHeader) + param_value_len;\n        }\n\n        if (m_current_data_size > m_buffer_capacity) {\n            if (m_config_data_buffer) { free(m_config_data_buffer); m_config_data_buffer = nullptr; }\n            m_buffer_capacity = 0;\n            m_current_data_size = 0;\n            return false;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getConfigData() const { return m_config_data_buffer; }\n    size_t getCapacity() const { return m_buffer_capacity; }\n    size_t getCurrentSize() const { return m_current_data_size; }\n};\n",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <limits>\n\n#pragma pack(push, 1)\nstruct ConfigPacketHeader {\n    uint16_t packet_id;\n    uint16_t num_params;\n    uint32_t declared_total_data_len;\n};\n\nstruct ParameterEntryHeader {\n    uint16_t param_id;\n    uint16_t param_value_len;\n};\n#pragma pack(pop)\n\nstatic const uint16_t MAX_NUM_PARAMETERS = 100;\nstatic const uint16_t MAX_PARAM_VALUE_LEN = 1024;\n\nclass FirmwareConfigUpdaterFixed {\nprivate:\n    uint8_t* m_config_data_buffer;\n    size_t   m_buffer_capacity;\n    size_t   m_current_data_size;\n\npublic:\n    FirmwareConfigUpdaterFixed() : m_config_data_buffer(nullptr), m_buffer_capacity(0), m_current_data_size(0) {}\n    ~FirmwareConfigUpdaterFixed() {\n        if (m_config_data_buffer) {\n            free(m_config_data_buffer);\n        }\n    }\n\n    bool processConfigPacketFixed(const uint8_t* raw_packet, size_t packet_len) {\n        if (!raw_packet || packet_len < sizeof(ConfigPacketHeader)) {\n            return false;\n        }\n\n        const ConfigPacketHeader* header = reinterpret_cast<const ConfigPacketHeader*>(raw_packet);\n        if (header->packet_id != 0xFE01) {\n            return false;\n        }\n\n        if (m_config_data_buffer) {\n            free(m_config_data_buffer);\n            m_config_data_buffer = nullptr;\n        }\n        m_buffer_capacity = 0;\n        m_current_data_size = 0;\n\n        size_t calculated_required_data_len = 0;\n        size_t temp_packet_offset = sizeof(ConfigPacketHeader);\n\n        if (header->num_params > MAX_NUM_PARAMETERS) {\n            return false;\n        }\n\n        for (uint16_t i = 0; i < header->num_params; ++i) {\n            if (temp_packet_offset > (std::numeric_limits<size_t>::max() - sizeof(ParameterEntryHeader)) ||\n                temp_packet_offset + sizeof(ParameterEntryHeader) > packet_len) {\n                return false;\n            }\n            const ParameterEntryHeader* param_entry_header = reinterpret_cast<const ParameterEntryHeader*>(raw_packet + temp_packet_offset);\n\n            uint16_t param_value_len = param_entry_header->param_value_len;\n\n            if (param_value_len > MAX_PARAM_VALUE_LEN) {\n                return false;\n            }\n\n            if (calculated_required_data_len > (std::numeric_limits<size_t>::max() - param_value_len)) {\n                return false;\n            }\n            calculated_required_data_len += param_value_len;\n\n            if (temp_packet_offset + sizeof(ParameterEntryHeader) > (std::numeric_limits<size_t>::max() - param_value_len) ||\n                temp_packet_offset + sizeof(ParameterEntryHeader) + param_value_len > packet_len) {\n                return false;\n            }\n            temp_packet_offset += sizeof(ParameterEntryHeader) + param_value_len;\n        }\n\n        if (calculated_required_data_len != header->declared_total_data_len) {\n            return false;\n        }\n\n        if (temp_packet_offset != packet_len) {\n            return false;\n        }\n\n        m_buffer_capacity = calculated_required_data_len;\n        if (m_buffer_capacity > 0) {\n            m_config_data_buffer = (uint8_t*)malloc(m_buffer_capacity);\n            if (!m_config_data_buffer) {\n                m_buffer_capacity = 0;\n                return false;\n            }\n        } else {\n            m_config_data_buffer = nullptr;\n            if (header->num_params > 0) return false;\n        }\n        m_current_data_size = 0;\n\n        size_t current_packet_offset = sizeof(ConfigPacketHeader);\n        for (uint16_t i = 0; i < header->num_params; ++i) {\n            const ParameterEntryHeader* param_entry_header = reinterpret_cast<const ParameterEntryHeader*>(raw_packet + current_packet_offset);\n            uint16_t param_value_len = param_entry_header->param_value_len;\n            size_t   param_data_source_offset = current_packet_offset + sizeof(ParameterEntryHeader);\n\n            if (m_current_data_size > (std::numeric_limits<size_t>::max() - param_value_len) ||\n                m_current_data_size + param_value_len > m_buffer_capacity) {\n                if (m_config_data_buffer) free(m_config_data_buffer);\n                m_config_data_buffer = nullptr;\n                m_buffer_capacity = 0;\n                m_current_data_size = 0;\n                return false;\n            }\n\n            if (param_value_len > 0) {\n                memcpy(m_config_data_buffer + m_current_data_size, raw_packet + param_data_source_offset, param_value_len);\n            }\n            m_current_data_size += param_value_len;\n            current_packet_offset += sizeof(ParameterEntryHeader) + param_value_len;\n        }\n\n        if (m_current_data_size != m_buffer_capacity) {\n            if (m_config_data_buffer) free(m_config_data_buffer);\n            m_config_data_buffer = nullptr;\n            m_buffer_capacity = 0;\n            m_current_data_size = 0;\n            return false;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getConfigData() const { return m_config_data_buffer; }\n    size_t getCapacity() const { return m_buffer_capacity; }\n    size_t getCurrentSize() const { return m_current_data_size; }\n};\n",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <vector>\n#include <numeric>\n#include <algorithm>\n#include <limits>\n\n#pragma pack(push, 1)\n\nstruct LogBatchHeaderVulnerable {\n    uint16_t num_log_entries;\n    uint32_t claimed_total_data_size;\n};\n\nstruct LogEntryMetadataVulnerable {\n    uint32_t timestamp;\n    uint16_t event_id;\n    uint16_t data_length;\n};\n\n#pragma pack(pop)\n\nconst size_t MAX_LOG_BUFFER_CAPACITY_VULNERABLE = 10 * 1024 * 1024;\n\nclass LogBufferManagerVulnerable {\npublic:\n    LogBufferManagerVulnerable() : m_current_write_idx(0) {}\n\n    bool processLogBatchVulnerable(const uint8_t* raw_packet, size_t packet_len) {\n        if (!raw_packet || packet_len < sizeof(LogBatchHeaderVulnerable)) {\n            return false;\n        }\n\n        const LogBatchHeaderVulnerable* batch_header = reinterpret_cast<const LogBatchHeaderVulnerable*>(raw_packet);\n\n        if (batch_header->claimed_total_data_size > (packet_len - sizeof(LogBatchHeaderVulnerable))) {\n            return false;\n        }\n\n        if (batch_header->claimed_total_data_size > MAX_LOG_BUFFER_CAPACITY_VULNERABLE) {\n            return false;\n        }\n\n        m_log_data.clear();\n        m_log_data.resize(batch_header->claimed_total_data_size);\n        m_current_write_idx = 0;\n\n        size_t current_packet_offset = sizeof(LogBatchHeaderVulnerable);\n        \n        for (uint16_t i = 0; i < batch_header->num_log_entries; ++i) {\n            if (current_packet_offset + sizeof(LogEntryMetadataVulnerable) > packet_len) {\n                return false;\n            }\n\n            const LogEntryMetadataVulnerable* entry_meta = reinterpret_cast<const LogEntryMetadataVulnerable*>(raw_packet + current_packet_offset);\n\n            if (current_packet_offset + sizeof(LogEntryMetadataVulnerable) + entry_meta->data_length > packet_len) {\n                return false;\n            }\n            \n            const uint8_t* entry_data_ptr = raw_packet + current_packet_offset + sizeof(LogEntryMetadataVulnerable);\n            for (uint16_t j = 0; j < entry_meta->data_length; ++j) {\n                m_log_data[m_current_write_idx++] = entry_data_ptr[j]; \n            }\n\n            current_packet_offset += sizeof(LogEntryMetadataVulnerable) + entry_meta->data_length;\n        }\n        \n        if (m_current_write_idx != batch_header->claimed_total_data_size) {\n            return false;\n        }\n\n        return true;\n    }\n\n    const std::vector<uint8_t>& getLogData() const {\n        return m_log_data;\n    }\n\nprivate:\n    std::vector<uint8_t> m_log_data;\n    size_t m_current_write_idx;\n};",
    "fixed_code": "#include <cstdint>\n#include <vector>\n#include <numeric>\n#include <algorithm>\n#include <limits>\n\n#pragma pack(push, 1)\n\nstruct LogBatchHeaderFixed {\n    uint16_t num_log_entries;\n    uint32_t claimed_total_data_size;\n};\n\nstruct LogEntryMetadataFixed {\n    uint32_t timestamp;\n    uint16_t event_id;\n    uint16_t data_length;\n};\n\n#pragma pack(pop)\n\nconst size_t MAX_LOG_BUFFER_CAPACITY_FIXED = 10 * 1024 * 1024;\n\nclass LogBufferManagerFixed {\npublic:\n    LogBufferManagerFixed() : m_current_write_idx(0) {}\n\n    bool processLogBatchFixed(const uint8_t* raw_packet, size_t packet_len) {\n        if (!raw_packet || packet_len < sizeof(LogBatchHeaderFixed)) {\n            return false;\n        }\n\n        const LogBatchHeaderFixed* batch_header = reinterpret_cast<const LogBatchHeaderFixed*>(raw_packet);\n\n        size_t current_packet_offset = sizeof(LogBatchHeaderFixed);\n        uint32_t calculated_actual_total_data_size = 0;\n\n        for (uint16_t i = 0; i < batch_header->num_log_entries; ++i) {\n            if (current_packet_offset > packet_len - sizeof(LogEntryMetadataFixed)) {\n                return false;\n            }\n\n            const LogEntryMetadataFixed* entry_meta = reinterpret_cast<const LogEntryMetadataFixed*>(raw_packet + current_packet_offset);\n\n            if (entry_meta->data_length > (std::numeric_limits<uint32_t>::max() - calculated_actual_total_data_size)) {\n                return false;\n            }\n            calculated_actual_total_data_size += entry_meta->data_length;\n\n            if (current_packet_offset > packet_len - (sizeof(LogEntryMetadataFixed) + entry_meta->data_length)) {\n                return false;\n            }\n\n            current_packet_offset += sizeof(LogEntryMetadataFixed) + entry_meta->data_length;\n        }\n\n        if (calculated_actual_total_data_size != batch_header->claimed_total_data_size) {\n            return false;\n        }\n        if (calculated_actual_total_data_size > MAX_LOG_BUFFER_CAPACITY_FIXED) {\n            return false;\n        }\n        \n        if (current_packet_offset != packet_len) {\n            return false;\n        }\n\n        m_log_data.clear();\n        m_log_data.resize(calculated_actual_total_data_size);\n\n        m_current_write_idx = 0;\n\n        current_packet_offset = sizeof(LogBatchHeaderFixed);\n\n        for (uint16_t i = 0; i < batch_header->num_log_entries; ++i) {\n            const LogEntryMetadataFixed* entry_meta = reinterpret_cast<const LogEntryMetadataFixed*>(raw_packet + current_packet_offset);\n            \n            const uint8_t* entry_data_ptr = raw_packet + current_packet_offset + sizeof(LogEntryMetadataFixed);\n            \n            if (m_current_write_idx > m_log_data.size() - entry_meta->data_length) {\n                return false;\n            }\n\n            for (uint16_t j = 0; j < entry_meta->data_length; ++j) {\n                m_log_data[m_current_write_idx++] = entry_data_ptr[j];\n            }\n            \n            current_packet_offset += sizeof(LogEntryMetadataFixed) + entry_meta->data_length;\n        }\n\n        if (m_current_write_idx != calculated_actual_total_data_size) {\n            return false;\n        }\n\n        return true;\n    }\n\n    const std::vector<uint8_t>& getLogData() const {\n        return m_log_data;\n    }\n\nprivate:\n    std::vector<uint8_t> m_log_data;\n    size_t m_current_write_idx;\n};",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <new>\n\n#pragma pack(push, 1)\nstruct ConfigSegmentPacket {\n    uint32_t segment_id;\n    uint32_t offset;\n    uint32_t length;\n};\n#pragma pack(pop)\n\nclass ConfigBufferManagerVulnerable {\npublic:\n    ConfigBufferManagerVulnerable() : m_buffer(nullptr), m_current_capacity(0), m_highest_offset_reached(0) {}\n\n    ~ConfigBufferManagerVulnerable() {\n        if (m_buffer) {\n            free(m_buffer);\n        }\n    }\n\n    bool processConfigSegmentVulnerable(const uint8_t* raw_packet, size_t packet_len) {\n        if (!raw_packet || packet_len < sizeof(ConfigSegmentPacket)) {\n            return false;\n        }\n\n        const ConfigSegmentPacket* header = reinterpret_cast<const ConfigSegmentPacket*>(raw_packet);\n        const uint8_t* segment_data = raw_packet + sizeof(ConfigSegmentPacket);\n        size_t actual_data_len = packet_len - sizeof(ConfigSegmentPacket);\n\n        if (header->length != actual_data_len) {\n            return false;\n        }\n\n        uint32_t required_end_address_u32 = header->offset + header->length;\n        size_t required_end_address = required_end_address_u32;\n\n        if (required_end_address > m_highest_offset_reached) {\n            m_highest_offset_reached = required_end_address;\n        }\n\n        if (m_highest_offset_reached > m_current_capacity) {\n            uint8_t* new_buffer = (uint8_t*)realloc(m_buffer, m_highest_offset_reached);\n            if (!new_buffer && m_highest_offset_reached > 0) {\n                return false;\n            }\n            m_buffer = new_buffer;\n            m_current_capacity = m_highest_offset_reached;\n        }\n\n        memcpy(m_buffer + header->offset, segment_data, header->length);\n\n        return true;\n    }\n\n    size_t getCurrentCapacity() const {\n        return m_current_capacity;\n    }\n\n    size_t getHighestOffsetReached() const {\n        return m_highest_offset_reached;\n    }\n\nprivate:\n    uint8_t* m_buffer;\n    size_t m_current_capacity;\n    size_t m_highest_offset_reached;\n}",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <new>\n#include <limits>\n\n#pragma pack(push, 1)\nstruct ConfigSegmentPacketFixed {\n    uint32_t segment_id;\n    uint32_t offset;\n    uint32_t length;\n};\n#pragma pack(pop)\n\nclass ConfigBufferManagerFixed {\npublic:\n    ConfigBufferManagerFixed() : m_buffer(nullptr), m_current_capacity(0), m_highest_offset_reached(0) {}\n\n    ~ConfigBufferManagerFixed() {\n        if (m_buffer) {\n            free(m_buffer);\n        }\n    }\n\n    bool processConfigSegmentFixed(const uint8_t* raw_packet, size_t packet_len) {\n        if (!raw_packet || packet_len < sizeof(ConfigSegmentPacketFixed)) {\n            return false;\n        }\n\n        const ConfigSegmentPacketFixed* header = reinterpret_cast<const ConfigSegmentPacketFixed*>(raw_packet);\n        const uint8_t* segment_data = raw_packet + sizeof(ConfigSegmentPacketFixed);\n        size_t actual_data_len = packet_len - sizeof(ConfigSegmentPacketFixed);\n\n        if (header->length != actual_data_len) {\n            return false;\n        }\n\n        size_t segment_offset = static_cast<size_t>(header->offset);\n        size_t segment_length = static_cast<size_t>(header->length);\n\n        if (segment_offset > std::numeric_limits<size_t>::max() - segment_length) {\n            return false;\n        }\n        size_t required_end_address = segment_offset + segment_length;\n\n        if (segment_length > actual_data_len) {\n             return false;\n        }\n\n        if (required_end_address > m_highest_offset_reached) {\n            m_highest_offset_reached = required_end_address;\n        }\n\n        if (m_highest_offset_reached > m_current_capacity) {\n            uint8_t* new_buffer = (uint8_t*)realloc(m_buffer, m_highest_offset_reached);\n            if (!new_buffer && m_highest_offset_reached > 0) {\n                return false;\n            } else if (new_buffer == nullptr && m_highest_offset_reached == 0) {\n                m_buffer = nullptr;\n            } else {\n                m_buffer = new_buffer;\n            }\n            m_current_capacity = m_highest_offset_reached;\n        }\n\n        if (segment_offset > m_current_capacity || (segment_offset + segment_length) > m_current_capacity) {\n            return false;\n        }\n\n        memcpy(m_buffer + segment_offset, segment_data, segment_length);\n\n        return true;\n    }\n\n    size_t getCurrentCapacity() const {\n        return m_current_capacity;\n    }\n\n    size_t getHighestOffsetReached() const {\n        return m_highest_offset_reached;\n    }\n\nprivate:\n    uint8_t* m_buffer;\n    size_t m_current_capacity;\n    size_t m_highest_offset_reached;\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n\n#pragma pack(push, 1)\nstruct VehicleCommandHeaderVulnerable {\n    uint16_t command_id;\n    uint16_t payload_length;\n};\n#pragma pack(pop)\n\nconst uint16_t DIAGNOSTIC_COMMAND_ID = 0x00A5;\nconst size_t DIAGNOSTIC_FOOTER_SIZE = 16;\n\nclass CommandProcessorVulnerable {\npublic:\n    CommandProcessorVulnerable() : m_command_data_buffer(nullptr), m_allocated_payload_size(0) {}\n\n    ~CommandProcessorVulnerable() {\n        if (m_command_data_buffer) {\n            free(m_command_data_buffer);\n        }\n    }\n\n    bool processCommand(const uint8_t* raw_command_packet, size_t packet_len) {\n        if (!raw_command_packet || packet_len < sizeof(VehicleCommandHeaderVulnerable)) {\n            return false;\n        }\n\n        const VehicleCommandHeaderVulnerable* header = reinterpret_cast<const VehicleCommandHeaderVulnerable*>(raw_command_packet);\n        uint16_t incoming_payload_len = header->payload_length;\n\n        if (packet_len < sizeof(VehicleCommandHeaderVulnerable) + incoming_payload_len) {\n            return false;\n        }\n\n        size_t effective_allocation_size = incoming_payload_len;\n        \n        if (m_command_data_buffer) {\n            free(m_command_data_buffer);\n        }\n        m_command_data_buffer = (uint8_t*)malloc(effective_allocation_size);\n        if (!m_command_data_buffer && effective_allocation_size > 0) {\n            return false;\n        }\n        m_allocated_payload_size = effective_allocation_size;\n\n        for (uint16_t i = 0; i < incoming_payload_len; ++i) {\n            m_command_data_buffer[i] = raw_command_packet[sizeof(VehicleCommandHeaderVulnerable) + i];\n        }\n\n        if (header->command_id == DIAGNOSTIC_COMMAND_ID) {\n            for (size_t i = 0; i < DIAGNOSTIC_FOOTER_SIZE; ++i) {\n                m_command_data_buffer[incoming_payload_len + i] = 0xAA;\n            }\n        }\n        \n        return true;\n    }\n\n    const uint8_t* getCommandDataBuffer() const {\n        return m_command_data_buffer;\n    }\n\n    size_t getAllocatedPayloadSize() const {\n        return m_allocated_payload_size;\n    }\n\nprivate:\n    uint8_t* m_command_data_buffer;\n    size_t m_allocated_payload_size;\n};",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <limits>\n\n#pragma pack(push, 1)\nstruct VehicleCommandHeaderFixed {\n    uint16_t command_id;\n    uint16_t payload_length;\n};\n#pragma pack(pop)\n\nconst uint16_t DIAGNOSTIC_COMMAND_ID_FIXED = 0x00A5;\nconst size_t DIAGNOSTIC_FOOTER_SIZE_FIXED = 16;\n\nclass CommandProcessorFixed {\npublic:\n    CommandProcessorFixed() : m_command_data_buffer(nullptr), m_allocated_payload_size(0) {}\n\n    ~CommandProcessorFixed() {\n        if (m_command_data_buffer) {\n            free(m_command_data_buffer);\n        }\n    }\n\n    bool processCommand(const uint8_t* raw_command_packet, size_t packet_len) {\n        if (!raw_command_packet || packet_len < sizeof(VehicleCommandHeaderFixed)) {\n            return false;\n        }\n\n        const VehicleCommandHeaderFixed* header = reinterpret_cast<const VehicleCommandHeaderFixed*>(raw_command_packet);\n        uint16_t incoming_payload_len = header->payload_length;\n\n        size_t additional_footer_size = 0;\n        if (header->command_id == DIAGNOSTIC_COMMAND_ID_FIXED) {\n            additional_footer_size = DIAGNOSTIC_FOOTER_SIZE_FIXED;\n        }\n\n        if (incoming_payload_len > std::numeric_limits<size_t>::max() - additional_footer_size) {\n            return false;\n        }\n        size_t effective_allocation_size = incoming_payload_len + additional_footer_size;\n        \n        if (packet_len < sizeof(VehicleCommandHeaderFixed) + incoming_payload_len) {\n            return false;\n        }\n\n        const size_t MAX_ALLOWED_PAYLOAD_SIZE = 65535; \n        if (incoming_payload_len > MAX_ALLOWED_PAYLOAD_SIZE || effective_allocation_size > MAX_ALLOWED_PAYLOAD_SIZE + DIAGNOSTIC_FOOTER_SIZE_FIXED) {\n            return false;\n        }\n\n        if (m_command_data_buffer) {\n            free(m_command_data_buffer);\n        }\n        m_command_data_buffer = (uint8_t*)malloc(effective_allocation_size);\n        if (!m_command_data_buffer && effective_allocation_size > 0) {\n            return false;\n        }\n        m_allocated_payload_size = effective_allocation_size;\n\n        if (incoming_payload_len > m_allocated_payload_size) {\n            free(m_command_data_buffer); m_command_data_buffer = nullptr; m_allocated_payload_size = 0;\n            return false;\n        }\n        for (uint16_t i = 0; i < incoming_payload_len; ++i) {\n            m_command_data_buffer[i] = raw_command_packet[sizeof(VehicleCommandHeaderFixed) + i];\n        }\n\n        if (header->command_id == DIAGNOSTIC_COMMAND_ID_FIXED) {\n            if (incoming_payload_len > m_allocated_payload_size - DIAGNOSTIC_FOOTER_SIZE_FIXED) {\n                free(m_command_data_buffer); m_command_data_buffer = nullptr; m_allocated_payload_size = 0;\n                return false;\n            }\n            for (size_t i = 0; i < DIAGNOSTIC_FOOTER_SIZE_FIXED; ++i) {\n                m_command_data_buffer[incoming_payload_len + i] = 0xAA;\n            }\n        }\n        \n        return true;\n    }\n\n    const uint8_t* getCommandDataBuffer() const {\n        return m_command_data_buffer;\n    }\n\n    size_t getAllocatedPayloadSize() const {\n        return m_allocated_payload_size;\n    }\n\nprivate:\n    uint8_t* m_command_data_buffer;\n    size_t m_allocated_payload_size;\n};",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <limits>\n\n#pragma pack(push, 1)\nstruct ConfigEntryHeaderVulnerable {\n    uint16_t key_len;\n    uint16_t value_len;\n};\n\nstruct ConfigBlockHeaderVulnerable {\n    uint32_t total_block_size; \n    uint16_t num_entries;\n};\n#pragma pack(pop)\n\nclass ConfigurationSerializerVulnerable {\npublic:\n    // Serializes a vector of key-value string pairs into a contiguous byte buffer.\n    // The serialized format includes a block header, followed by entry headers\n    // for each key-value pair, then the raw key data, then the raw value data.\n    // \n    // VULNERABILITY:\n    // The calculation of `calculated_payload_len` (used for `malloc`) truncates\n    // `size_t` string lengths to `uint16_t` when summing them up. If a key or value\n    // string has a length greater than `UINT16_MAX` (65535), the `static_cast<uint16_t>`\n    // will truncate the length. This leads to `calculated_payload_len` being smaller\n    // than the actual total size needed for all the string data.\n    // When `std::copy` is later used, it copies the *original*, untruncated `size_t`\n    // string lengths into the undersized buffer, resulting in a heap-based buffer overflow.\n    uint8_t* serializeConfigVulnerable(const std::vector<std::pair<std::string, std::string>>& config_map, size_t& serialized_size) {\n        serialized_size = 0;\n        if (config_map.empty()) {\n            return nullptr;\n        }\n\n        size_t calculated_payload_len = 0;\n        for (const auto& entry : config_map) {\n            // VULNERABILITY POINT: String lengths are truncated to uint16_t here\n            // when calculating the total payload size needed for allocation.\n            // If entry.first.length() or entry.second.length() exceeds UINT16_MAX,\n            // the effective length added to calculated_payload_len will be incorrect (smaller).\n            calculated_payload_len += sizeof(ConfigEntryHeaderVulnerable) +\n                                      static_cast<uint16_t>(entry.first.length()) +\n                                      static_cast<uint16_t>(entry.second.length());\n        }\n\n        // Check for potential overflow of serialized_size itself\n        if (calculated_payload_len > (std::numeric_limits<size_t>::max() - sizeof(ConfigBlockHeaderVulnerable))) {\n            return nullptr;\n        }\n\n        serialized_size = sizeof(ConfigBlockHeaderVulnerable) + calculated_payload_len;\n\n        uint8_t* buffer = (uint8_t*)malloc(serialized_size);\n        if (!buffer) {\n            serialized_size = 0;\n            return nullptr;\n        }\n\n        ConfigBlockHeaderVulnerable* block_header = reinterpret_cast<ConfigBlockHeaderVulnerable*>(buffer);\n        block_header->num_entries = static_cast<uint16_t>(config_map.size()); // Assuming num_entries fits uint16_t\n        block_header->total_block_size = static_cast<uint32_t>(serialized_size); // Assuming serialized_size fits uint32_t\n\n        uint8_t* current_ptr = buffer + sizeof(ConfigBlockHeaderVulnerable);\n\n        for (const auto& entry : config_map) {\n            ConfigEntryHeaderVulnerable* entry_header = reinterpret_cast<ConfigEntryHeaderVulnerable*>(current_ptr);\n            \n            // Store the (potentially truncated) lengths in the header\n            entry_header->key_len = static_cast<uint16_t>(entry.first.length());\n            entry_header->value_len = static_cast<uint16_t>(entry.second.length());\n            \n            current_ptr += sizeof(ConfigEntryHeaderVulnerable);\n\n            // VULNERABLE COPY:\n            // std::copy uses the *original* size_t lengths (entry.first.length()),\n            // which might be significantly larger than the uint16_t length used for allocation\n            // if truncation occurred. This causes a heap buffer overflow.\n            std::copy(entry.first.begin(), entry.first.end(), current_ptr);\n            current_ptr += entry.first.length(); // Advances by original length\n\n            std::copy(entry.second.begin(), entry.second.end(), current_ptr);\n            current_ptr += entry.second.length(); // Advances by original length\n        }\n        \n        return buffer;\n    }\n};\n",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <limits>\n\n#pragma pack(push, 1)\nstruct ConfigEntryHeaderFixed {\n    uint16_t key_len;\n    uint16_t value_len;\n};\n\nstruct ConfigBlockHeaderFixed {\n    uint32_t total_block_size;\n    uint16_t num_entries;\n};\n#pragma pack(pop)\n\nclass ConfigurationSerializerFixed {\npublic:\n    // Serializes a vector of key-value string pairs into a contiguous byte buffer.\n    // Fixes the heap-based buffer overflow by correctly calculating the required\n    // buffer size, performing proper integer overflow checks, and enforcing maximum limits.\n    uint8_t* serializeConfigFixed(const std::vector<std::pair<std::string, std::string>>& config_map, size_t& serialized_size) {\n        serialized_size = 0;\n        if (config_map.empty()) {\n            return nullptr;\n        }\n\n        static const uint16_t MAX_KEY_VALUE_LENGTH = 4096; // Max length for individual key/value strings\n        static const uint16_t MAX_CONFIG_ENTRIES = 250;     // Max number of entries allowed\n        static const uint32_t MAX_TOTAL_BLOCK_SIZE = 128 * 1024; // Max total serialized block size (128 KB)\n\n        // FIX 1: Enforce maximum number of entries to prevent excessively large loops or data structures.\n        if (config_map.size() > MAX_CONFIG_ENTRIES) {\n            return nullptr;\n        }\n\n        size_t calculated_payload_len = 0;\n        for (const auto& entry : config_map) {\n            size_t current_key_len = entry.first.length();\n            size_t current_value_len = entry.second.length();\n\n            // FIX 2: Validate that individual string lengths do not exceed uint16_t limits\n            // AND defined application-specific maximums before casting or using in calculations.\n            if (current_key_len > std::numeric_limits<uint16_t>::max() || current_key_len > MAX_KEY_VALUE_LENGTH ||\n                current_value_len > std::numeric_limits<uint16_t>::max() || current_value_len > MAX_KEY_VALUE_LENGTH) {\n                return nullptr; // Reject if lengths are too large or would truncate\n            }\n\n            // FIX 3: Perform integer overflow checks during summation to calculate total payload size.\n            // Use the actual size_t lengths for calculation, not the truncated uint16_t ones.\n            size_t required_for_entry_data = current_key_len + current_value_len;\n            size_t required_for_entry_total = sizeof(ConfigEntryHeaderFixed) + required_for_entry_data;\n\n            if (calculated_payload_len > (std::numeric_limits<size_t>::max() - required_for_entry_total)) {\n                return nullptr; // Overflow if adding this entry's size would exceed size_t max\n            }\n            calculated_payload_len += required_for_entry_total;\n        }\n\n        // FIX 4: Check for integer overflow when combining header size with calculated payload size.\n        if (calculated_payload_len > (std::numeric_limits<size_t>::max() - sizeof(ConfigBlockHeaderFixed))) {\n            return nullptr;\n        }\n        serialized_size = sizeof(ConfigBlockHeaderFixed) + calculated_payload_len;\n\n        // FIX 5: Enforce overall maximum total block size to prevent excessive memory allocation.\n        if (serialized_size > MAX_TOTAL_BLOCK_SIZE) {\n            return nullptr;\n        }\n\n        uint8_t* buffer = (uint8_t*)malloc(serialized_size);\n        if (!buffer) {\n            serialized_size = 0;\n            return nullptr; // Allocation failed\n        }\n\n        ConfigBlockHeaderFixed* block_header = reinterpret_cast<ConfigBlockHeaderFixed*>(buffer);\n        block_header->num_entries = static_cast<uint16_t>(config_map.size());\n        block_header->total_block_size = static_cast<uint32_t>(serialized_size);\n\n        uint8_t* current_ptr = buffer + sizeof(ConfigBlockHeaderFixed);\n        size_t bytes_written_to_buffer = 0;\n\n        for (const auto& entry : config_map) {\n            ConfigEntryHeaderFixed* entry_header = reinterpret_cast<ConfigEntryHeaderFixed*>(current_ptr);\n            \n            size_t current_key_len = entry.first.length();\n            size_t current_value_len = entry.second.length();\n\n            // Lengths are now guaranteed to fit uint16_t and MAX_KEY_VALUE_LENGTH due to prior checks.\n            entry_header->key_len = static_cast<uint16_t>(current_key_len);\n            entry_header->value_len = static_cast<uint16_t>(current_value_len);\n            \n            current_ptr += sizeof(ConfigEntryHeaderFixed);\n            bytes_written_to_buffer += sizeof(ConfigEntryHeaderFixed);\n\n            // FIX 6: Add defensive bounds checks before copying, even if prior calculations are correct.\n            // This guards against logic errors or unexpected state changes.\n            if (bytes_written_to_buffer > serialized_size - current_key_len ||\n                current_ptr > buffer + serialized_size - current_key_len) {\n                free(buffer); serialized_size = 0; return nullptr;\n            }\n            std::copy(entry.first.begin(), entry.first.end(), current_ptr);\n            current_ptr += current_key_len;\n            bytes_written_to_buffer += current_key_len;\n\n            if (bytes_written_to_buffer > serialized_size - current_value_len ||\n                current_ptr > buffer + serialized_size - current_value_len) {\n                free(buffer); serialized_size = 0; return nullptr;\n            }\n            std::copy(entry.second.begin(), entry.second.end(), current_ptr);\n            current_ptr += current_value_len;\n            bytes_written_to_buffer += current_value_len;\n        }\n        \n        // Final sanity check: ensure all calculated bytes were actually written.\n        if (bytes_written_to_buffer != calculated_payload_len) {\n            free(buffer); serialized_size = 0; return nullptr;\n        }\n\n        return buffer;\n    }\n};\n",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <new>\n\n#pragma pack(push, 1)\n\nstruct EventEntryHeaderVulnerable {\n    uint16_t event_id;\n    uint32_t timestamp;\n    uint16_t description_length;\n};\n\nstruct LogPacketHeaderVulnerable {\n    uint32_t packet_sequence_num;\n    uint16_t num_entries;\n    uint32_t total_payload_bytes;\n};\n\n#pragma pack(pop)\n\nconst size_t MAX_AGGREGATED_LOG_BUFFER_SIZE = 128 * 1024;\n\nclass VehicleEventLogProcessorVulnerable {\npublic:\n    VehicleEventLogProcessorVulnerable() : m_log_buffer(nullptr), m_current_log_size(0), m_allocated_capacity(0) {}\n\n    ~VehicleEventLogProcessorVulnerable() {\n        if (m_log_buffer) {\n            free(m_log_buffer);\n            m_log_buffer = nullptr;\n        }\n    }\n\n    bool processLogPacketVulnerable(const uint8_t* raw_packet, size_t packet_len) {\n        if (!raw_packet || packet_len < sizeof(LogPacketHeaderVulnerable)) {\n            return false;\n        }\n\n        const LogPacketHeaderVulnerable* pkt_header = reinterpret_cast<const LogPacketHeaderVulnerable*>(raw_packet);\n\n        if (pkt_header->total_payload_bytes > (packet_len - sizeof(LogPacketHeaderVulnerable))) {\n            return false;\n        }\n        \n        uint32_t buffer_to_allocate_size = pkt_header->total_payload_bytes;\n\n        if (buffer_to_allocate_size > MAX_AGGREGATED_LOG_BUFFER_SIZE) {\n            return false;\n        }\n        if (buffer_to_allocate_size == 0 && pkt_header->num_entries > 0) {\n             return false;\n        }\n\n        if (m_log_buffer) {\n            free(m_log_buffer);\n            m_log_buffer = nullptr;\n        }\n\n        m_log_buffer = (uint8_t*)malloc(buffer_to_allocate_size);\n        if (!m_log_buffer && buffer_to_allocate_size > 0) {\n            m_allocated_capacity = 0;\n            return false;\n        }\n        m_allocated_capacity = buffer_to_allocate_size;\n        m_current_log_size = 0;\n\n        size_t current_raw_offset = sizeof(LogPacketHeaderVulnerable);\n\n        for (uint16_t i = 0; i < pkt_header->num_entries; ++i) {\n            if (current_raw_offset + sizeof(EventEntryHeaderVulnerable) > packet_len) {\n                free(m_log_buffer); m_log_buffer = nullptr; m_allocated_capacity = 0;\n                return false;\n            }\n\n            const EventEntryHeaderVulnerable* entry_header = reinterpret_cast<const EventEntryHeaderVulnerable*>(raw_packet + current_raw_offset);\n            \n            if (current_raw_offset + sizeof(EventEntryHeaderVulnerable) + entry_header->description_length > packet_len) {\n                free(m_log_buffer); m_log_buffer = nullptr; m_allocated_capacity = 0;\n                return false;\n            }\n\n            for (size_t k = 0; k < sizeof(EventEntryHeaderVulnerable); ++k) {\n                m_log_buffer[m_current_log_size + k] = raw_packet[current_raw_offset + k];\n            }\n            m_current_log_size += sizeof(EventEntryHeaderVulnerable);\n\n            for (size_t k = 0; k < entry_header->description_length; ++k) {\n                m_log_buffer[m_current_log_size + k] = raw_packet[current_raw_offset + sizeof(EventEntryHeaderVulnerable) + k];\n            }\n            m_current_log_size += entry_header->description_length;\n\n            current_raw_offset += sizeof(EventEntryHeaderVulnerable) + entry_header->description_length;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getLogBuffer() const { return m_log_buffer; }\n    size_t getCurrentLogSize() const { return m_current_log_size; }\n    size_t getAllocatedCapacity() const { return m_allocated_capacity; }\n\nprivate:\n    uint8_t* m_log_buffer;\n    size_t m_current_log_size;\n    size_t m_allocated_capacity;\n};",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <new>\n#include <limits>\n#include <algorithm>\n\n#pragma pack(push, 1)\n\nstruct EventEntryHeaderFixed {\n    uint16_t event_id;\n    uint32_t timestamp;\n    uint16_t description_length;\n};\n\nstruct LogPacketHeaderFixed {\n    uint32_t packet_sequence_num;\n    uint16_t num_entries;\n    uint32_t total_payload_bytes;\n};\n\n#pragma pack(pop)\n\nconst size_t MAX_AGGREGATED_LOG_BUFFER_SIZE_FIXED = 128 * 1024;\nconst uint16_t MAX_ALLOWED_ENTRIES_PER_PACKET = 1000;\n\nclass VehicleEventLogProcessorFixed {\npublic:\n    VehicleEventLogProcessorFixed() : m_log_buffer(nullptr), m_current_log_size(0), m_allocated_capacity(0) {}\n\n    ~VehicleEventLogProcessorFixed() {\n        if (m_log_buffer) {\n            free(m_log_buffer);\n            m_log_buffer = nullptr;\n        }\n    }\n\n    bool processLogPacketFixed(const uint8_t* raw_packet, size_t packet_len) {\n        if (!raw_packet || packet_len < sizeof(LogPacketHeaderFixed)) {\n            return false;\n        }\n\n        const LogPacketHeaderFixed* pkt_header = reinterpret_cast<const LogPacketHeaderFixed*>(raw_packet);\n\n        if (pkt_header->num_entries == 0 || pkt_header->num_entries > MAX_ALLOWED_ENTRIES_PER_PACKET) {\n            return false;\n        }\n\n        size_t calculated_required_payload_size = 0;\n        size_t current_raw_offset_calc = sizeof(LogPacketHeaderFixed);\n\n        for (uint16_t i = 0; i < pkt_header->num_entries; ++i) {\n            if (current_raw_offset_calc + sizeof(EventEntryHeaderFixed) > packet_len) {\n                return false;\n            }\n\n            const EventEntryHeaderFixed* entry_header = reinterpret_cast<const EventEntryHeaderFixed*>(raw_packet + current_raw_offset_calc);\n\n            if (current_raw_offset_calc + sizeof(EventEntryHeaderFixed) + entry_header->description_length > packet_len) {\n                return false;\n            }\n\n            size_t entry_total_size = sizeof(EventEntryHeaderFixed) + entry_header->description_length;\n            if (calculated_required_payload_size > (std::numeric_limits<size_t>::max() - entry_total_size)) {\n                return false;\n            }\n            calculated_required_payload_size += entry_total_size;\n\n            current_raw_offset_calc += entry_total_size;\n        }\n\n        if (pkt_header->total_payload_bytes != calculated_required_payload_size) {\n            return false;\n        }\n\n        if (calculated_required_payload_size > MAX_AGGREGATED_LOG_BUFFER_SIZE_FIXED) {\n            return false;\n        }\n        \n        if (m_log_buffer) {\n            free(m_log_buffer);\n            m_log_buffer = nullptr;\n        }\n\n        m_log_buffer = (uint8_t*)malloc(calculated_required_payload_size);\n        if (!m_log_buffer && calculated_required_payload_size > 0) {\n            m_allocated_capacity = 0;\n            return false;\n        }\n        m_allocated_capacity = calculated_required_payload_size;\n        m_current_log_size = 0;\n\n        size_t current_raw_offset = sizeof(LogPacketHeaderFixed);\n        for (uint16_t i = 0; i < pkt_header->num_entries; ++i) {\n            const EventEntryHeaderFixed* entry_header = reinterpret_cast<const EventEntryHeaderFixed*>(raw_packet + current_raw_offset);\n            size_t entry_total_size = sizeof(EventEntryHeaderFixed) + entry_header->description_length;\n\n            if (m_current_log_size + entry_total_size > m_allocated_capacity) {\n                free(m_log_buffer); m_log_buffer = nullptr; m_allocated_capacity = 0;\n                return false;\n            }\n\n            for (size_t k = 0; k < sizeof(EventEntryHeaderFixed); ++k) {\n                m_log_buffer[m_current_log_size + k] = raw_packet[current_raw_offset + k];\n            }\n            m_current_log_size += sizeof(EventEntryHeaderFixed);\n\n            for (size_t k = 0; k < entry_header->description_length; ++k) {\n                m_log_buffer[m_current_log_size + k] = raw_packet[current_raw_offset + sizeof(EventEntryHeaderFixed) + k];\n            }\n            m_current_log_size += entry_header->description_length;\n\n            current_raw_offset += entry_total_size;\n        }\n        \n        if (m_current_log_size != m_allocated_capacity) {\n            free(m_log_buffer); m_log_buffer = nullptr; m_allocated_capacity = 0;\n            return false;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getLogBuffer() const { return m_log_buffer; }\n    size_t getCurrentLogSize() const { return m_current_log_size; }\n    size_t getAllocatedCapacity() const { return m_allocated_capacity; }\n\nprivate:\n    uint8_t* m_log_buffer;\n    size_t m_current_log_size;\n    size_t m_allocated_capacity;\n};",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <new>\n\n#pragma pack(push, 1)\nstruct DiagnosticLogEntryHeaderVulnerable {\n    uint16_t entry_type;\n    uint32_t timestamp;\n    uint32_t data_length; \n};\n#pragma pack(pop)\n\nclass DiagnosticLogProcessorVulnerable {\npublic:\n    DiagnosticLogProcessorVulnerable() : m_log_buffer(nullptr), m_current_size(0), m_allocated_capacity(0) {}\n\n    ~DiagnosticLogProcessorVulnerable() {\n        if (m_log_buffer) {\n            free(m_log_buffer);\n        }\n    }\n\n    bool appendLogPacketVulnerable(const uint8_t* raw_packet, size_t packet_len) {\n        if (!raw_packet || packet_len < sizeof(DiagnosticLogEntryHeaderVulnerable)) {\n            return false;\n        }\n\n        const DiagnosticLogEntryHeaderVulnerable* header = \n            reinterpret_cast<const DiagnosticLogEntryHeaderVulnerable*>(raw_packet);\n        \n        if (packet_len < sizeof(DiagnosticLogEntryHeaderVulnerable) || \n            header->data_length > (packet_len - sizeof(DiagnosticLogEntryHeaderVulnerable))) {\n            return false;\n        }\n\n        uint32_t incoming_data_payload_len = header->data_length;\n        uint32_t entry_total_size = sizeof(DiagnosticLogEntryHeaderVulnerable) + incoming_data_payload_len;\n\n        uint32_t new_capacity_u32 = static_cast<uint32_t>(m_current_size) + entry_total_size; \n        size_t new_capacity = new_capacity_u32; \n\n        if (new_capacity > m_allocated_capacity) {\n            uint8_t* temp_buffer = (uint8_t*)realloc(m_log_buffer, new_capacity);\n            if (!temp_buffer && new_capacity > 0) {\n                return false;\n            }\n            m_log_buffer = temp_buffer;\n            m_allocated_capacity = new_capacity;\n        }\n\n        memcpy(m_log_buffer + m_current_size, raw_packet, entry_total_size);\n        m_current_size += entry_total_size;\n\n        return true;\n    }\n\n    size_t getCurrentBufferSize() const {\n        return m_current_size;\n    }\n\n    size_t getAllocatedCapacity() const {\n        return m_allocated_capacity;\n    }\n\n    const uint8_t* getLogBuffer() const {\n        return m_log_buffer;\n    }\n\nprivate:\n    uint8_t* m_log_buffer;\n    size_t m_current_size;\n    size_t m_allocated_capacity;\n};",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <new>\n#include <algorithm>\n#include <limits>\n\n#pragma pack(push, 1)\nstruct DiagnosticLogEntryHeaderFixed {\n    uint16_t entry_type;\n    uint32_t timestamp;\n    uint32_t data_length;\n};\n#pragma pack(pop)\n\nclass DiagnosticLogProcessorFixed {\npublic:\n    DiagnosticLogProcessorFixed() : m_log_buffer(nullptr), m_current_size(0), m_allocated_capacity(0) {}\n\n    ~DiagnosticLogProcessorFixed() {\n        if (m_log_buffer) {\n            free(m_log_buffer);\n        }\n    }\n\n    bool appendLogPacketFixed(const uint8_t* raw_packet, size_t packet_len) {\n        if (!raw_packet || packet_len < sizeof(DiagnosticLogEntryHeaderFixed)) {\n            return false;\n        }\n\n        const DiagnosticLogEntryHeaderFixed* header = \n            reinterpret_cast<const DiagnosticLogEntryHeaderFixed*>(raw_packet);\n        \n        if (packet_len < sizeof(DiagnosticLogEntryHeaderFixed) || \n            header->data_length > (packet_len - sizeof(DiagnosticLogEntryHeaderFixed))) {\n            return false;\n        }\n\n        size_t incoming_data_payload_len = header->data_length; \n        size_t entry_total_size = sizeof(DiagnosticLogEntryHeaderFixed) + incoming_data_payload_len;\n\n        if (m_current_size > std::numeric_limits<size_t>::max() - entry_total_size) {\n            return false;\n        }\n\n        size_t new_required_size = m_current_size + entry_total_size;\n\n        const size_t MAX_AGGREGATED_LOG_SIZE = 16 * 1024 * 1024; \n        if (new_required_size > MAX_AGGREGATED_LOG_SIZE) {\n            return false;\n        }\n\n        if (new_required_size > m_allocated_capacity) {\n            uint8_t* temp_buffer = (uint8_t*)realloc(m_log_buffer, new_required_size);\n            if (!temp_buffer && new_required_size > 0) {\n                return false; \n            }\n            if (new_required_size == 0) {\n                if (m_log_buffer) free(m_log_buffer);\n                m_log_buffer = nullptr;\n                m_allocated_capacity = 0;\n            } else {\n                m_log_buffer = temp_buffer;\n                m_allocated_capacity = new_required_size;\n            }\n        }\n\n        if (m_current_size > m_allocated_capacity - entry_total_size) {\n            return false; \n        }\n\n        memcpy(m_log_buffer + m_current_size, raw_packet, entry_total_size);\n        m_current_size += entry_total_size;\n\n        return true;\n    }\n\n    size_t getCurrentBufferSize() const {\n        return m_current_size;\n    }\n\n    size_t getAllocatedCapacity() const {\n        return m_allocated_capacity;\n    }\n\n    const uint8_t* getLogBuffer() const {\n        return m_log_buffer;\n    }\n\nprivate:\n    uint8_t* m_log_buffer;\n    size_t m_current_size;\n    size_t m_allocated_capacity;\n};",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <new>\n#include <limits>\n\n#pragma pack(push, 1)\nstruct DataBlockHeader {\n    uint32_t block_id;\n    uint16_t num_entries;\n    uint32_t total_declared_payload_size_bytes;\n};\n\nstruct DataEntryHeader {\n    uint16_t entry_type;\n    uint16_t entry_data_len;\n};\n#pragma pack(pop)\n\n#define ENTRY_TYPE_BYTE_ARRAY 0x01\n#define ENTRY_TYPE_UINT32_ARRAY 0x02\n#define ENTRY_TYPE_STRING_UTF8 0x03\n#define ENTRY_TYPE_FLOAT_ARRAY 0x04\n\nclass VehicleDataProcessorVulnerable {\npublic:\n    VehicleDataProcessorVulnerable() : m_processed_buffer(nullptr), m_buffer_capacity(0), m_current_offset(0) {}\n\n    ~VehicleDataProcessorVulnerable() {\n        if (m_processed_buffer) {\n            free(m_processed_buffer);\n        }\n    }\n\n    bool processDataBlockVulnerable(const uint8_t* raw_block_data, size_t raw_block_len) {\n        if (!raw_block_data || raw_block_len < sizeof(DataBlockHeader)) {\n            return false;\n        }\n\n        const DataBlockHeader* block_header = reinterpret_cast<const DataBlockHeader*>(raw_block_data);\n\n        if (raw_block_len < sizeof(DataBlockHeader) + block_header->total_declared_payload_size_bytes) {\n            return false;\n        }\n\n        if (m_processed_buffer) {\n            free(m_processed_buffer);\n        }\n        m_buffer_capacity = block_header->total_declared_payload_size_bytes;\n        m_processed_buffer = (uint8_t*)malloc(m_buffer_capacity);\n        if (!m_processed_buffer && m_buffer_capacity > 0) {\n            m_buffer_capacity = 0;\n            m_current_offset = 0;\n            return false;\n        }\n        m_current_offset = 0;\n\n        const uint8_t* current_read_ptr = raw_block_data + sizeof(DataBlockHeader);\n        size_t remaining_raw_len = raw_block_len - sizeof(DataBlockHeader);\n\n        for (uint16_t i = 0; i < block_header->num_entries; ++i) {\n            if (remaining_raw_len < sizeof(DataEntryHeader)) {\n                return false;\n            }\n\n            const DataEntryHeader* entry_header = reinterpret_cast<const DataEntryHeader*>(current_read_ptr);\n            uint16_t entry_data_len = entry_header->entry_data_len;\n\n            size_t actual_bytes_to_copy_for_entry_data = 0;\n            if (entry_header->entry_type == ENTRY_TYPE_BYTE_ARRAY || entry_header->entry_type == ENTRY_TYPE_STRING_UTF8) {\n                actual_bytes_to_copy_for_entry_data = entry_data_len;\n            } else if (entry_header->entry_type == ENTRY_TYPE_UINT32_ARRAY) {\n                if (entry_data_len > (std::numeric_limits<uint16_t>::max() / sizeof(uint32_t))) {\n                    return false;\n                }\n                actual_bytes_to_copy_for_entry_data = static_cast<size_t>(entry_data_len) * sizeof(uint32_t);\n            } else if (entry_header->entry_type == ENTRY_TYPE_FLOAT_ARRAY) {\n                if (entry_data_len > (std::numeric_limits<uint16_t>::max() / sizeof(float))) {\n                    return false;\n                }\n                actual_bytes_to_copy_for_entry_data = static_cast<size_t>(entry_data_len) * sizeof(float);\n            } else {\n                current_read_ptr += sizeof(DataEntryHeader);\n                remaining_raw_len -= sizeof(DataEntryHeader);\n                continue;\n            }\n\n            if (remaining_raw_len < sizeof(DataEntryHeader) + actual_bytes_to_copy_for_entry_data) {\n                return false;\n            }\n\n            if (m_current_offset > (SIZE_MAX - sizeof(DataEntryHeader)) ||\n                m_current_offset + sizeof(DataEntryHeader) > (SIZE_MAX - actual_bytes_to_copy_for_entry_data) ||\n                m_current_offset + sizeof(DataEntryHeader) + actual_bytes_to_copy_for_entry_data > m_buffer_capacity) {\n                return false;\n            }\n\n            memcpy(m_processed_buffer + m_current_offset, entry_header, sizeof(DataEntryHeader));\n            m_current_offset += sizeof(DataEntryHeader);\n\n            memcpy(m_processed_buffer + m_current_offset,\n                   current_read_ptr + sizeof(DataEntryHeader),\n                   actual_bytes_to_copy_for_entry_data);\n            m_current_offset += actual_bytes_to_copy_for_entry_data;\n\n            current_read_ptr += sizeof(DataEntryHeader) + actual_bytes_to_copy_for_entry_data;\n            remaining_raw_len -= (sizeof(DataEntryHeader) + actual_bytes_to_copy_for_entry_data);\n        }\n\n        return true;\n    }\n\n    const uint8_t* getProcessedBuffer() const { return m_processed_buffer; }\n    size_t getProcessedSize() const { return m_current_offset; }\n    size_t getBufferCapacity() const { return m_buffer_capacity; }\n\nprivate:\n    uint8_t* m_processed_buffer;\n    size_t   m_buffer_capacity;\n    size_t   m_current_offset;\n};",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <new>\n#include <limits>\n#include <algorithm>\n\n#pragma pack(push, 1)\nstruct DataBlockHeaderFixed {\n    uint32_t block_id;\n    uint16_t num_entries;\n    uint32_t total_declared_payload_size_bytes;\n};\n\nstruct DataEntryHeaderFixed {\n    uint16_t entry_type;\n    uint16_t entry_data_len;\n};\n#pragma pack(pop)\n\n#define ENTRY_TYPE_BYTE_ARRAY_FIXED 0x01\n#define ENTRY_TYPE_UINT32_ARRAY_FIXED 0x02\n#define ENTRY_TYPE_STRING_UTF8_FIXED 0x03\n#define ENTRY_TYPE_FLOAT_ARRAY_FIXED 0x04\n\nclass VehicleDataProcessorFixed {\npublic:\n    VehicleDataProcessorFixed() : m_processed_buffer(nullptr), m_buffer_capacity(0), m_current_offset(0) {}\n\n    ~VehicleDataProcessorFixed() {\n        if (m_processed_buffer) {\n            free(m_processed_buffer);\n        }\n    }\n\n    bool processDataBlockFixed(const uint8_t* raw_block_data, size_t raw_block_len) {\n        if (!raw_block_data || raw_block_len < sizeof(DataBlockHeaderFixed)) {\n            return false;\n        }\n\n        const DataBlockHeaderFixed* block_header = reinterpret_cast<const DataBlockHeaderFixed*>(raw_block_data);\n\n        size_t calculated_total_storage_needed = 0;\n        size_t current_validation_offset = sizeof(DataBlockHeaderFixed);\n\n        for (uint16_t i = 0; i < block_header->num_entries; ++i) {\n            if (current_validation_offset > (std::numeric_limits<size_t>::max() - sizeof(DataEntryHeaderFixed)) ||\n                current_validation_offset + sizeof(DataEntryHeaderFixed) > raw_block_len) {\n                return false;\n            }\n\n            const DataEntryHeaderFixed* entry_header = reinterpret_cast<const DataEntryHeaderFixed*>(raw_block_data + current_validation_offset);\n            uint16_t entry_data_len = entry_header->entry_data_len;\n\n            size_t bytes_for_this_entry_data = 0;\n            switch (entry_header->entry_type) {\n                case ENTRY_TYPE_BYTE_ARRAY_FIXED:\n                case ENTRY_TYPE_STRING_UTF8_FIXED:\n                    bytes_for_this_entry_data = entry_data_len;\n                    break;\n                case ENTRY_TYPE_UINT32_ARRAY_FIXED:\n                    if (entry_data_len > (std::numeric_limits<uint16_t>::max() / sizeof(uint32_t))) return false;\n                    bytes_for_this_entry_data = static_cast<size_t>(entry_data_len) * sizeof(uint32_t);\n                    break;\n                case ENTRY_TYPE_FLOAT_ARRAY_FIXED:\n                    if (entry_data_len > (std::numeric_limits<uint16_t>::max() / sizeof(float))) return false;\n                    bytes_for_this_entry_data = static_cast<size_t>(entry_data_len) * sizeof(float);\n                    break;\n                default:\n                    return false;\n            }\n\n            if (calculated_total_storage_needed > (std::numeric_limits<size_t>::max() - sizeof(DataEntryHeaderFixed)) ||\n                calculated_total_storage_needed + sizeof(DataEntryHeaderFixed) > (std::numeric_limits<size_t>::max() - bytes_for_this_entry_data)) {\n                return false;\n            }\n            calculated_total_storage_needed += sizeof(DataEntryHeaderFixed) + bytes_for_this_entry_data;\n\n            if (current_validation_offset > (std::numeric_limits<size_t>::max() - sizeof(DataEntryHeaderFixed)) ||\n                current_validation_offset + sizeof(DataEntryHeaderFixed) > (std::numeric_limits<size_t>::max() - bytes_for_this_entry_data)) {\n                return false;\n            }\n            current_validation_offset += sizeof(DataEntryHeaderFixed) + bytes_for_this_entry_data;\n        }\n        \n        if (current_validation_offset != raw_block_len || \n            calculated_total_storage_needed != block_header->total_declared_payload_size_bytes) {\n             return false;\n        }\n\n        if (m_processed_buffer) {\n            free(m_processed_buffer);\n        }\n        m_buffer_capacity = calculated_total_storage_needed;\n        m_processed_buffer = (uint8_t*)malloc(m_buffer_capacity);\n        if (!m_processed_buffer && m_buffer_capacity > 0) {\n            m_buffer_capacity = 0;\n            m_current_offset = 0;\n            return false;\n        }\n        m_current_offset = 0;\n\n        const uint8_t* current_read_ptr = raw_block_data + sizeof(DataBlockHeaderFixed);\n        \n        for (uint16_t i = 0; i < block_header->num_entries; ++i) {\n            const DataEntryHeaderFixed* entry_header = reinterpret_cast<const DataEntryHeaderFixed*>(current_read_ptr);\n            uint16_t entry_data_len = entry_header->entry_data_len;\n\n            size_t bytes_to_copy_for_entry_data = 0;\n            switch (entry_header->entry_type) {\n                case ENTRY_TYPE_BYTE_ARRAY_FIXED:\n                case ENTRY_TYPE_STRING_UTF8_FIXED:\n                    bytes_to_copy_for_entry_data = entry_data_len;\n                    break;\n                case ENTRY_TYPE_UINT32_ARRAY_FIXED:\n                    bytes_to_copy_for_entry_data = static_cast<size_t>(entry_data_len) * sizeof(uint32_t);\n                    break;\n                case ENTRY_TYPE_FLOAT_ARRAY_FIXED:\n                    bytes_to_copy_for_entry_data = static_cast<size_t>(entry_data_len) * sizeof(float);\n                    break;\n                default:\n                    return false;\n            }\n\n            if (m_current_offset > (std::numeric_limits<size_t>::max() - sizeof(DataEntryHeaderFixed)) ||\n                m_current_offset + sizeof(DataEntryHeaderFixed) > (std::numeric_limits<size_t>::max() - bytes_to_copy_for_entry_data) ||\n                m_current_offset + sizeof(DataEntryHeaderFixed) + bytes_to_copy_for_entry_data > m_buffer_capacity) {\n                return false;\n            }\n\n            memcpy(m_processed_buffer + m_current_offset, entry_header, sizeof(DataEntryHeaderFixed));\n            m_current_offset += sizeof(DataEntryHeaderFixed);\n\n            memcpy(m_processed_buffer + m_current_offset,\n                   current_read_ptr + sizeof(DataEntryHeaderFixed),\n                   bytes_to_copy_for_entry_data);\n            m_current_offset += bytes_to_copy_for_entry_data;\n\n            current_read_ptr += sizeof(DataEntryHeaderFixed) + bytes_to_copy_for_entry_data;\n        }\n        \n        if (m_current_offset != m_buffer_capacity) {\n            return false;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getProcessedBuffer() const { return m_processed_buffer; }\n    size_t getProcessedSize() const { return m_current_offset; }\n    size_t getBufferCapacity() const { return m_buffer_capacity; }\n\nprivate:\n    uint8_t* m_processed_buffer;\n    size_t   m_buffer_capacity;\n    size_t   m_current_offset;\n};",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n\n#pragma pack(push, 1)\nstruct ParameterBlockHeaderVulnerable {\n    uint16_t block_id;\n    uint16_t data_word_count; \n};\n#pragma pack(pop)\n\nclass ECUParameterConfiguratorVulnerable {\nprivate:\n    uint8_t* m_data_buffer;\n    size_t m_buffer_capacity;\n    size_t m_current_offset;\n\npublic:\n    ECUParameterConfiguratorVulnerable() : m_data_buffer(nullptr), m_buffer_capacity(0), m_current_offset(0) {}\n\n    ~ECUParameterConfiguratorVulnerable() {\n        if (m_data_buffer) {\n            free(m_data_buffer);\n            m_data_buffer = nullptr;\n        }\n    }\n\n    bool loadParameterBlockVulnerable(const uint8_t* raw_block, size_t block_len) {\n        if (!raw_block || block_len < sizeof(ParameterBlockHeaderVulnerable)) {\n            return false;\n        }\n\n        const ParameterBlockHeaderVulnerable* header = reinterpret_cast<const ParameterBlockHeaderVulnerable*>(raw_block);\n        uint16_t advertised_word_count = header->data_word_count; \n\n        size_t expected_payload_bytes_in_block = (size_t)advertised_word_count * sizeof(uint32_t);\n        if (block_len < sizeof(ParameterBlockHeaderVulnerable) + expected_payload_bytes_in_block) {\n             return false;\n        }\n\n        size_t required_bytes_for_data = advertised_word_count; \n        size_t total_required_size = required_bytes_for_data + sizeof(ParameterBlockHeaderVulnerable);\n        \n        if (m_data_buffer == nullptr || m_current_offset + total_required_size > m_buffer_capacity) {\n            size_t new_capacity = m_buffer_capacity == 0 ? 1024 : m_buffer_capacity * 2;\n            if (new_capacity < m_current_offset + total_required_size) {\n                new_capacity = m_current_offset + total_required_size;\n            }\n            \n            static const size_t MAX_TOTAL_BUFFER_SIZE = 65536; \n            if (new_capacity > MAX_TOTAL_BUFFER_SIZE) {\n                new_capacity = MAX_TOTAL_BUFFER_SIZE;\n                if (m_current_offset + total_required_size > new_capacity) {\n                    return false; \n                }\n            }\n            \n            uint8_t* new_buffer = (uint8_t*)realloc(m_data_buffer, new_capacity);\n            if (!new_buffer) {\n                if (m_data_buffer) { free(m_data_buffer); }\n                m_data_buffer = nullptr;\n                m_buffer_capacity = 0;\n                m_current_offset = 0;\n                return false;\n            }\n            m_data_buffer = new_buffer;\n            m_buffer_capacity = new_capacity;\n        }\n\n        for (size_t k = 0; k < sizeof(ParameterBlockHeaderVulnerable); ++k) {\n            m_data_buffer[m_current_offset + k] = raw_block[k];\n        }\n        m_current_offset += sizeof(ParameterBlockHeaderVulnerable);\n\n        size_t bytes_to_copy_payload = (size_t)advertised_word_count * sizeof(uint32_t);\n        for (size_t k = 0; k < bytes_to_copy_payload; ++k) {\n            m_data_buffer[m_current_offset + k] = raw_block[sizeof(ParameterBlockHeaderVulnerable) + k];\n        }\n        m_current_offset += bytes_to_copy_payload;\n\n        return true;\n    }\n\n    const uint8_t* getDataBuffer() const { return m_data_buffer; }\n    size_t getCurrentOffset() const { return m_current_offset; }\n    size_t getBufferCapacity() const { return m_buffer_capacity; }\n};",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <limits>\n\n#pragma pack(push, 1)\nstruct ParameterBlockHeaderFixed {\n    uint16_t block_id;\n    uint16_t data_word_count; \n};\n#pragma pack(pop)\n\nclass ECUParameterConfiguratorFixed {\nprivate:\n    uint8_t* m_data_buffer;\n    size_t m_buffer_capacity;\n    size_t m_current_offset;\n\npublic:\n    ECUParameterConfiguratorFixed() : m_data_buffer(nullptr), m_buffer_capacity(0), m_current_offset(0) {}\n\n    ~ECUParameterConfiguratorFixed() {\n        if (m_data_buffer) {\n            free(m_data_buffer);\n            m_data_buffer = nullptr;\n        }\n    }\n\n    bool loadParameterBlockFixed(const uint8_t* raw_block, size_t block_len) {\n        if (!raw_block || block_len < sizeof(ParameterBlockHeaderFixed)) {\n            return false;\n        }\n\n        const ParameterBlockHeaderFixed* header = reinterpret_cast<const ParameterBlockHeaderFixed*>(raw_block);\n        uint16_t advertised_word_count = header->data_word_count; \n\n        if (advertised_word_count > (std::numeric_limits<size_t>::max() / sizeof(uint32_t))) {\n            return false; \n        }\n        size_t required_bytes_for_data = (size_t)advertised_word_count * sizeof(uint32_t);\n\n        size_t total_required_size_for_block;\n        if (required_bytes_for_data > (std::numeric_limits<size_t>::max() - sizeof(ParameterBlockHeaderFixed))) {\n            return false; \n        }\n        total_required_size_for_block = required_bytes_for_data + sizeof(ParameterBlockHeaderFixed);\n\n        if (block_len < total_required_size_for_block) {\n             return false;\n        }\n        \n        if (m_current_offset > (std::numeric_limits<size_t>::max() - total_required_size_for_block)) {\n            return false;\n        }\n\n        if (m_data_buffer == nullptr || m_current_offset + total_required_size_for_block > m_buffer_capacity) {\n            size_t new_capacity = m_buffer_capacity == 0 ? 1024 : m_buffer_capacity * 2;\n            if (new_capacity < m_current_offset + total_required_size_for_block) {\n                new_capacity = m_current_offset + total_required_size_for_block;\n            }\n            \n            static const size_t MAX_TOTAL_BUFFER_SIZE = 65536; \n            if (new_capacity > MAX_TOTAL_BUFFER_SIZE) {\n                new_capacity = MAX_TOTAL_BUFFER_SIZE;\n            }\n\n            if (m_current_offset > (MAX_TOTAL_BUFFER_SIZE - total_required_size_for_block)) {\n                return false; \n            }\n            \n            uint8_t* new_buffer = (uint8_t*)realloc(m_data_buffer, new_capacity);\n            if (!new_buffer) {\n                if (m_data_buffer) { free(m_data_buffer); }\n                m_data_buffer = nullptr;\n                m_buffer_capacity = 0;\n                m_current_offset = 0;\n                return false;\n            }\n            m_data_buffer = new_buffer;\n            m_buffer_capacity = new_capacity;\n        }\n\n        for (size_t k = 0; k < sizeof(ParameterBlockHeaderFixed); ++k) {\n            m_data_buffer[m_current_offset + k] = raw_block[k];\n        }\n        m_current_offset += sizeof(ParameterBlockHeaderFixed);\n\n        for (size_t k = 0; k < required_bytes_for_data; ++k) {\n            m_data_buffer[m_current_offset + k] = raw_block[sizeof(ParameterBlockHeaderFixed) + k];\n        }\n        m_current_offset += required_bytes_for_data;\n\n        return true;\n    }\n\n    const uint8_t* getDataBuffer() const { return m_data_buffer; }\n    size_t getCurrentOffset() const { return m_current_offset; }\n    size_t getBufferCapacity() const { return m_buffer_capacity; }\n};",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <vector>\n#include <string>\n\n#pragma pack(push, 1)\nstruct CommandHeader {\n    uint16_t command_id;\n    uint16_t num_args;\n    uint32_t total_arg_data_size; \n};\n\nstruct ArgumentEntry {\n    uint16_t arg_id;\n    uint16_t arg_type; \n    uint16_t arg_length; \n};\n#pragma pack(pop)\n\nstruct ParsedArgument {\n    uint16_t arg_id;\n    uint16_t arg_type;\n    size_t data_offset; \n    size_t data_length; \n};\n\nclass CommandProcessorVulnerable {\npublic:\n    CommandProcessorVulnerable() : m_arg_buffer(nullptr), m_buffer_capacity(0) {}\n\n    ~CommandProcessorVulnerable() {\n        cleanup();\n    }\n\n    bool processCommandPacketVulnerable(const uint8_t* raw_packet, size_t packet_len) {\n        if (!raw_packet || packet_len < sizeof(CommandHeader)) {\n            return false;\n        }\n\n        const CommandHeader* cmd_header = reinterpret_cast<const CommandHeader*>(raw_packet);\n\n        if (cmd_header->total_arg_data_size > (packet_len - sizeof(CommandHeader))) {\n            return false;\n        }\n\n        cleanup(); \n\n        if (cmd_header->total_arg_data_size > 0) {\n            m_arg_buffer = (uint8_t*)malloc(cmd_header->total_arg_data_size);\n            if (!m_arg_buffer) {\n                return false;\n            }\n            m_buffer_capacity = cmd_header->total_arg_data_size;\n        } else {\n            if (cmd_header->num_args > 0) {\n\n            }\n        }\n\n        size_t current_packet_read_offset = sizeof(CommandHeader);\n        size_t current_buffer_write_offset = 0;\n\n        for (uint16_t i = 0; i < cmd_header->num_args; ++i) {\n            if (current_packet_read_offset + sizeof(ArgumentEntry) > packet_len) {\n                cleanup();\n                return false;\n            }\n\n            const ArgumentEntry* arg_entry_header = reinterpret_cast<const ArgumentEntry*>(raw_packet + current_packet_read_offset);\n            uint16_t arg_value_len = arg_entry_header->arg_length;\n\n            if (current_packet_read_offset + sizeof(ArgumentEntry) + arg_value_len > packet_len) {\n                cleanup();\n                return false;\n            }\n\n            size_t bytes_to_store_this_arg = arg_value_len; \n            \n            if (arg_entry_header->arg_type == 0x05) {\n                bytes_to_store_this_arg += sizeof(ArgumentEntry); \n            }\n\n            if (current_buffer_write_offset + bytes_to_store_this_arg > m_buffer_capacity) {\n                cleanup();\n                return false;\n            }\n\n            const uint8_t* source_data_ptr = raw_packet + current_packet_read_offset + sizeof(ArgumentEntry);\n            \n            if (arg_entry_header->arg_type == 0x05) {\n                for (size_t k = 0; k < sizeof(ArgumentEntry); ++k) {\n                    m_arg_buffer[current_buffer_write_offset + k] = raw_packet[current_packet_read_offset + k];\n                }\n                current_buffer_write_offset += sizeof(ArgumentEntry);\n            }\n            \n            for (uint16_t k = 0; k < arg_value_len; ++k) {\n                m_arg_buffer[current_buffer_write_offset + k] = source_data_ptr[k];\n            }\n            current_buffer_write_offset += arg_value_len;\n\n            ParsedArgument p_arg;\n            p_arg.arg_id = arg_entry_header->arg_id;\n            p_arg.arg_type = arg_entry_header->arg_type;\n            m_parsed_args.push_back(p_arg);\n\n            current_packet_read_offset += sizeof(ArgumentEntry) + arg_value_len;\n        }\n\n        if (current_buffer_write_offset > m_buffer_capacity) {\n            cleanup();\n            return false;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getArgBuffer() const { return m_arg_buffer; }\n    size_t getBufferCapacity() const { return m_buffer_capacity; }\n    const std::vector<ParsedArgument>& getParsedArgs() const { return m_parsed_args; }\n\nprivate:\n    uint8_t* m_arg_buffer; \n    size_t m_buffer_capacity; \n    std::vector<ParsedArgument> m_parsed_args; \n\n    void cleanup() {\n        if (m_arg_buffer) {\n            free(m_arg_buffer);\n            m_arg_buffer = nullptr;\n        }\n        m_buffer_capacity = 0;\n        m_parsed_args.clear();\n    }\n};",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <vector>\n#include <string>\n#include <limits>\n\n#pragma pack(push, 1)\nstruct CommandHeaderFixed {\n    uint16_t command_id;\n    uint16_t num_args;\n    uint32_t total_arg_data_size; \n};\n\nstruct ArgumentEntryFixed {\n    uint16_t arg_id;\n    uint16_t arg_type; \n    uint16_t arg_length; \n};\n#pragma pack(pop)\n\nstruct ParsedArgumentFixed {\n    uint16_t arg_id;\n    uint16_t arg_type;\n    size_t data_offset;\n    size_t data_length;\n};\n\nclass CommandProcessorFixed {\npublic:\n    CommandProcessorFixed() : m_arg_buffer(nullptr), m_buffer_capacity(0) {}\n\n    ~CommandProcessorFixed() {\n        cleanup();\n    }\n\n    bool processCommandPacketFixed(const uint8_t* raw_packet, size_t packet_len) {\n        if (!raw_packet || packet_len < sizeof(CommandHeaderFixed)) {\n            return false;\n        }\n\n        const CommandHeaderFixed* cmd_header = reinterpret_cast<const CommandHeaderFixed*>(raw_packet);\n\n        cleanup(); \n\n        size_t actual_total_required_buffer_size = 0; \n        size_t current_packet_scan_offset = sizeof(CommandHeaderFixed);\n\n        for (uint16_t i = 0; i < cmd_header->num_args; ++i) {\n            if (current_packet_scan_offset > (std::numeric_limits<size_t>::max() - sizeof(ArgumentEntryFixed)) ||\n                current_packet_scan_offset + sizeof(ArgumentEntryFixed) > packet_len) {\n                return false;\n            }\n            const ArgumentEntryFixed* arg_entry_header_scan = reinterpret_cast<const ArgumentEntryFixed*>(raw_packet + current_packet_scan_offset);\n            uint16_t arg_value_len = arg_entry_header_scan->arg_length;\n\n            if (current_packet_scan_offset + sizeof(ArgumentEntryFixed) > (std::numeric_limits<size_t>::max() - arg_value_len) ||\n                current_packet_scan_offset + sizeof(ArgumentEntryFixed) + arg_value_len > packet_len) {\n                return false;\n            }\n\n            size_t bytes_to_store_this_arg = arg_value_len;\n            if (arg_entry_header_scan->arg_type == 0x05) {\n                if (bytes_to_store_this_arg > (std::numeric_limits<size_t>::max() - sizeof(ArgumentEntryFixed))) {\n                    return false; \n                }\n                bytes_to_store_this_arg += sizeof(ArgumentEntryFixed);\n            }\n\n            if (actual_total_required_buffer_size > (std::numeric_limits<size_t>::max() - bytes_to_store_this_arg)) {\n                return false; \n            }\n            actual_total_required_buffer_size += bytes_to_store_this_arg;\n            \n            current_packet_scan_offset += sizeof(ArgumentEntryFixed) + arg_value_len;\n        }\n        \n        if (current_packet_scan_offset != packet_len) {\n            return false;\n        }\n\n        if (cmd_header->total_arg_data_size != actual_total_required_buffer_size) {\n            return false;\n        }\n\n        if (actual_total_required_buffer_size > 0) {\n            m_arg_buffer = (uint8_t*)malloc(actual_total_required_buffer_size);\n            if (!m_arg_buffer) {\n                return false;\n            }\n            m_buffer_capacity = actual_total_required_buffer_size;\n        }\n\n        size_t current_packet_read_offset = sizeof(CommandHeaderFixed);\n        size_t current_buffer_write_offset = 0;\n\n        for (uint16_t i = 0; i < cmd_header->num_args; ++i) {\n            const ArgumentEntryFixed* arg_entry_header = reinterpret_cast<const ArgumentEntryFixed*>(raw_packet + current_packet_read_offset);\n            uint16_t arg_value_len = arg_entry_header->arg_length;\n\n            size_t bytes_to_store_this_arg = arg_value_len;\n            if (arg_entry_header->arg_type == 0x05) {\n                bytes_to_store_this_arg += sizeof(ArgumentEntryFixed);\n            }\n\n            if (current_buffer_write_offset > (std::numeric_limits<size_t>::max() - bytes_to_store_this_arg) ||\n                current_buffer_write_offset + bytes_to_store_this_arg > m_buffer_capacity) {\n                cleanup();\n                return false;\n            }\n\n            const uint8_t* source_data_ptr = raw_packet + current_packet_read_offset + sizeof(ArgumentEntryFixed);\n            \n            if (arg_entry_header->arg_type == 0x05) {\n                for (size_t k = 0; k < sizeof(ArgumentEntryFixed); ++k) {\n                    m_arg_buffer[current_buffer_write_offset + k] = raw_packet[current_packet_read_offset + k];\n                }\n                current_buffer_write_offset += sizeof(ArgumentEntryFixed);\n            }\n            \n            for (uint16_t k = 0; k < arg_value_len; ++k) {\n                m_arg_buffer[current_buffer_write_offset + k] = source_data_ptr[k];\n            }\n            current_buffer_write_offset += arg_value_len;\n\n            ParsedArgumentFixed p_arg;\n            p_arg.arg_id = arg_entry_header->arg_id;\n            p_arg.arg_type = arg_entry_header->arg_type;\n            p_arg.data_offset = current_buffer_write_offset - bytes_to_store_this_arg; \n            p_arg.data_length = bytes_to_store_this_arg;\n            m_parsed_args.push_back(p_arg);\n\n            current_packet_read_offset += sizeof(ArgumentEntryFixed) + arg_value_len;\n        }\n\n        if (current_buffer_write_offset != m_buffer_capacity) {\n            cleanup();\n            return false;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getArgBuffer() const { return m_arg_buffer; }\n    size_t getBufferCapacity() const { return m_buffer_capacity; }\n    const std::vector<ParsedArgumentFixed>& getParsedArgs() const { return m_parsed_args; }\n\nprivate:\n    uint8_t* m_arg_buffer;\n    size_t m_buffer_capacity;\n    std::vector<ParsedArgumentFixed> m_parsed_args;\n\n    void cleanup() {\n        if (m_arg_buffer) {\n            free(m_arg_buffer);\n            m_arg_buffer = nullptr;\n        }\n        m_buffer_capacity = 0;\n        m_parsed_args.clear();\n    }\n};",
    "analysis": ""
  },
  {
    "cwe_id": "122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n\n#pragma pack(push, 1)\nstruct DiagRequestHeader {\n    uint8_t service_id;\n    uint8_t num_dids;\n};\n\nstruct DIDRequestEntry {\n    uint16_t did_id;\n};\n\nstruct DiagResponseHeader {\n    uint8_t service_id_ack;\n    uint8_t num_dids_responded;\n};\n\nstruct DIDResponseEntry {\n    uint16_t did_id;\n    uint16_t data_length;\n};\n#pragma pack(pop)\n\nclass DiagnosticResponseBuilderVulnerable {\nprivate:\n    uint8_t* m_response_buffer;\n    size_t m_buffer_capacity;\n    size_t m_current_buffer_pos;\n\n    bool read_did_data_payload_vulnerable(uint16_t did_id, uint8_t* out_buffer, size_t max_out_len, uint16_t* actual_len) {\n        if (!out_buffer || !actual_len || max_out_len == 0) {\n            return false;\n        }\n\n        if (did_id == 0x0100) {\n            const char* vin = \"WVWZZZ12345678901\";\n            if (max_out_len < 17) return false;\n            memcpy(out_buffer, vin, 17);\n            *actual_len = 17;\n            return true;\n        } else if (did_id == 0x0001) {\n            uint8_t secret_data[20] = {0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xA0, 0xB1, 0xC2, 0xD3};\n            if (max_out_len < 20) return false;\n            memcpy(out_buffer, secret_data, 20);\n            *actual_len = 20;\n            return true;\n        }\n        uint8_t default_data[4] = {0x01, 0x02, 0x03, 0x04};\n        if (max_out_len < 4) return false;\n        memcpy(out_buffer, default_data, 4);\n        *actual_len = 4;\n        return true;\n    }\n\npublic:\n    DiagnosticResponseBuilderVulnerable() : m_response_buffer(nullptr), m_buffer_capacity(0), m_current_buffer_pos(0) {}\n\n    ~DiagnosticResponseBuilderVulnerable() {\n        if (m_response_buffer) {\n            free(m_response_buffer);\n        }\n    }\n\n    bool buildResponseVulnerable(const uint8_t* request_data, size_t request_len) {\n        if (!request_data || request_len < sizeof(DiagRequestHeader)) {\n            return false;\n        }\n\n        const DiagRequestHeader* req_hdr = reinterpret_cast<const DiagRequestHeader*>(request_data);\n        if (req_hdr->service_id != 0x22) {\n            return false;\n        }\n        \n        if (request_len < sizeof(DiagRequestHeader) + (size_t)req_hdr->num_dids * sizeof(DIDRequestEntry)) {\n            return false;\n        }\n\n        size_t total_required_size = sizeof(DiagResponseHeader);\n        const DIDRequestEntry* did_entries_ptr = reinterpret_cast<const DIDRequestEntry*>(request_data + sizeof(DiagRequestHeader));\n\n        for (uint8_t i = 0; i < req_hdr->num_dids; ++i) {\n            total_required_size += sizeof(DIDResponseEntry) + 4; \n        }\n\n        if (m_response_buffer) {\n            free(m_response_buffer);\n            m_response_buffer = nullptr;\n        }\n        \n        m_response_buffer = (uint8_t*)malloc(total_required_size);\n        if (!m_response_buffer && total_required_size > 0) {\n            m_buffer_capacity = 0;\n            m_current_buffer_pos = 0;\n            return false;\n        }\n        m_buffer_capacity = total_required_size;\n        m_current_buffer_pos = 0;\n\n        DiagResponseHeader resp_hdr;\n        resp_hdr.service_id_ack = req_hdr->service_id + 0x40;\n        resp_hdr.num_dids_responded = req_hdr->num_dids;\n        \n        if (m_current_buffer_pos + sizeof(DiagResponseHeader) > m_buffer_capacity) {\n            return false; \n        }\n        memcpy(m_response_buffer + m_current_buffer_pos, &resp_hdr, sizeof(DiagResponseHeader));\n        m_current_buffer_pos += sizeof(DiagResponseHeader);\n\n        for (uint8_t i = 0; i < req_hdr->num_dids; ++i) {\n            uint16_t requested_did_id = did_entries_ptr[i].did_id;\n            DIDResponseEntry did_resp_entry;\n            did_resp_entry.did_id = requested_did_id;\n\n            uint8_t temp_data[128]; \n            uint16_t actual_did_data_len = 0;\n\n            if (read_did_data_payload_vulnerable(requested_did_id, temp_data, sizeof(temp_data), &actual_did_data_len)) {\n                did_resp_entry.data_length = actual_did_data_len;\n\n                if (m_current_buffer_pos > m_buffer_capacity - (sizeof(DIDResponseEntry) + actual_did_data_len)) {\n                    return false; \n                }\n\n                memcpy(m_response_buffer + m_current_buffer_pos, &did_resp_entry, sizeof(DIDResponseEntry));\n                m_current_buffer_pos += sizeof(DIDResponseEntry);\n\n                memcpy(m_response_buffer + m_current_buffer_pos, temp_data, actual_did_data_len); \n                m_current_buffer_pos += actual_did_data_len;\n            } else {\n                did_resp_entry.data_length = 0;\n                if (m_current_buffer_pos > m_buffer_capacity - sizeof(DIDResponseEntry)) {\n                    return false;\n                }\n                memcpy(m_response_buffer + m_current_buffer_pos, &did_resp_entry, sizeof(DIDResponseEntry));\n                m_current_buffer_pos += sizeof(DIDResponseEntry);\n            }\n        }\n        return true;\n    }\n\n    const uint8_t* getResponseBuffer() const {\n        return m_response_buffer;\n    }\n\n    size_t getCurrentBufferSize() const {\n        return m_current_buffer_pos;\n    }\n};",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <limits>\n\n#pragma pack(push, 1)\nstruct DiagRequestHeader {\n    uint8_t service_id;\n    uint8_t num_dids;\n};\n\nstruct DIDRequestEntry {\n    uint16_t did_id;\n};\n\nstruct DiagResponseHeader {\n    uint8_t service_id_ack;\n    uint8_t num_dids_responded;\n};\n\nstruct DIDResponseEntry {\n    uint16_t did_id;\n    uint16_t data_length;\n};\n#pragma pack(pop)\n\nclass DiagnosticResponseBuilderFixed {\nprivate:\n    uint8_t* m_response_buffer;\n    size_t m_buffer_capacity;\n    size_t m_current_buffer_pos;\n\n    uint16_t get_did_expected_payload_size_fixed(uint16_t did_id) {\n        if (did_id == 0x0100) {\n            return 17;\n        } else if (did_id == 0x0001) {\n            return 20;\n        }\n        return 4; \n    }\n\n    bool read_did_data_payload_fixed(uint16_t did_id, uint8_t* out_buffer, size_t max_out_len, uint16_t* actual_len) {\n        if (!out_buffer || !actual_len || max_out_len == 0) {\n            return false;\n        }\n\n        if (did_id == 0x0100) {\n            const char* vin = \"WVWZZZ12345678901\";\n            if (max_out_len < 17) return false;\n            memcpy(out_buffer, vin, 17);\n            *actual_len = 17;\n            return true;\n        } else if (did_id == 0x0001) {\n            uint8_t secret_data[20] = {0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xA0, 0xB1, 0xC2, 0xD3};\n            if (max_out_len < 20) return false;\n            memcpy(out_buffer, secret_data, 20);\n            *actual_len = 20;\n            return true;\n        }\n        uint8_t default_data[4] = {0x01, 0x02, 0x03, 0x04};\n        if (max_out_len < 4) return false;\n        memcpy(out_buffer, default_data, 4);\n        *actual_len = 4;\n        return true;\n    }\n\npublic:\n    DiagnosticResponseBuilderFixed() : m_response_buffer(nullptr), m_buffer_capacity(0), m_current_buffer_pos(0) {}\n\n    ~DiagnosticResponseBuilderFixed() {\n        if (m_response_buffer) {\n            free(m_response_buffer);\n        }\n    }\n\n    bool buildResponseFixed(const uint8_t* request_data, size_t request_len) {\n        if (!request_data || request_len < sizeof(DiagRequestHeader)) {\n            return false;\n        }\n\n        const DiagRequestHeader* req_hdr = reinterpret_cast<const DiagRequestHeader*>(request_data);\n        if (req_hdr->service_id != 0x22) {\n            return false;\n        }\n        \n        if (request_len < sizeof(DiagRequestHeader) + (size_t)req_hdr->num_dids * sizeof(DIDRequestEntry)) {\n            return false;\n        }\n\n        size_t total_required_size = sizeof(DiagResponseHeader);\n        const DIDRequestEntry* did_entries_ptr = reinterpret_cast<const DIDRequestEntry*>(request_data + sizeof(DiagRequestHeader));\n\n        for (uint8_t i = 0; i < req_hdr->num_dids; ++i) {\n            uint16_t requested_did_id = did_entries_ptr[i].did_id;\n            uint16_t expected_payload_len = get_did_expected_payload_size_fixed(requested_did_id);\n            \n            if (total_required_size > std::numeric_limits<size_t>::max() - (sizeof(DIDResponseEntry) + expected_payload_len)) {\n                return false; \n            }\n            total_required_size += sizeof(DIDResponseEntry) + expected_payload_len;\n        }\n\n        if (m_response_buffer) {\n            free(m_response_buffer);\n            m_response_buffer = nullptr;\n        }\n        \n        m_response_buffer = (uint8_t*)malloc(total_required_size);\n        if (!m_response_buffer && total_required_size > 0) {\n            m_buffer_capacity = 0;\n            m_current_buffer_pos = 0;\n            return false;\n        }\n        m_buffer_capacity = total_required_size;\n        m_current_buffer_pos = 0;\n\n        DiagResponseHeader resp_hdr;\n        resp_hdr.service_id_ack = req_hdr->service_id + 0x40;\n        resp_hdr.num_dids_responded = req_hdr->num_dids;\n        \n        if (m_current_buffer_pos > m_buffer_capacity - sizeof(DiagResponseHeader)) {\n            return false; \n        }\n        memcpy(m_response_buffer + m_current_buffer_pos, &resp_hdr, sizeof(DiagResponseHeader));\n        m_current_buffer_pos += sizeof(DiagResponseHeader);\n\n        for (uint8_t i = 0; i < req_hdr->num_dids; ++i) {\n            uint16_t requested_did_id = did_entries_ptr[i].did_id;\n            DIDResponseEntry did_resp_entry;\n            did_resp_entry.did_id = requested_did_id;\n\n            uint8_t temp_data[128]; \n            uint16_t actual_did_data_len = 0;\n\n            if (read_did_data_payload_fixed(requested_did_id, temp_data, sizeof(temp_data), &actual_did_data_len)) {\n                did_resp_entry.data_length = actual_did_data_len;\n\n                if (m_current_buffer_pos > m_buffer_capacity - (sizeof(DIDResponseEntry) + actual_did_data_len)) {\n                    return false; \n                }\n\n                memcpy(m_response_buffer + m_current_buffer_pos, &did_resp_entry, sizeof(DIDResponseEntry));\n                m_current_buffer_pos += sizeof(DIDResponseEntry);\n\n                memcpy(m_response_buffer + m_current_buffer_pos, temp_data, actual_did_data_len); \n                m_current_buffer_pos += actual_did_data_len;\n            } else {\n                did_resp_entry.data_length = 0;\n                if (m_current_buffer_pos > m_buffer_capacity - sizeof(DIDResponseEntry)) {\n                    return false;\n                }\n                memcpy(m_response_buffer + m_current_buffer_pos, &did_resp_entry, sizeof(DIDResponseEntry));\n                m_current_buffer_pos += sizeof(DIDResponseEntry);\n            }\n        }\n        return true;\n    }\n\n    const uint8_t* getResponseBuffer() const {\n        return m_response_buffer;\n    }\n\n    size_t getCurrentBufferSize() const {\n        return m_current_buffer_pos;\n    }\n};",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <new>\n\n#pragma pack(push, 1)\n\nstruct SystemLogArchiveHeaderVulnerable {\n    uint32_t archive_id;\n    uint32_t total_compressed_payload_size;\n    uint16_t num_log_entries;\n};\n\nstruct LogEntryHeaderVulnerable {\n    uint16_t entry_id;\n    uint16_t compressed_data_len;\n};\n\n#pragma pack(pop)\n\nclass LogArchiverVulnerable {\npublic:\n    LogArchiverVulnerable() : m_archived_buffer(nullptr), m_buffer_capacity(0) {}\n\n    ~LogArchiverVulnerable() {\n        if (m_archived_buffer) {\n            free(m_archived_buffer);\n        }\n    }\n\n    bool processLogArchivePacketVulnerable(const uint8_t* raw_packet, size_t packet_len) {\n        if (!raw_packet || packet_len < sizeof(SystemLogArchiveHeaderVulnerable)) {\n            return false;\n        }\n\n        const SystemLogArchiveHeaderVulnerable* header =\n            reinterpret_cast<const SystemLogArchiveHeaderVulnerable*>(raw_packet);\n\n        if (header->archive_id == 0) {\n            return false;\n        }\n\n        if (m_archived_buffer) {\n            free(m_archived_buffer);\n            m_archived_buffer = nullptr;\n            m_buffer_capacity = 0;\n        }\n\n        m_buffer_capacity = header->total_compressed_payload_size;\n        if (m_buffer_capacity > 0) {\n            m_archived_buffer = (uint8_t*)malloc(m_buffer_capacity);\n            if (!m_archived_buffer) {\n                m_buffer_capacity = 0;\n                return false;\n            }\n        } else {\n            if (header->num_log_entries > 0) {\n                return false;\n            }\n            return true;\n        }\n\n        size_t current_raw_packet_offset = sizeof(SystemLogArchiveHeaderVulnerable);\n        size_t current_buffer_write_offset = 0;\n\n        for (uint16_t i = 0; i < header->num_log_entries; ++i) {\n            if (current_raw_packet_offset + sizeof(LogEntryHeaderVulnerable) > packet_len) {\n                free(m_archived_buffer);\n                m_archived_buffer = nullptr;\n                m_buffer_capacity = 0;\n                return false;\n            }\n\n            const LogEntryHeaderVulnerable* entry_header =\n                reinterpret_cast<const LogEntryHeaderVulnerable*>(raw_packet + current_raw_packet_offset);\n            \n            uint16_t entry_data_len = entry_header->compressed_data_len;\n            size_t entry_total_size = sizeof(LogEntryHeaderVulnerable) + entry_data_len;\n\n            if (current_raw_packet_offset + entry_total_size > packet_len) {\n                free(m_archived_buffer);\n                m_archived_buffer = nullptr;\n                m_buffer_capacity = 0;\n                return false;\n            }\n\n            for (uint16_t k = 0; k < entry_data_len; ++k) {\n                m_archived_buffer[current_buffer_write_offset + k] = raw_packet[current_raw_packet_offset + sizeof(LogEntryHeaderVulnerable) + k];\n            }\n            current_buffer_write_offset += entry_data_len;\n\n            current_raw_packet_offset += entry_total_size;\n        }\n\n        if (current_buffer_write_offset != header->total_compressed_payload_size) {\n            free(m_archived_buffer);\n            m_archived_buffer = nullptr;\n            m_buffer_capacity = 0;\n            return false;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getArchivedBuffer() const { return m_archived_buffer; }\n    size_t getBufferCapacity() const { return m_buffer_capacity; }\n\nprivate:\n    uint8_t* m_archived_buffer;\n    size_t m_buffer_capacity;\n};",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <new>\n#include <limits>\n\n#pragma pack(push, 1)\n\nstruct SystemLogArchiveHeaderFixed {\n    uint32_t archive_id;\n    uint32_t total_compressed_payload_size;\n    uint16_t num_log_entries;\n};\n\nstruct LogEntryHeaderFixed {\n    uint16_t entry_id;\n    uint16_t compressed_data_len;\n};\n\n#pragma pack(pop)\n\nclass LogArchiverFixed {\npublic:\n    LogArchiverFixed() : m_archived_buffer(nullptr), m_buffer_capacity(0) {}\n\n    ~LogArchiverFixed() {\n        if (m_archived_buffer) {\n            free(m_archived_buffer);\n        }\n    }\n\n    bool processLogArchivePacketFixed(const uint8_t* raw_packet, size_t packet_len) {\n        if (!raw_packet || packet_len < sizeof(SystemLogArchiveHeaderFixed)) {\n            return false;\n        }\n\n        const SystemLogArchiveHeaderFixed* header =\n            reinterpret_cast<const SystemLogArchiveHeaderFixed*>(raw_packet);\n\n        if (header->archive_id == 0) {\n            return false;\n        }\n        \n        size_t calculated_total_data_size = 0;\n        size_t temp_raw_packet_offset = sizeof(SystemLogArchiveHeaderFixed);\n\n        for (uint16_t i = 0; i < header->num_log_entries; ++i) {\n            if (temp_raw_packet_offset + sizeof(LogEntryHeaderFixed) > packet_len) {\n                return false;\n            }\n\n            const LogEntryHeaderFixed* entry_header =\n                reinterpret_cast<const LogEntryHeaderFixed*>(raw_packet + temp_raw_packet_offset);\n            \n            uint16_t entry_data_len = entry_header->compressed_data_len;\n            size_t entry_total_size = sizeof(LogEntryHeaderFixed) + entry_data_len;\n\n            if (temp_raw_packet_offset + entry_total_size > packet_len) {\n                return false;\n            }\n\n            if (calculated_total_data_size > std::numeric_limits<size_t>::max() - entry_data_len) {\n                return false;\n            }\n            calculated_total_data_size += entry_data_len;\n\n            temp_raw_packet_offset += entry_total_size;\n        }\n        \n        if (calculated_total_data_size != header->total_compressed_payload_size) {\n            return false;\n        }\n\n        if (temp_raw_packet_offset != packet_len) {\n             return false;\n        }\n\n        if (m_archived_buffer) {\n            free(m_archived_buffer);\n            m_archived_buffer = nullptr;\n            m_buffer_capacity = 0;\n        }\n\n        m_buffer_capacity = calculated_total_data_size;\n        if (m_buffer_capacity > 0) {\n            m_archived_buffer = (uint8_t*)malloc(m_buffer_capacity);\n            if (!m_archived_buffer) {\n                m_buffer_capacity = 0;\n                return false;\n            }\n        } else {\n            if (header->num_log_entries > 0) {\n                return false;\n            }\n            return true;\n        }\n\n        size_t current_raw_packet_offset = sizeof(SystemLogArchiveHeaderFixed);\n        size_t current_buffer_write_offset = 0;\n\n        for (uint16_t i = 0; i < header->num_log_entries; ++i) {\n            if (current_raw_packet_offset + sizeof(LogEntryHeaderFixed) > packet_len) {\n                free(m_archived_buffer); m_archived_buffer = nullptr; m_buffer_capacity = 0;\n                return false;\n            }\n\n            const LogEntryHeaderFixed* entry_header =\n                reinterpret_cast<const LogEntryHeaderFixed*>(raw_packet + current_raw_packet_offset);\n            \n            uint16_t entry_data_len = entry_header->compressed_data_len;\n            size_t entry_total_size = sizeof(LogEntryHeaderFixed) + entry_data_len;\n\n            if (current_raw_packet_offset + entry_total_size > packet_len) {\n                free(m_archived_buffer); m_archived_buffer = nullptr; m_buffer_capacity = 0;\n                return false;\n            }\n            \n            if (current_buffer_write_offset > (std::numeric_limits<size_t>::max() - entry_data_len) ||\n                current_buffer_write_offset + entry_data_len > m_buffer_capacity) {\n                free(m_archived_buffer); m_archived_buffer = nullptr; m_buffer_capacity = 0;\n                return false;\n            }\n\n            for (uint16_t k = 0; k < entry_data_len; ++k) {\n                m_archived_buffer[current_buffer_write_offset + k] = raw_packet[current_raw_packet_offset + sizeof(LogEntryHeaderFixed) + k];\n            }\n            current_buffer_write_offset += entry_data_len;\n\n            current_raw_packet_offset += entry_total_size;\n        }\n\n        if (current_buffer_write_offset != m_buffer_capacity) {\n            free(m_archived_buffer); m_archived_buffer = nullptr; m_buffer_capacity = 0;\n            return false;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getArchivedBuffer() const { return m_archived_buffer; }\n    size_t getBufferCapacity() const { return m_buffer_capacity; }\n\nprivate:\n    uint8_t* m_archived_buffer;\n    size_t m_buffer_capacity;\n};",
    "analysis": ""
  },
  {
    "cwe_id": "122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <new>\n\n#pragma pack(push, 1)\nstruct DiagnosticLogEntryHeader {\n    uint32_t timestamp;\n    uint16_t event_id;\n    uint16_t message_length; \n};\n#pragma pack(pop)\n\nclass AutomotiveDiagnosticLogVulnerable {\npublic:\n    AutomotiveDiagnosticLogVulnerable(size_t initial_buffer_capacity = 1024)\n        : m_log_buffer(nullptr), m_current_write_offset(0), m_allocated_capacity(0) {\n        if (initial_buffer_capacity > 0) {\n            m_log_buffer = (uint8_t*)malloc(initial_buffer_capacity);\n            if (m_log_buffer) {\n                m_allocated_capacity = initial_buffer_capacity;\n            }\n        }\n    }\n\n    ~AutomotiveDiagnosticLogVulnerable() {\n        if (m_log_buffer) {\n            free(m_log_buffer);\n            m_log_buffer = nullptr;\n        }\n    }\n\n    bool addLogEntryVulnerable(uint32_t timestamp, uint16_t event_id, const char* message) {\n        if (!message) {\n            return false;\n        }\n\n        uint16_t msg_len = static_cast<uint16_t>(strlen(message)); \n        static const uint16_t MAX_MESSAGE_LENGTH = 512;\n        if (msg_len > MAX_MESSAGE_LENGTH) {\n            return false;\n        }\n\n        size_t entry_header_size = sizeof(DiagnosticLogEntryHeader);\n        size_t required_space_for_payload = msg_len; \n        \n        if (m_current_write_offset > (SIZE_MAX - entry_header_size - required_space_for_payload)) {\n            return false;\n        }\n        size_t total_space_needed = entry_header_size + required_space_for_payload;\n\n        if (m_current_write_offset + total_space_needed > m_allocated_capacity) {\n            size_t new_capacity = m_allocated_capacity == 0 ? total_space_needed : m_allocated_capacity * 2;\n            if (new_capacity < m_current_write_offset + total_space_needed) {\n                new_capacity = m_current_write_offset + total_space_needed;\n            }\n            if (new_capacity > (16ULL * 1024 * 1024)) { \n                 if (total_space_needed > (16ULL * 1024 * 1024)) {\n                     return false;\n                 }\n                 new_capacity = (16ULL * 1024 * 1024);\n            }\n\n            uint8_t* new_buffer = (uint8_t*)realloc(m_log_buffer, new_capacity);\n            if (!new_buffer) {\n                if (m_log_buffer) {\n                    free(m_log_buffer);\n                    m_log_buffer = nullptr;\n                }\n                m_current_write_offset = 0;\n                m_allocated_capacity = 0;\n                return false;\n            }\n            m_log_buffer = new_buffer;\n            m_allocated_capacity = new_capacity;\n        }\n\n        DiagnosticLogEntryHeader header_to_write;\n        header_to_write.timestamp = timestamp;\n        header_to_write.event_id = event_id;\n        header_to_write.message_length = msg_len;\n\n        uint8_t* current_dest = m_log_buffer + m_current_write_offset;\n        memcpy(current_dest, &header_to_write, entry_header_size);\n        \n        for (uint16_t i = 0; i < msg_len; ++i) {\n            current_dest[entry_header_size + i] = message[i];\n        }\n\n        current_dest[entry_header_size + msg_len] = '\\0'; \n\n        m_current_write_offset += (entry_header_size + msg_len + 1); \n        \n        return true;\n    }\n\n    const uint8_t* getLogBuffer() const { return m_log_buffer; }\n    size_t getCurrentLogSize() const { return m_current_write_offset; }\n    size_t getAllocatedCapacity() const { return m_allocated_capacity; }\n\nprivate:\n    uint8_t* m_log_buffer;\n    size_t m_current_write_offset;\n    size_t m_allocated_capacity;\n}",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <new>\n#include <limits>\n\n#pragma pack(push, 1)\nstruct DiagnosticLogEntryHeaderFixed {\n    uint32_t timestamp;\n    uint16_t event_id;\n    uint16_t message_length; \n};\n#pragma pack(pop)\n\nclass AutomotiveDiagnosticLogFixed {\npublic:\n    AutomotiveDiagnosticLogFixed(size_t initial_buffer_capacity = 1024)\n        : m_log_buffer(nullptr), m_current_write_offset(0), m_allocated_capacity(0) {\n        if (initial_buffer_capacity > 0) {\n            m_log_buffer = (uint8_t*)malloc(initial_buffer_capacity);\n            if (m_log_buffer) {\n                m_allocated_capacity = initial_buffer_capacity;\n            }\n        }\n    }\n\n    ~AutomotiveDiagnosticLogFixed() {\n        if (m_log_buffer) {\n            free(m_log_buffer);\n            m_log_buffer = nullptr;\n        }\n    }\n\n    bool addLogEntryFixed(uint32_t timestamp, uint16_t event_id, const char* message) {\n        if (!message) {\n            return false;\n        }\n\n        uint16_t msg_len = static_cast<uint16_t>(strlen(message));\n        static const uint16_t MAX_MESSAGE_LENGTH = 512;\n        if (msg_len > MAX_MESSAGE_LENGTH) {\n            return false;\n        }\n\n        size_t entry_header_size = sizeof(DiagnosticLogEntryHeaderFixed);\n        \n        size_t required_space_for_payload;\n        if (msg_len == std::numeric_limits<uint16_t>::max()) {\n            return false;\n        }\n        required_space_for_payload = static_cast<size_t>(msg_len) + 1; \n        \n        if (entry_header_size > (SIZE_MAX - required_space_for_payload)) {\n            return false;\n        }\n        size_t total_space_needed = entry_header_size + required_space_for_payload;\n\n        if (m_current_write_offset > (SIZE_MAX - total_space_needed)) {\n            return false;\n        }\n\n        if (m_current_write_offset + total_space_needed > m_allocated_capacity) {\n            size_t new_capacity = m_allocated_capacity == 0 ? total_space_needed : m_allocated_capacity * 2;\n            if (m_allocated_capacity > (std::numeric_limits<size_t>::max() / 2) && m_allocated_capacity != 0) {\n                 new_capacity = std::numeric_limits<size_t>::max();\n            }\n\n            if (new_capacity < m_current_write_offset + total_space_needed) {\n                new_capacity = m_current_write_offset + total_space_needed;\n            }\n            \n            static const size_t MAX_TOTAL_BUFFER_CAPACITY = 16ULL * 1024 * 1024;\n            if (new_capacity > MAX_TOTAL_BUFFER_CAPACITY) {\n                 if (total_space_needed > MAX_TOTAL_BUFFER_CAPACITY) {\n                     return false;\n                 }\n                 new_capacity = MAX_TOTAL_BUFFER_CAPACITY;\n            }\n            if (new_capacity == 0 && total_space_needed > 0) return false;\n\n            uint8_t* new_buffer = (uint8_t*)realloc(m_log_buffer, new_capacity);\n            if (!new_buffer) {\n                if (m_log_buffer) {\n                    free(m_log_buffer);\n                    m_log_buffer = nullptr;\n                }\n                m_current_write_offset = 0;\n                m_allocated_capacity = 0;\n                return false;\n            }\n            m_log_buffer = new_buffer;\n            m_allocated_capacity = new_capacity;\n        }\n\n        DiagnosticLogEntryHeaderFixed header_to_write;\n        header_to_write.timestamp = timestamp;\n        header_to_write.event_id = event_id;\n        header_to_write.message_length = msg_len;\n\n        uint8_t* current_dest = m_log_buffer + m_current_write_offset;\n        memcpy(current_dest, &header_to_write, entry_header_size);\n        \n        memcpy(current_dest + entry_header_size, message, msg_len);\n\n        current_dest[entry_header_size + msg_len] = '\\0'; \n\n        m_current_write_offset += total_space_needed; \n        \n        return true;\n    }\n\n    const uint8_t* getLogBuffer() const { return m_log_buffer; }\n    size_t getCurrentLogSize() const { return m_current_write_offset; }\n    size_t getAllocatedCapacity() const { return m_allocated_capacity; }\n\nprivate:\n    uint8_t* m_log_buffer;\n    size_t m_current_write_offset;\n    size_t m_allocated_capacity;\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n\n#pragma pack(push, 1)\nstruct DiagnosticRecordHeaderVulnerable {\n    uint16_t record_id;\n    uint16_t record_length; \n};\n\nstruct DiagnosticStreamHeaderVulnerable {\n    uint32_t stream_id;\n    uint32_t num_records;\n};\n#pragma pack(pop)\n\nclass DiagnosticAggregatorVulnerable {\nprivate:\n    uint8_t* aggregated_buffer;\n    size_t current_buffer_pos;\n    size_t allocated_size;\n\npublic:\n    DiagnosticAggregatorVulnerable() : aggregated_buffer(nullptr), current_buffer_pos(0), allocated_size(0) {}\n    ~DiagnosticAggregatorVulnerable() {\n        if (aggregated_buffer) {\n            free(aggregated_buffer);\n        }\n    }\n\n    bool processDiagnosticStreamVulnerable(const uint8_t* stream_data, size_t stream_len) {\n        if (!stream_data || stream_len < sizeof(DiagnosticStreamHeaderVulnerable)) {\n            return false;\n        }\n\n        const DiagnosticStreamHeaderVulnerable* stream_header = reinterpret_cast<const DiagnosticStreamHeaderVulnerable*>(stream_data);\n\n        uint32_t pre_calculated_total_relevant_data_size_u32 = 0;\n        size_t current_offset = sizeof(DiagnosticStreamHeaderVulnerable);\n\n        for (uint32_t i = 0; i < stream_header->num_records; ++i) {\n            if (current_offset + sizeof(DiagnosticRecordHeaderVulnerable) > stream_len) {\n                return false;\n            }\n\n            const DiagnosticRecordHeaderVulnerable* record_header = reinterpret_cast<const DiagnosticRecordHeaderVulnerable*>(stream_data + current_offset);\n\n            if (current_offset + sizeof(DiagnosticRecordHeaderVulnerable) + record_header->record_length > stream_len) {\n                return false;\n            }\n\n            if (record_header->record_id == 0x1001 || record_header->record_id == 0x1002) {\n                pre_calculated_total_relevant_data_size_u32 += record_header->record_length;\n            }\n            current_offset += sizeof(DiagnosticRecordHeaderVulnerable) + record_header->record_length;\n        }\n\n        if (current_offset != stream_len) {\n            return false;\n        }\n\n        if (aggregated_buffer) {\n            free(aggregated_buffer);\n            aggregated_buffer = nullptr;\n        }\n        \n        allocated_size = pre_calculated_total_relevant_data_size_u32;\n        aggregated_buffer = (uint8_t*)malloc(allocated_size);\n        if (!aggregated_buffer && allocated_size > 0) {\n            return false;\n        }\n        current_buffer_pos = 0;\n\n        current_offset = sizeof(DiagnosticStreamHeaderVulnerable);\n        for (uint32_t i = 0; i < stream_header->num_records; ++i) {\n            const DiagnosticRecordHeaderVulnerable* record_header = reinterpret_cast<const DiagnosticRecordHeaderVulnerable*>(stream_data + current_offset);\n\n            if (record_header->record_id == 0x1001 || record_header->record_id == 0x1002) {\n                if (current_buffer_pos + record_header->record_length > allocated_size) {\n                    free(aggregated_buffer);\n                    aggregated_buffer = nullptr;\n                    allocated_size = 0;\n                    current_buffer_pos = 0;\n                    return false;\n                }\n                memcpy(aggregated_buffer + current_buffer_pos, stream_data + current_offset + sizeof(DiagnosticRecordHeaderVulnerable), record_header->record_length);\n                current_buffer_pos += record_header->record_length;\n            }\n            current_offset += sizeof(DiagnosticRecordHeaderVulnerable) + record_header->record_length;\n        }\n        \n        return true;\n    }\n\n    const uint8_t* getAggregatedBuffer() const { return aggregated_buffer; }\n    size_t getAggregatedSize() const { return current_buffer_pos; }\n    size_t getAllocatedSize() const { return allocated_size; }\n}",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <limits>\n\n#pragma pack(push, 1)\nstruct DiagnosticRecordHeaderFixed {\n    uint16_t record_id;\n    uint16_t record_length;\n};\n\nstruct DiagnosticStreamHeaderFixed {\n    uint32_t stream_id;\n    uint32_t num_records;\n};\n#pragma pack(pop)\n\nclass DiagnosticAggregatorFixed {\nprivate:\n    uint8_t* aggregated_buffer;\n    size_t current_buffer_pos;\n    size_t allocated_size;\n\npublic:\n    DiagnosticAggregatorFixed() : aggregated_buffer(nullptr), current_buffer_pos(0), allocated_size(0) {}\n    ~DiagnosticAggregatorFixed() {\n        if (aggregated_buffer) {\n            free(aggregated_buffer);\n        }\n    }\n\n    bool processDiagnosticStreamFixed(const uint8_t* stream_data, size_t stream_len) {\n        if (!stream_data || stream_len < sizeof(DiagnosticStreamHeaderFixed)) {\n            return false;\n        }\n\n        const DiagnosticStreamHeaderFixed* stream_header = reinterpret_cast<const DiagnosticStreamHeaderFixed*>(stream_data);\n\n        size_t calculated_total_relevant_data_size = 0;\n        size_t current_offset = sizeof(DiagnosticStreamHeaderFixed);\n\n        for (uint32_t i = 0; i < stream_header->num_records; ++i) {\n            if (current_offset > stream_len - sizeof(DiagnosticRecordHeaderFixed)) {\n                return false;\n            }\n\n            const DiagnosticRecordHeaderFixed* record_header = reinterpret_cast<const DiagnosticRecordHeaderFixed*>(stream_data + current_offset);\n\n            if (record_header->record_length > (std::numeric_limits<size_t>::max() - sizeof(DiagnosticRecordHeaderFixed))) {\n                return false;\n            }\n\n            if (current_offset > stream_len - (sizeof(DiagnosticRecordHeaderFixed) + record_header->record_length)) {\n                return false;\n            }\n\n            if (record_header->record_id == 0x1001 || record_header->record_id == 0x1002) {\n                size_t current_record_len = static_cast<size_t>(record_header->record_length);\n                if (calculated_total_relevant_data_size > std::numeric_limits<size_t>::max() - current_record_len) {\n                    return false;\n                }\n                calculated_total_relevant_data_size += current_record_len;\n            }\n            current_offset += sizeof(DiagnosticRecordHeaderFixed) + record_header->record_length;\n        }\n\n        if (current_offset != stream_len) {\n            return false;\n        }\n\n        if (calculated_total_relevant_data_size == 0) {\n            if (aggregated_buffer) {\n                free(aggregated_buffer);\n                aggregated_buffer = nullptr;\n            }\n            allocated_size = 0;\n            current_buffer_pos = 0;\n            return true;\n        }\n        \n        if (aggregated_buffer) {\n            free(aggregated_buffer);\n            aggregated_buffer = nullptr;\n        }\n        allocated_size = calculated_total_relevant_data_size;\n        aggregated_buffer = (uint8_t*)malloc(allocated_size);\n        if (!aggregated_buffer) {\n            allocated_size = 0;\n            return false;\n        }\n        current_buffer_pos = 0;\n\n        current_offset = sizeof(DiagnosticStreamHeaderFixed);\n        for (uint32_t i = 0; i < stream_header->num_records; ++i) {\n            const DiagnosticRecordHeaderFixed* record_header = reinterpret_cast<const DiagnosticRecordHeaderFixed*>(stream_data + current_offset);\n\n            if (record_header->record_id == 0x1001 || record_header->record_id == 0x1002) {\n                size_t current_record_len = static_cast<size_t>(record_header->record_length);\n\n                if (current_buffer_pos > allocated_size - current_record_len) {\n                    free(aggregated_buffer);\n                    aggregated_buffer = nullptr;\n                    allocated_size = 0;\n                    current_buffer_pos = 0;\n                    return false;\n                }\n                memcpy(aggregated_buffer + current_buffer_pos, stream_data + current_offset + sizeof(DiagnosticRecordHeaderFixed), current_record_len);\n                current_buffer_pos += current_record_len;\n            }\n            current_offset += sizeof(DiagnosticRecordHeaderFixed) + record_header->record_length;\n        }\n        \n        if (current_buffer_pos != calculated_total_relevant_data_size) {\n            free(aggregated_buffer);\n            aggregated_buffer = nullptr;\n            allocated_size = 0;\n            current_buffer_pos = 0;\n            return false;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getAggregatedBuffer() const { return aggregated_buffer; }\n    size_t getAggregatedSize() const { return current_buffer_pos; }\n    size_t getAllocatedSize() const { return allocated_size; }\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <new>\n\n#pragma pack(push, 1)\nstruct SensorPacketHeaderVulnerable {\n    uint16_t packet_id;\n    uint16_t total_decoded_values; \n    uint16_t encoded_payload_size; \n};\n#pragma pack(pop)\n\n#define MAX_DECODED_DATA_LEN_BYTES 1024 * 1024 \n\nclass SensorDataProcessorVulnerable {\npublic:\n    SensorDataProcessorVulnerable() : m_decoded_buffer(nullptr), m_buffer_capacity(0), m_current_values_count(0) {}\n\n    ~SensorDataProcessorVulnerable() {\n        if (m_decoded_buffer) {\n            free(m_decoded_buffer);\n        }\n    }\n\n    void resetBuffer() {\n        if (m_decoded_buffer) {\n            free(m_decoded_buffer);\n            m_decoded_buffer = nullptr;\n        }\n        m_buffer_capacity = 0;\n        m_current_values_count = 0;\n    }\n\n    bool decodeSensorDataVulnerable(const uint8_t* raw_packet, size_t packet_len) {\n        if (!raw_packet || packet_len < sizeof(SensorPacketHeaderVulnerable)) {\n            return false;\n        }\n\n        const SensorPacketHeaderVulnerable* header = reinterpret_cast<const SensorPacketHeaderVulnerable*>(raw_packet);\n\n        if (packet_len < sizeof(SensorPacketHeaderVulnerable) + header->encoded_payload_size) {\n            return false;\n        }\n\n        size_t desired_alloc_bytes = (size_t)header->total_decoded_values * sizeof(uint32_t);\n\n        if (desired_alloc_bytes > MAX_DECODED_DATA_LEN_BYTES) {\n            return false;\n        }\n        \n        resetBuffer(); \n\n        if (desired_alloc_bytes > 0) {\n            m_decoded_buffer = (uint32_t*)malloc(desired_alloc_bytes);\n            if (!m_decoded_buffer) {\n                return false;\n            }\n            m_buffer_capacity = desired_alloc_bytes;\n        } else {\n            return true;\n        }\n\n        const uint8_t* encoded_data_ptr = raw_packet + sizeof(SensorPacketHeaderVulnerable);\n        size_t current_encoded_offset = 0;\n        m_current_values_count = 0; \n\n        uint32_t last_decoded_value = 0;\n\n        while (current_encoded_offset < header->encoded_payload_size) {\n            if (m_current_values_count >= header->total_decoded_values) {\n                resetBuffer();\n                return false; \n            }\n\n            uint8_t delta_type_byte = encoded_data_ptr[current_encoded_offset];\n            current_encoded_offset++;\n\n            if (delta_type_byte <= 0x7F) {\n                uint32_t delta = delta_type_byte;\n                last_decoded_value += delta;\n                m_decoded_buffer[m_current_values_count++] = last_decoded_value;\n            } else if (delta_type_byte >= 0x80 && delta_type_byte <= 0xBF) {\n                if (current_encoded_offset + 1 > header->encoded_payload_size) {\n                    resetBuffer();\n                    return false;\n                }\n                uint32_t delta = (delta_type_byte & 0x3F) << 8 | encoded_data_ptr[current_encoded_offset];\n                current_encoded_offset += 1;\n                last_decoded_value += delta;\n                m_decoded_buffer[m_current_values_count++] = last_decoded_value;\n            } else if (delta_type_byte >= 0xC0 && delta_type_byte <= 0xDF) {\n                if (current_encoded_offset + 3 > header->encoded_payload_size) {\n                    resetBuffer();\n                    return false;\n                }\n                uint32_t delta = (delta_type_byte & 0x1F) << 24 |\n                                 encoded_data_ptr[current_encoded_offset] << 16 |\n                                 encoded_data_ptr[current_encoded_offset + 1] << 8 |\n                                 encoded_data_ptr[current_encoded_offset + 2];\n                current_encoded_offset += 3;\n                last_decoded_value += delta;\n                m_decoded_buffer[m_current_values_count++] = last_decoded_value;\n            } else if (delta_type_byte == 0xE0) {\n                if (current_encoded_offset + 1 > header->encoded_payload_size) {\n                    resetBuffer();\n                    return false;\n                }\n                uint8_t repeat_count = encoded_data_ptr[current_encoded_offset];\n                current_encoded_offset++;\n\n                for (uint8_t k = 0; k < repeat_count; ++k) {\n                    m_decoded_buffer[m_current_values_count++] = last_decoded_value;\n                }\n            } else {\n                resetBuffer();\n                return false;\n            }\n        }\n\n        if (m_current_values_count != header->total_decoded_values) {\n            resetBuffer();\n            return false;\n        }\n\n        return true;\n    }\n\n    const uint32_t* getDecodedData() const { return m_decoded_buffer; }\n    size_t getCurrentValuesCount() const { return m_current_values_count; }\n    size_t getBufferCapacityBytes() const { return m_buffer_capacity; }\n\nprivate:\n    uint32_t* m_decoded_buffer;\n    size_t m_buffer_capacity;\n    size_t m_current_values_count; \n};",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <new>\n#include <limits>\n\n#pragma pack(push, 1)\nstruct SensorPacketHeaderFixed {\n    uint16_t packet_id;\n    uint16_t total_decoded_values; \n    uint16_t encoded_payload_size; \n};\n#pragma pack(pop)\n\n#define MAX_DECODED_DATA_LEN_BYTES_FIXED 1024 * 1024 \n\nclass SensorDataProcessorFixed {\npublic:\n    SensorDataProcessorFixed() : m_decoded_buffer(nullptr), m_buffer_capacity(0), m_current_values_count(0) {}\n\n    ~SensorDataProcessorFixed() {\n        if (m_decoded_buffer) {\n            free(m_decoded_buffer);\n        }\n    }\n\n    void resetBuffer() {\n        if (m_decoded_buffer) {\n            free(m_decoded_buffer);\n            m_decoded_buffer = nullptr;\n        }\n        m_buffer_capacity = 0;\n        m_current_values_count = 0;\n    }\n\n    bool decodeSensorDataFixed(const uint8_t* raw_packet, size_t packet_len) {\n        if (!raw_packet || packet_len < sizeof(SensorPacketHeaderFixed)) {\n            return false;\n        }\n\n        const SensorPacketHeaderFixed* header = reinterpret_cast<const SensorPacketHeaderFixed*>(raw_packet);\n\n        if (packet_len < sizeof(SensorPacketHeaderFixed) + header->encoded_payload_size) {\n            return false;\n        }\n\n        size_t calculated_max_decoded_values = 0;\n        size_t current_encoded_offset_calc = 0;\n        const uint8_t* encoded_data_ptr_calc = raw_packet + sizeof(SensorPacketHeaderFixed);\n\n        while (current_encoded_offset_calc < header->encoded_payload_size) {\n            if (current_encoded_offset_calc + 1 > header->encoded_payload_size) {\n                return false; \n            }\n            uint8_t delta_type_byte = encoded_data_ptr_calc[current_encoded_offset_calc];\n            current_encoded_offset_calc++;\n\n            if (delta_type_byte <= 0x7F) {\n                if (calculated_max_decoded_values > std::numeric_limits<size_t>::max() - 1) return false; \n                calculated_max_decoded_values++;\n            } else if (delta_type_byte >= 0x80 && delta_type_byte <= 0xBF) {\n                if (current_encoded_offset_calc + 1 > header->encoded_payload_size) return false;\n                if (calculated_max_decoded_values > std::numeric_limits<size_t>::max() - 1) return false;\n                calculated_max_decoded_values++;\n                current_encoded_offset_calc += 1;\n            } else if (delta_type_byte >= 0xC0 && delta_type_byte <= 0xDF) {\n                if (current_encoded_offset_calc + 3 > header->encoded_payload_size) return false;\n                if (calculated_max_decoded_values > std::numeric_limits<size_t>::max() - 1) return false;\n                calculated_max_decoded_values++;\n                current_encoded_offset_calc += 3;\n            } else if (delta_type_byte == 0xE0) {\n                if (current_encoded_offset_calc + 1 > header->encoded_payload_size) return false;\n                uint8_t repeat_count = encoded_data_ptr_calc[current_encoded_offset_calc];\n                current_encoded_offset_calc++;\n                \n                if (calculated_max_decoded_values > std::numeric_limits<size_t>::max() - repeat_count) {\n                    return false;\n                }\n                calculated_max_decoded_values += repeat_count;\n            } else {\n                return false; \n            }\n        }\n\n        if (header->total_decoded_values < calculated_max_decoded_values) {\n            return false;\n        }\n\n        if ((size_t)header->total_decoded_values * sizeof(uint32_t) > MAX_DECODED_DATA_LEN_BYTES_FIXED) {\n            return false;\n        }\n\n        size_t desired_alloc_bytes = (size_t)header->total_decoded_values * sizeof(uint32_t);\n        \n        resetBuffer();\n\n        if (desired_alloc_bytes > 0) {\n            m_decoded_buffer = (uint32_t*)malloc(desired_alloc_bytes);\n            if (!m_decoded_buffer) {\n                return false;\n            }\n            m_buffer_capacity = desired_alloc_bytes;\n        } else {\n            return true;\n        }\n\n        const uint8_t* encoded_data_ptr = raw_packet + sizeof(SensorPacketHeaderFixed);\n        size_t current_encoded_offset = 0;\n        m_current_values_count = 0; \n\n        uint32_t last_decoded_value = 0; \n\n        while (current_encoded_offset < header->encoded_payload_size) {\n            if (m_current_values_count >= header->total_decoded_values) {\n                resetBuffer();\n                return false; \n            }\n\n            uint8_t delta_type_byte = encoded_data_ptr[current_encoded_offset];\n            current_encoded_offset++;\n\n            if (delta_type_byte <= 0x7F) {\n                uint32_t delta = delta_type_byte;\n                last_decoded_value += delta;\n                m_decoded_buffer[m_current_values_count++] = last_decoded_value;\n            } else if (delta_type_byte >= 0x80 && delta_type_byte <= 0xBF) {\n                if (current_encoded_offset + 1 > header->encoded_payload_size) { resetBuffer(); return false; }\n                uint32_t delta = (delta_type_byte & 0x3F) << 8 | encoded_data_ptr[current_encoded_offset];\n                current_encoded_offset += 1;\n                last_decoded_value += delta;\n                m_decoded_buffer[m_current_values_count++] = last_decoded_value;\n            } else if (delta_type_byte >= 0xC0 && delta_type_byte <= 0xDF) {\n                if (current_encoded_offset + 3 > header->encoded_payload_size) { resetBuffer(); return false; }\n                uint32_t delta = (delta_type_byte & 0x1F) << 24 |\n                                 encoded_data_ptr[current_encoded_offset] << 16 |\n                                 encoded_data_ptr[current_encoded_offset + 1] << 8 |\n                                 encoded_data_ptr[current_encoded_offset + 2];\n                current_encoded_offset += 3;\n                last_decoded_value += delta;\n                m_decoded_buffer[m_current_values_count++] = last_decoded_value;\n            } else if (delta_type_byte == 0xE0) {\n                if (current_encoded_offset + 1 > header->encoded_payload_size) { resetBuffer(); return false; }\n                uint8_t repeat_count = encoded_data_ptr[current_encoded_offset];\n                current_encoded_offset++;\n\n                if (m_current_values_count > header->total_decoded_values - repeat_count) {\n                    resetBuffer();\n                    return false;\n                }\n\n                for (uint8_t k = 0; k < repeat_count; ++k) {\n                    m_decoded_buffer[m_current_values_count++] = last_decoded_value;\n                }\n            } else {\n                resetBuffer();\n                return false;\n            }\n        }\n\n        if (m_current_values_count != header->total_decoded_values) {\n            resetBuffer(); \n            return false;\n        }\n\n        return true;\n    }\n\n    const uint32_t* getDecodedData() const { return m_decoded_buffer; }\n    size_t getCurrentValuesCount() const { return m_current_values_count; }\n    size_t getBufferCapacityBytes() const { return m_buffer_capacity; }\n\nprivate:\n    uint32_t* m_decoded_buffer;\n    size_t m_buffer_capacity; \n    size_t m_current_values_count;\n};",
    "analysis": ""
  },
  {
    "cwe_id": "122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n\n#pragma pack(push, 1)\nstruct DTCPacketHeader {\n    uint16_t num_dtc_entries;\n    uint32_t total_descriptions_payload_length; \n};\n\nstruct DTCEntryHeader {\n    uint16_t dtc_id;\n    uint16_t description_length; \n};\n#pragma pack(pop)\n\nclass DTCLogManagerVulnerable {\npublic:\n    DTCLogManagerVulnerable() : m_log_buffer(nullptr), m_buffer_capacity(0), m_current_offset(0) {}\n\n    ~DTCLogManagerVulnerable() {\n        if (m_log_buffer) {\n            free(m_log_buffer);\n        }\n    }\n\n    bool processDTCPacketVulnerable(const uint8_t* packet_data, size_t packet_len) {\n        if (!packet_data || packet_len < sizeof(DTCPacketHeader)) {\n            return false;\n        }\n\n        const DTCPacketHeader* packet_header = reinterpret_cast<const DTCPacketHeader*>(packet_data);\n\n        size_t required_buffer_size = packet_header->total_descriptions_payload_length;\n\n        if (m_log_buffer == nullptr || required_buffer_size > m_buffer_capacity) {\n            if (m_log_buffer) {\n                free(m_log_buffer);\n            }\n            m_log_buffer = (char*)malloc(required_buffer_size);\n            if (!m_log_buffer && required_buffer_size > 0) {\n                m_buffer_capacity = 0;\n                return false;\n            }\n            m_buffer_capacity = required_buffer_size;\n            m_current_offset = 0; \n        } else if (required_buffer_size == 0) {\n            if (m_log_buffer) {\n                free(m_log_buffer);\n                m_log_buffer = nullptr;\n            }\n            m_buffer_capacity = 0;\n            m_current_offset = 0;\n            return true;\n        }\n\n\n        const uint8_t* current_read_ptr = packet_data + sizeof(DTCPacketHeader);\n        size_t remaining_packet_bytes = packet_len - sizeof(DTCPacketHeader);\n\n        for (uint16_t i = 0; i < packet_header->num_dtc_entries; ++i) {\n            if (remaining_packet_bytes < sizeof(DTCEntryHeader)) {\n                return false;\n            }\n\n            const DTCEntryHeader* entry_header = reinterpret_cast<const DTCEntryHeader*>(current_read_ptr);\n            uint16_t description_len = entry_header->description_length;\n\n            if (remaining_packet_bytes < sizeof(DTCEntryHeader) + description_len) {\n                return false;\n            }\n\n            if (m_current_offset + description_len + 1 > m_buffer_capacity) {\n                return false;\n            }\n            \n            char* dest_ptr = m_log_buffer + m_current_offset;\n            memcpy(dest_ptr, current_read_ptr + sizeof(DTCEntryHeader), description_len);\n            dest_ptr[description_len] = '\\0';\n\n            m_current_offset += (description_len + 1);\n\n            current_read_ptr += (sizeof(DTCEntryHeader) + description_len);\n            remaining_packet_bytes -= (sizeof(DTCEntryHeader) + description_len);\n        }\n\n        if (m_current_offset > m_buffer_capacity) {\n            return false;\n        }\n\n        return true;\n    }\n\n    const char* getLogBuffer() const { return m_log_buffer; }\n    size_t getBufferCapacity() const { return m_buffer_capacity; }\n\nprivate:\n    char* m_log_buffer;\n    size_t m_buffer_capacity;\n    size_t m_current_offset;\n}",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <numeric>\n#include <limits>\n\n#pragma pack(push, 1)\nstruct DTCPacketHeaderFixed {\n    uint16_t num_dtc_entries;\n    uint32_t total_descriptions_payload_length; \n};\n\nstruct DTCEntryHeaderFixed {\n    uint16_t dtc_id;\n    uint16_t description_length; \n};\n#pragma pack(pop)\n\nclass DTCLogManagerFixed {\npublic:\n    DTCLogManagerFixed() : m_log_buffer(nullptr), m_buffer_capacity(0), m_current_offset(0) {}\n\n    ~DTCLogManagerFixed() {\n        if (m_log_buffer) {\n            free(m_log_buffer);\n        }\n    }\n\n    bool processDTCPacketFixed(const uint8_t* packet_data, size_t packet_len) {\n        if (!packet_data || packet_len < sizeof(DTCPacketHeaderFixed)) {\n            return false;\n        }\n\n        const DTCPacketHeaderFixed* packet_header = reinterpret_cast<const DTCPacketHeaderFixed*>(packet_data);\n\n        if (static_cast<size_t>(packet_header->total_descriptions_payload_length) > (packet_len - sizeof(DTCPacketHeaderFixed))) {\n            return false;\n        }\n\n        size_t calculated_total_required_size = 0;\n        const uint8_t* scan_ptr = packet_data + sizeof(DTCPacketHeaderFixed);\n        size_t remaining_scan_bytes = packet_len - sizeof(DTCPacketHeaderFixed);\n\n        for (uint16_t i = 0; i < packet_header->num_dtc_entries; ++i) {\n            if (remaining_scan_bytes < sizeof(DTCEntryHeaderFixed)) {\n                return false;\n            }\n\n            const DTCEntryHeaderFixed* entry_header = reinterpret_cast<const DTCEntryHeaderFixed*>(scan_ptr);\n            uint16_t description_len = entry_header->description_length;\n\n            if (description_len == std::numeric_limits<uint16_t>::max() || \n                calculated_total_required_size > std::numeric_limits<size_t>::max() - (static_cast<size_t>(description_len) + 1)) {\n                return false;\n            }\n            calculated_total_required_size += (static_cast<size_t>(description_len) + 1); \n\n            size_t entry_full_size_in_packet = sizeof(DTCEntryHeaderFixed) + description_len;\n            if (remaining_scan_bytes < entry_full_size_in_packet) {\n                return false;\n            }\n            scan_ptr += entry_full_size_in_packet;\n            remaining_scan_bytes -= entry_full_size_in_packet;\n        }\n\n        if (calculated_total_required_size - packet_header->num_dtc_entries != packet_header->total_descriptions_payload_length) {\n            return false;\n        }\n\n        if (m_log_buffer == nullptr || calculated_total_required_size > m_buffer_capacity) {\n            if (m_log_buffer) {\n                free(m_log_buffer);\n            }\n            m_log_buffer = (char*)malloc(calculated_total_required_size);\n            if (!m_log_buffer && calculated_total_required_size > 0) {\n                m_buffer_capacity = 0;\n                return false;\n            }\n            m_buffer_capacity = calculated_total_required_size;\n            m_current_offset = 0;\n        } else if (calculated_total_required_size == 0) {\n            if (m_log_buffer) {\n                free(m_log_buffer);\n                m_log_buffer = nullptr;\n            }\n            m_buffer_capacity = 0;\n            m_current_offset = 0;\n            return true;\n        }\n        \n        const uint8_t* current_read_ptr = packet_data + sizeof(DTCPacketHeaderFixed);\n        size_t remaining_packet_bytes = packet_len - sizeof(DTCPacketHeaderFixed);\n\n        for (uint16_t i = 0; i < packet_header->num_dtc_entries; ++i) {\n            if (remaining_packet_bytes < sizeof(DTCEntryHeaderFixed)) {\n                return false;\n            }\n\n            const DTCEntryHeaderFixed* entry_header = reinterpret_cast<const DTCEntryHeaderFixed*>(current_read_ptr);\n            uint16_t description_len = entry_header->description_length;\n\n            size_t full_entry_size = sizeof(DTCEntryHeaderFixed) + description_len;\n            if (remaining_packet_bytes < full_entry_size) {\n                return false;\n            }\n            \n            if (m_current_offset > std::numeric_limits<size_t>::max() - (static_cast<size_t>(description_len) + 1) ||\n                m_current_offset + static_cast<size_t>(description_len) + 1 > m_buffer_capacity) {\n                return false;\n            }\n            \n            char* dest_ptr = m_log_buffer + m_current_offset;\n            memcpy(dest_ptr, current_read_ptr + sizeof(DTCEntryHeaderFixed), description_len);\n            dest_ptr[description_len] = '\\0'; \n\n            m_current_offset += (static_cast<size_t>(description_len) + 1);\n\n            current_read_ptr += full_entry_size;\n            remaining_packet_bytes -= full_entry_size;\n        }\n\n        if (m_current_offset != m_buffer_capacity) {\n            return false;\n        }\n\n        return true;\n    }\n\n    const char* getLogBuffer() const { return m_log_buffer; }\n    size_t getBufferCapacity() const { return m_buffer_capacity; }\n\nprivate:\n    char* m_log_buffer;\n    size_t m_buffer_capacity;\n    size_t m_current_offset;\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <new>\n\n#pragma pack(push, 1)\nstruct InboundParamHeaderVulnerable {\n    uint16_t param_id;\n    uint16_t param_data_len; \n};\n\nstruct InboundConfigPacketHeaderVulnerable {\n    uint32_t packet_timestamp;\n    uint16_t num_parameters;\n    uint32_t total_payload_data_bytes; \n};\n#pragma pack(pop)\n\n#pragma pack(push, 1)\nstruct StoredParamEntryHeaderVulnerable {\n    uint16_t stored_id;\n    uint16_t stored_length; \n};\n#pragma pack(pop)\n\nclass ECUConfigUpdaterVulnerable {\npublic:\n    ECUConfigUpdaterVulnerable() : m_config_buffer(nullptr), m_buffer_size(0), m_allocated_capacity(0) {}\n\n    ~ECUConfigUpdaterVulnerable() {\n        if (m_config_buffer) {\n            free(m_config_buffer);\n        }\n    }\n\n    bool processConfigurationPacketVulnerable(const uint8_t* raw_packet, size_t packet_length) {\n        if (!raw_packet || packet_length < sizeof(InboundConfigPacketHeaderVulnerable)) {\n            return false;\n        }\n\n        const InboundConfigPacketHeaderVulnerable* packet_hdr =\n            reinterpret_cast<const InboundConfigPacketHeaderVulnerable*>(raw_packet);\n\n        size_t current_read_offset = sizeof(InboundConfigPacketHeaderVulnerable);\n        uint32_t verified_total_payload_bytes = 0;\n\n        for (uint16_t i = 0; i < packet_hdr->num_parameters; ++i) {\n            if (current_read_offset + sizeof(InboundParamHeaderVulnerable) > packet_length) {\n                return false;\n            }\n\n            const InboundParamHeaderVulnerable* param_hdr =\n                reinterpret_cast<const InboundParamHeaderVulnerable*>(raw_packet + current_read_offset);\n\n            if (current_read_offset + sizeof(InboundParamHeaderVulnerable) + param_hdr->param_data_len > packet_length) {\n                return false;\n            }\n            \n            if (verified_total_payload_bytes > (UINT32_MAX - param_hdr->param_data_len)) {\n                return false;\n            }\n            verified_total_payload_bytes += param_hdr->param_data_len;\n\n            current_read_offset += sizeof(InboundParamHeaderVulnerable) + param_hdr->param_data_len;\n        }\n\n        if (verified_total_payload_bytes != packet_hdr->total_payload_data_bytes) {\n            return false;\n        }\n        \n        m_allocated_capacity = packet_hdr->total_payload_data_bytes; \n        \n        if (m_config_buffer) {\n            free(m_config_buffer);\n            m_config_buffer = nullptr;\n        }\n\n        if (m_allocated_capacity > 0) {\n            m_config_buffer = (uint8_t*)malloc(m_allocated_capacity);\n            if (!m_config_buffer) {\n                m_buffer_size = 0;\n                m_allocated_capacity = 0;\n                return false;\n            }\n        } else {\n            m_config_buffer = nullptr;\n        }\n\n        m_buffer_size = 0;\n        current_read_offset = sizeof(InboundConfigPacketHeaderVulnerable);\n\n        for (uint16_t i = 0; i < packet_hdr->num_parameters; ++i) {\n            const InboundParamHeaderVulnerable* param_hdr =\n                reinterpret_cast<const InboundParamHeaderVulnerable*>(raw_packet + current_read_offset);\n\n            size_t current_entry_stored_size = sizeof(StoredParamEntryHeaderVulnerable) + param_hdr->param_data_len;\n\n            if (m_buffer_size + current_entry_stored_size > m_allocated_capacity) {\n                free(m_config_buffer);\n                m_config_buffer = nullptr;\n                m_buffer_size = 0;\n                m_allocated_capacity = 0;\n                return false;\n            }\n\n            StoredParamEntryHeaderVulnerable* stored_entry_hdr =\n                reinterpret_cast<StoredParamEntryHeaderVulnerable*>(m_config_buffer + m_buffer_size);\n            stored_entry_hdr->stored_id = param_hdr->param_id;\n            stored_entry_hdr->stored_length = param_hdr->param_data_len;\n            m_buffer_size += sizeof(StoredParamEntryHeaderVulnerable);\n\n            memcpy(m_config_buffer + m_buffer_size,\n                   raw_packet + current_read_offset + sizeof(InboundParamHeaderVulnerable),\n                   param_hdr->param_data_len);\n            m_buffer_size += param_hdr->param_data_len;\n\n            current_read_offset += sizeof(InboundParamHeaderVulnerable) + param_hdr->param_data_len;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getConfigBuffer() const { return m_config_buffer; }\n    size_t getBufferSize() const { return m_buffer_size; }\n    size_t getAllocatedCapacity() const { return m_allocated_capacity; }\n\nprivate:\n    uint8_t* m_config_buffer;\n    size_t m_buffer_size;\n    size_t m_allocated_capacity;\n};",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <new>\n#include <limits>\n\n#pragma pack(push, 1)\nstruct InboundParamHeaderFixed {\n    uint16_t param_id;\n    uint16_t param_data_len; \n};\n\nstruct InboundConfigPacketHeaderFixed {\n    uint32_t packet_timestamp;\n    uint16_t num_parameters;\n    uint32_t total_payload_data_bytes; \n};\n#pragma pack(pop)\n\n#pragma pack(push, 1)\nstruct StoredParamEntryHeaderFixed {\n    uint16_t stored_id;\n    uint16_t stored_length; \n};\n#pragma pack(pop)\n\nclass ECUConfigUpdaterFixed {\npublic:\n    ECUConfigUpdaterFixed() : m_config_buffer(nullptr), m_buffer_size(0), m_allocated_capacity(0) {}\n\n    ~ECUConfigUpdaterFixed() {\n        if (m_config_buffer) {\n            free(m_config_buffer);\n        }\n    }\n\n    bool processConfigurationPacketFixed(const uint8_t* raw_packet, size_t packet_length) {\n        if (!raw_packet || packet_length < sizeof(InboundConfigPacketHeaderFixed)) {\n            return false;\n        }\n\n        const InboundConfigPacketHeaderFixed* packet_hdr =\n            reinterpret_cast<const InboundConfigPacketHeaderFixed*>(raw_packet);\n\n        size_t current_read_offset = sizeof(InboundConfigPacketHeaderFixed);\n        uint32_t verified_total_payload_bytes = 0;\n        \n        size_t total_required_internal_buffer_size = 0;\n\n        for (uint16_t i = 0; i < packet_hdr->num_parameters; ++i) {\n            if (current_read_offset + sizeof(InboundParamHeaderFixed) > packet_length) {\n                return false;\n            }\n\n            const InboundParamHeaderFixed* param_hdr =\n                reinterpret_cast<const InboundParamHeaderFixed*>(raw_packet + current_read_offset);\n\n            if (current_read_offset + sizeof(InboundParamHeaderFixed) + param_hdr->param_data_len > packet_length) {\n                return false;\n            }\n            \n            if (verified_total_payload_bytes > (std::numeric_limits<uint32_t>::max() - param_hdr->param_data_len)) {\n                return false;\n            }\n            verified_total_payload_bytes += param_hdr->param_data_len;\n\n            if (total_required_internal_buffer_size > (std::numeric_limits<size_t>::max() - (sizeof(StoredParamEntryHeaderFixed) + param_hdr->param_data_len))) {\n                return false;\n            }\n            total_required_internal_buffer_size += sizeof(StoredParamEntryHeaderFixed) + param_hdr->param_data_len;\n\n            current_read_offset += sizeof(InboundParamHeaderFixed) + param_hdr->param_data_len;\n        }\n\n        if (verified_total_payload_bytes != packet_hdr->total_payload_data_bytes) {\n            return false;\n        }\n        \n        m_allocated_capacity = total_required_internal_buffer_size; \n        \n        if (m_config_buffer) {\n            free(m_config_buffer);\n            m_config_buffer = nullptr;\n        }\n\n        if (m_allocated_capacity > 0) {\n            m_config_buffer = (uint8_t*)malloc(m_allocated_capacity);\n            if (!m_config_buffer) {\n                m_buffer_size = 0;\n                m_allocated_capacity = 0;\n                return false;\n            }\n        } else {\n            m_config_buffer = nullptr;\n        }\n\n        m_buffer_size = 0;\n        current_read_offset = sizeof(InboundConfigPacketHeaderFixed);\n\n        for (uint16_t i = 0; i < packet_hdr->num_parameters; ++i) {\n            const InboundParamHeaderFixed* param_hdr =\n                reinterpret_cast<const InboundParamHeaderFixed*>(raw_packet + current_read_offset);\n\n            size_t current_entry_stored_size = sizeof(StoredParamEntryHeaderFixed) + param_hdr->param_data_len;\n\n            if (m_buffer_size > (m_allocated_capacity - current_entry_stored_size)) {\n                 free(m_config_buffer);\n                 m_config_buffer = nullptr;\n                 m_buffer_size = 0;\n                 m_allocated_capacity = 0;\n                 return false;\n            }\n\n            StoredParamEntryHeaderFixed* stored_entry_hdr =\n                reinterpret_cast<StoredParamEntryHeaderFixed*>(m_config_buffer + m_buffer_size);\n            stored_entry_hdr->stored_id = param_hdr->param_id;\n            stored_entry_hdr->stored_length = param_hdr->param_data_len;\n            m_buffer_size += sizeof(StoredParamEntryHeaderFixed);\n\n            memcpy(m_config_buffer + m_buffer_size,\n                   raw_packet + current_read_offset + sizeof(InboundParamHeaderFixed),\n                   param_hdr->param_data_len);\n            m_buffer_size += param_hdr->param_data_len;\n\n            current_read_offset += sizeof(InboundParamHeaderFixed) + param_hdr->param_data_len;\n        }\n\n        if (m_buffer_size != m_allocated_capacity) {\n            free(m_config_buffer);\n            m_config_buffer = nullptr;\n            m_buffer_size = 0;\n            m_allocated_capacity = 0;\n            return false;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getConfigBuffer() const { return m_config_buffer; }\n    size_t getBufferSize() const { return m_buffer_size; }\n    size_t getAllocatedCapacity() const { return m_allocated_capacity; }\n\nprivate:\n    uint8_t* m_config_buffer;\n    size_t m_buffer_size;\n    size_t m_allocated_capacity;\n};",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <new>\n#include <limits>\n\n// A simple sensor reading structure typical in automotive (timestamp + value)\nstruct SensorReading {\n    uint32_t timestamp;\n    uint32_t sensor_value;\n};\n\nclass DiagnosticRecorderVulnerable {\npublic:\n    DiagnosticRecorderVulnerable() : m_raw_data_buffer(nullptr), m_data_count(0), m_allocated_bytes(0) {}\n\n    ~DiagnosticRecorderVulnerable() {\n        if (m_raw_data_buffer) {\n            free(m_raw_data_buffer);\n        }\n    }\n\n    // Records a new diagnostic entry\n    // Vulnerability: Integer overflow in size calculation for realloc.\n    // If 'm_data_count' is large enough, the 'new_total_size_u32' calculation\n    // can overflow, leading to 'realloc' receiving a much smaller size than needed.\n    // Subsequent 'memcpy' will then write beyond the heap boundary.\n    bool recordDiagnosticEntryVulnerable(uint32_t timestamp, uint32_t value) {\n        SensorReading entry = {timestamp, value};\n        uint32_t entry_size = sizeof(SensorReading);\n\n        // Calculate the number of bytes needed for the next allocation.\n        // This calculation is performed using uint32_t, which has a smaller range\n        // than size_t on 64-bit systems.\n        uint32_t new_logical_count_u32 = m_data_count + 1;\n\n        // VULNERABILITY: If (new_logical_count_u32 * entry_size) overflows uint32_t,\n        // it wraps around to a small value. This small value is then used for allocation.\n        uint32_t new_total_size_u32 = new_logical_count_u32 * entry_size;\n\n        // On a 64-bit system, new_total_size_u32 (uint32_t) might be e.g. 0x00001000\n        // when the true size_t value should be 0x10000001000.\n        // If it overflows and becomes small, `realloc` will size it too small.\n        size_t desired_alloc_size = new_total_size_u32; // Implicit conversion from uint32_t to size_t\n\n        // Basic check for empty or huge allocation, but doesn't prevent overflow wrap-around\n        // if the wrapped value is still within MAX_ALLOWED_ALLOC_BYTES.\n        static const size_t MAX_ALLOWED_ALLOC_BYTES = 10 * 1024 * 1024; // 10 MB limit\n        if (desired_alloc_size == 0 || desired_alloc_size > MAX_ALLOWED_ALLOC_BYTES) {\n            return false;\n        }\n\n        // Reallocate buffer if current capacity is insufficient\n        if (desired_alloc_size > m_allocated_bytes) {\n            uint8_t* temp_buffer = (uint8_t*)realloc(m_raw_data_buffer, desired_alloc_size);\n            if (!temp_buffer) {\n                if (m_raw_data_buffer) {\n                    free(m_raw_data_buffer);\n                    m_raw_data_buffer = nullptr;\n                }\n                m_data_count = 0;\n                m_allocated_bytes = 0;\n                return false;\n            }\n            m_raw_data_buffer = temp_buffer;\n            m_allocated_bytes = desired_alloc_size;\n        }\n\n        // Calculate offset for the new entry. This calculation is safe\n        // because m_data_count is a uint32_t, and multiplication happens\n        // *before* the overflowed `desired_alloc_size` was received.\n        // However, the *actual* allocated memory pointed to by m_raw_data_buffer\n        // might be much smaller than the logical offset if the overflow occurred.\n        size_t write_offset = (size_t)m_data_count * entry_size;\n\n        // Heap-based Buffer Overflow if 'desired_alloc_size' (the actual realloc'd size)\n        // is less than 'write_offset + entry_size' due to integer overflow.\n        // This check *might* catch it if the difference is too large, but might not\n        // if it still fits within a wrapped small range or is only off-by-a-little.\n        if (write_offset + entry_size > m_allocated_bytes) {\n            // This is a post-hoc check, the overflow might have already occurred during reallocation logic\n            return false;\n        }\n\n        memcpy(m_raw_data_buffer + write_offset, &entry, entry_size);\n        m_data_count++;\n        return true;\n    }\n\n    const uint8_t* getRawDataBuffer() const {\n        return m_raw_data_buffer;\n    }\n\n    uint32_t getDataCount() const {\n        return m_data_count;\n    }\n\n    size_t getAllocatedBytes() const {\n        return m_allocated_bytes;\n    }\n\nprivate:\n    uint8_t* m_raw_data_buffer;\n    uint32_t m_data_count; // Number of SensorReading entries currently stored\n    size_t m_allocated_bytes; // Current allocated buffer size in bytes\n}",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <new>\n#include <limits>\n\n// A simple sensor reading structure typical in automotive (timestamp + value)\nstruct SensorReading {\n    uint32_t timestamp;\n    uint32_t sensor_value;\n};\n\nclass DiagnosticRecorderFixed {\npublic:\n    DiagnosticRecorderFixed() : m_raw_data_buffer(nullptr), m_data_count(0), m_allocated_bytes(0) {}\n\n    ~DiagnosticRecorderFixed() {\n        if (m_raw_data_buffer) {\n            free(m_raw_data_buffer);\n        }\n    }\n\n    // Records a new diagnostic entry\n    // Fix: Perform all size calculations using size_t and include robust\n    // integer overflow checks before allocation.\n    bool recordDiagnosticEntryFixed(uint32_t timestamp, uint32_t value) {\n        SensorReading entry = {timestamp, value};\n        size_t entry_size = sizeof(SensorReading);\n\n        // Check if adding one more entry would cause m_data_count to overflow uint32_t\n        if (m_data_count == std::numeric_limits<uint32_t>::max()) {\n            return false;\n        }\n        // Use size_t for the next logical count to prevent overflow in intermediate calculations.\n        size_t new_logical_count = (size_t)m_data_count + 1;\n\n        // Check for multiplication overflow before calculating total size (new_logical_count * entry_size).\n        // This ensures the result fits within size_t.\n        if (entry_size > std::numeric_limits<size_t>::max() / new_logical_count) {\n            return false; // Multiplication would overflow size_t\n        }\n        size_t new_required_bytes = new_logical_count * entry_size;\n\n        static const size_t MAX_ALLOWED_ALLOC_BYTES = 10 * 1024 * 1024; // 10 MB limit\n        if (new_required_bytes == 0 || new_required_bytes > MAX_ALLOWED_ALLOC_BYTES) {\n            return false;\n        }\n\n        // Reallocate buffer only if current capacity is insufficient\n        if (new_required_bytes > m_allocated_bytes) {\n            uint8_t* temp_buffer = (uint8_t*)realloc(m_raw_data_buffer, new_required_bytes);\n            if (!temp_buffer) {\n                if (m_raw_data_buffer) {\n                    free(m_raw_data_buffer);\n                    m_raw_data_buffer = nullptr;\n                }\n                m_data_count = 0;\n                m_allocated_bytes = 0;\n                return false;\n            }\n            m_raw_data_buffer = temp_buffer;\n            m_allocated_bytes = new_required_bytes;\n        }\n\n        // Calculate offset for the new entry. This is safe as new_required_bytes\n        // guarantees sufficient space if previous checks passed.\n        size_t write_offset = (size_t)m_data_count * entry_size;\n        \n        // Defensive check: This should ideally always pass if previous logic is correct.\n        if (write_offset + entry_size > m_allocated_bytes) {\n            return false;\n        }\n\n        memcpy(m_raw_data_buffer + write_offset, &entry, entry_size);\n        m_data_count++;\n        return true;\n    }\n\n    const uint8_t* getRawDataBuffer() const {\n        return m_raw_data_buffer;\n    }\n\n    uint32_t getDataCount() const {\n        return m_data_count;\n    }\n\n    size_t getAllocatedBytes() const {\n        return m_allocated_bytes;\n    }\n\nprivate:\n    uint8_t* m_raw_data_buffer;\n    uint32_t m_data_count; // Number of SensorReading entries currently stored\n    size_t m_allocated_bytes; // Current allocated buffer size in bytes\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <new>\n#include <limits>\n\n#pragma pack(push, 1)\nstruct CompressedLogEntryHeader {\n    uint16_t entry_id;\n    uint16_t compressed_size; \n    uint32_t original_size_hint; \n};\n#pragma pack(pop)\n\nclass DiagnosticDecompressorVulnerable {\nprivate:\n    uint8_t* m_uncompressed_buffer;\n    size_t   m_uncompressed_buffer_capacity;\n    size_t   m_actual_uncompressed_size;\n\n    bool decompress_rle(const uint8_t* compressed_data, size_t compressed_len,\n                        uint8_t* dest_buffer, size_t dest_capacity, size_t& actual_output_len) {\n        if (!compressed_data || !dest_buffer) {\n            return false;\n        }\n\n        actual_output_len = 0;\n        size_t src_idx = 0;\n\n        while (src_idx < compressed_len) {\n            if (src_idx + 2 > compressed_len) {\n                if (src_idx + 1 == compressed_len) {\n                    if (actual_output_len >= dest_capacity) {\n                        return false;\n                    }\n                    dest_buffer[actual_output_len++] = compressed_data[src_idx++];\n                    continue;\n                }\n                return false;\n            }\n\n            uint8_t current_byte = compressed_data[src_idx++];\n            uint8_t count = compressed_data[src_idx++];\n\n            if (count == 0) {\n                if (actual_output_len >= dest_capacity) {\n                    return false;\n                }\n                dest_buffer[actual_output_len++] = current_byte;\n            } else {\n                for (uint8_t j = 0; j <= count; ++j) {\n                    dest_buffer[actual_output_len++] = current_byte;\n                }\n            }\n        }\n        return true;\n    }\n\npublic:\n    DiagnosticDecompressorVulnerable() : m_uncompressed_buffer(nullptr), m_uncompressed_buffer_capacity(0), m_actual_uncompressed_size(0) {}\n\n    ~DiagnosticDecompressorVulnerable() {\n        if (m_uncompressed_buffer) {\n            free(m_uncompressed_buffer);\n        }\n    }\n\n    bool processCompressedLogEntryVulnerable(const uint8_t* raw_packet, size_t packet_len) {\n        if (!raw_packet || packet_len < sizeof(CompressedLogEntryHeader)) {\n            return false;\n        }\n\n        const CompressedLogEntryHeader* header = reinterpret_cast<const CompressedLogEntryHeader*>(raw_packet);\n\n        if (packet_len < sizeof(CompressedLogEntryHeader) + header->compressed_size) {\n            return false;\n        }\n        \n        if (header->compressed_size == 0 && header->original_size_hint > 0) {\n            return false;\n        }\n\n        if (m_uncompressed_buffer) {\n            free(m_uncompressed_buffer);\n            m_uncompressed_buffer = nullptr;\n            m_uncompressed_buffer_capacity = 0;\n            m_actual_uncompressed_size = 0;\n        }\n\n        m_uncompressed_buffer_capacity = header->original_size_hint;\n        \n        m_uncompressed_buffer = (uint8_t*)malloc(m_uncompressed_buffer_capacity);\n        if (!m_uncompressed_buffer && m_uncompressed_buffer_capacity > 0) {\n            return false;\n        }\n\n        const uint8_t* compressed_payload = raw_packet + sizeof(CompressedLogEntryHeader);\n\n        if (!decompress_rle(compressed_payload, header->compressed_size,\n                             m_uncompressed_buffer, m_uncompressed_buffer_capacity, m_actual_uncompressed_size)) {\n            if (m_uncompressed_buffer) {\n                free(m_uncompressed_buffer);\n                m_uncompressed_buffer = nullptr;\n            }\n            m_uncompressed_buffer_capacity = 0;\n            m_actual_uncompressed_size = 0;\n            return false;\n        }\n        \n        if (m_actual_uncompressed_size > header->original_size_hint && header->original_size_hint > 0) {\n            if (m_uncompressed_buffer) {\n                free(m_uncompressed_buffer);\n                m_uncompressed_buffer = nullptr;\n            }\n            m_uncompressed_buffer_capacity = 0;\n            m_actual_uncompressed_size = 0;\n            return false;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getUncompressedData() const {\n        return m_uncompressed_buffer;\n    }\n\n    size_t getActualUncompressedSize() const {\n        return m_actual_uncompressed_size;\n    }\n}",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <new>\n#include <limits>\n\n#pragma pack(push, 1)\nstruct CompressedLogEntryHeaderFixed {\n    uint16_t entry_id;\n    uint16_t compressed_size;\n    uint32_t original_size_hint;\n};\n#pragma pack(pop)\n\nclass DiagnosticDecompressorFixed {\nprivate:\n    uint8_t* m_uncompressed_buffer;\n    size_t   m_uncompressed_buffer_capacity;\n    size_t   m_actual_uncompressed_size;\n\n    bool decompress_rle_fixed(const uint8_t* compressed_data, size_t compressed_len,\n                              uint8_t* dest_buffer, size_t dest_capacity, size_t& actual_output_len) {\n        if (!compressed_data || !dest_buffer) {\n            return false;\n        }\n\n        actual_output_len = 0;\n        size_t src_idx = 0;\n\n        while (src_idx < compressed_len) {\n            if (src_idx + 2 > compressed_len) {\n                if (src_idx + 1 == compressed_len) {\n                    if (actual_output_len >= dest_capacity) {\n                        return false;\n                    }\n                    dest_buffer[actual_output_len++] = compressed_data[src_idx++];\n                    continue;\n                }\n                return false;\n            }\n\n            uint8_t current_byte = compressed_data[src_idx++];\n            uint8_t count = compressed_data[src_idx++];\n\n            if (count == 0) {\n                if (actual_output_len >= dest_capacity) {\n                    return false;\n                }\n                dest_buffer[actual_output_len++] = current_byte;\n            } else {\n                size_t bytes_to_write = static_cast<size_t>(count) + 1;\n                if (actual_output_len > std::numeric_limits<size_t>::max() - bytes_to_write ||\n                    actual_output_len + bytes_to_write > dest_capacity) {\n                    return false;\n                }\n                for (uint8_t j = 0; j <= count; ++j) {\n                    dest_buffer[actual_output_len++] = current_byte;\n                }\n            }\n        }\n        return true;\n    }\n\npublic:\n    DiagnosticDecompressorFixed() : m_uncompressed_buffer(nullptr), m_uncompressed_buffer_capacity(0), m_actual_uncompressed_size(0) {}\n\n    ~DiagnosticDecompressorFixed() {\n        if (m_uncompressed_buffer) {\n            free(m_uncompressed_buffer);\n        }\n    }\n\n    bool processCompressedLogEntryFixed(const uint8_t* raw_packet, size_t packet_len) {\n        if (!raw_packet || packet_len < sizeof(CompressedLogEntryHeaderFixed)) {\n            return false;\n        }\n\n        const CompressedLogEntryHeaderFixed* header = reinterpret_cast<const CompressedLogEntryHeaderFixed*>(raw_packet);\n\n        if (packet_len < sizeof(CompressedLogEntryHeaderFixed) + header->compressed_size) {\n            return false;\n        }\n        \n        if (header->compressed_size == 0 && header->original_size_hint > 0) {\n            return false;\n        }\n\n        if (m_uncompressed_buffer) {\n            free(m_uncompressed_buffer);\n            m_uncompressed_buffer = nullptr;\n            m_uncompressed_buffer_capacity = 0;\n            m_actual_uncompressed_size = 0;\n        }\n\n        size_t max_possible_uncompressed_size = 0;\n        if (header->compressed_size > 0) {\n            size_t num_full_segments = header->compressed_size / 2;\n            size_t remaining_bytes = header->compressed_size % 2;\n\n            if (num_full_segments > std::numeric_limits<size_t>::max() / 256) {\n                return false;\n            }\n            max_possible_uncompressed_size = num_full_segments * 256;\n            \n            if (max_possible_uncompressed_size > std::numeric_limits<size_t>::max() - remaining_bytes) {\n                return false;\n            }\n            max_possible_uncompressed_size += remaining_bytes;\n        }\n        \n        if (header->original_size_hint > 0 && header->original_size_hint < max_possible_uncompressed_size) {\n            m_uncompressed_buffer_capacity = header->original_size_hint;\n        } else {\n            m_uncompressed_buffer_capacity = max_possible_uncompressed_size;\n        }\n        \n        m_uncompressed_buffer = (uint8_t*)malloc(m_uncompressed_buffer_capacity);\n        if (!m_uncompressed_buffer && m_uncompressed_buffer_capacity > 0) {\n            return false;\n        }\n\n        const uint8_t* compressed_payload = raw_packet + sizeof(CompressedLogEntryHeaderFixed);\n\n        if (!decompress_rle_fixed(compressed_payload, header->compressed_size,\n                                   m_uncompressed_buffer, m_uncompressed_buffer_capacity, m_actual_uncompressed_size)) {\n            if (m_uncompressed_buffer) {\n                free(m_uncompressed_buffer);\n                m_uncompressed_buffer = nullptr;\n            }\n            m_uncompressed_buffer_capacity = 0;\n            m_actual_uncompressed_size = 0;\n            return false;\n        }\n        \n        if (m_actual_uncompressed_size > m_uncompressed_buffer_capacity) {\n            if (m_uncompressed_buffer) {\n                free(m_uncompressed_buffer);\n                m_uncompressed_buffer = nullptr;\n            }\n            m_uncompressed_buffer_capacity = 0;\n            m_actual_uncompressed_size = 0;\n            return false;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getUncompressedData() const {\n        return m_uncompressed_buffer;\n    }\n\n    size_t getActualUncompressedSize() const {\n        return m_actual_uncompressed_size;\n    }\n}",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <new>\n\n#pragma pack(push, 1)\nstruct DiagnosticParamHeader {\n    uint8_t  param_id;\n    uint8_t  param_type; \n    uint16_t param_len;  \n};\n\nstruct DiagnosticPacket {\n    uint16_t packet_id;\n    uint16_t num_params;\n};\n#pragma pack(pop)\n\nclass ParameterStoreVulnerable {\npublic:\n    ParameterStoreVulnerable() : m_param_data_buffer(nullptr), m_buffer_capacity(0) {}\n\n    ~ParameterStoreVulnerable() {\n        if (m_param_data_buffer) {\n            free(m_param_data_buffer);\n        }\n    }\n\n    bool processDiagnosticPacketVulnerable(const uint8_t* raw_packet, size_t packet_len) {\n        if (!raw_packet || packet_len < sizeof(DiagnosticPacket)) {\n            return false;\n        }\n\n        const DiagnosticPacket* packet_header = reinterpret_cast<const DiagnosticPacket*>(raw_packet);\n\n        const uint8_t* current_read_ptr = raw_packet + sizeof(DiagnosticPacket);\n        size_t bytes_remaining_in_packet = packet_len - sizeof(DiagnosticPacket);\n\n        size_t total_required_data_size = 0;\n\n        for (uint16_t i = 0; i < packet_header->num_params; ++i) {\n            if (bytes_remaining_in_packet < sizeof(DiagnosticParamHeader)) {\n                return false;\n            }\n            const DiagnosticParamHeader* param_header = reinterpret_cast<const DiagnosticParamHeader*>(current_read_ptr);\n\n            size_t param_data_actual_len = 0;\n            if (param_header->param_type == 0) {\n                param_data_actual_len = sizeof(uint32_t);\n            } else if (param_header->param_type == 1) {\n                param_data_actual_len = param_header->param_len; \n                if (param_data_actual_len == 0 && packet_header->num_params > 0) {\n                    return false;\n                }\n            } else {\n                return false;\n            }\n\n            if (total_required_data_size > (SIZE_MAX - param_data_actual_len)) {\n                return false;\n            }\n            total_required_data_size += param_data_actual_len;\n\n            if (bytes_remaining_in_packet < (sizeof(DiagnosticParamHeader) + param_data_actual_len)) {\n                return false;\n            }\n            current_read_ptr += sizeof(DiagnosticParamHeader) + param_data_actual_len;\n            bytes_remaining_in_packet -= (sizeof(DiagnosticParamHeader) + param_data_actual_len);\n        }\n\n        if (total_required_data_size > m_buffer_capacity) {\n            uint8_t* new_buffer = (uint8_t*)realloc(m_param_data_buffer, total_required_data_size);\n            if (!new_buffer) {\n                return false;\n            }\n            m_param_data_buffer = new_buffer;\n            m_buffer_capacity = total_required_data_size;\n        }\n\n        current_read_ptr = raw_packet + sizeof(DiagnosticPacket);\n        bytes_remaining_in_packet = packet_len - sizeof(DiagnosticPacket);\n        size_t current_write_offset = 0;\n\n        for (uint16_t i = 0; i < packet_header->num_params; ++i) {\n            if (bytes_remaining_in_packet < sizeof(DiagnosticParamHeader)) {\n                return false;\n            }\n            const DiagnosticParamHeader* param_header = reinterpret_cast<const DiagnosticParamHeader*>(current_read_ptr);\n\n            size_t param_data_payload_size = 0;\n            if (param_header->param_type == 0) {\n                param_data_payload_size = sizeof(uint32_t);\n            } else if (param_header->param_type == 1) {\n                param_data_payload_size = param_header->param_len;\n            } else {\n                return false;\n            }\n\n            if (bytes_remaining_in_packet < sizeof(DiagnosticParamHeader) + param_data_payload_size) {\n                return false;\n            }\n\n            if (current_write_offset > m_buffer_capacity ||\n                param_data_payload_size > m_buffer_capacity - current_write_offset) {\n                return false;\n            }\n\n            memcpy(m_param_data_buffer + current_write_offset,\n                   current_read_ptr + sizeof(DiagnosticParamHeader),\n                   param_data_payload_size);\n            current_write_offset += param_data_payload_size;\n\n            if (param_header->param_type == 1) {\n                m_param_data_buffer[current_write_offset] = '\\0'; \n                current_write_offset++;\n            }\n\n            current_read_ptr += sizeof(DiagnosticParamHeader) + param_data_payload_size;\n            bytes_remaining_in_packet -= (sizeof(DiagnosticParamHeader) + param_data_payload_size);\n        }\n\n        return true;\n    }\n\n    const uint8_t* getParamDataBuffer() const { return m_param_data_buffer; }\n    size_t getBufferCapacity() const { return m_buffer_capacity; }\n\nprivate:\n    uint8_t* m_param_data_buffer;\n    size_t   m_buffer_capacity;\n};",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <new>\n#include <limits>\n\n#pragma pack(push, 1)\nstruct DiagnosticParamHeaderFixed {\n    uint8_t  param_id;\n    uint8_t  param_type; \n    uint16_t param_len;  \n};\n\nstruct DiagnosticPacketFixed {\n    uint16_t packet_id;\n    uint16_t num_params;\n};\n#pragma pack(pop)\n\nclass ParameterStoreFixed {\npublic:\n    ParameterStoreFixed() : m_param_data_buffer(nullptr), m_buffer_capacity(0) {}\n\n    ~ParameterStoreFixed() {\n        if (m_param_data_buffer) {\n            free(m_param_data_buffer);\n        }\n    }\n\n    bool processDiagnosticPacketFixed(const uint8_t* raw_packet, size_t packet_len) {\n        if (!raw_packet || packet_len < sizeof(DiagnosticPacketFixed)) {\n            return false;\n        }\n\n        const DiagnosticPacketFixed* packet_header = reinterpret_cast<const DiagnosticPacketFixed*>(raw_packet);\n\n        const uint8_t* current_read_ptr = raw_packet + sizeof(DiagnosticPacketFixed);\n        size_t bytes_remaining_in_packet = packet_len - sizeof(DiagnosticPacketFixed);\n\n        size_t total_required_data_size = 0;\n\n        for (uint16_t i = 0; i < packet_header->num_params; ++i) {\n            if (bytes_remaining_in_packet < sizeof(DiagnosticParamHeaderFixed)) {\n                return false;\n            }\n            const DiagnosticParamHeaderFixed* param_header = reinterpret_cast<const DiagnosticParamHeaderFixed*>(current_read_ptr);\n\n            size_t param_data_source_len = 0; \n            size_t param_data_store_len = 0;  \n\n            if (param_header->param_type == 0) {\n                param_data_source_len = sizeof(uint32_t);\n                param_data_store_len = sizeof(uint32_t);\n            } else if (param_header->param_type == 1) {\n                param_data_source_len = param_header->param_len;\n                if (param_data_source_len > std::numeric_limits<size_t>::max() - 1) {\n                    return false; \n                }\n                param_data_store_len = param_data_source_len + 1; \n            } else {\n                return false;\n            }\n\n            if (bytes_remaining_in_packet < (sizeof(DiagnosticParamHeaderFixed) + param_data_source_len)) {\n                return false;\n            }\n            \n            if (total_required_data_size > (std::numeric_limits<size_t>::max() - param_data_store_len)) {\n                return false;\n            }\n            total_required_data_size += param_data_store_len;\n\n            current_read_ptr += sizeof(DiagnosticParamHeaderFixed) + param_data_source_len;\n            bytes_remaining_in_packet -= (sizeof(DiagnosticParamHeaderFixed) + param_data_source_len);\n        }\n\n        if (total_required_data_size > m_buffer_capacity) {\n            uint8_t* new_buffer = (uint8_t*)realloc(m_param_data_buffer, total_required_data_size);\n            if (!new_buffer) {\n                return false;\n            }\n            m_param_data_buffer = new_buffer;\n            m_buffer_capacity = total_required_data_size;\n        }\n\n        current_read_ptr = raw_packet + sizeof(DiagnosticPacketFixed);\n        bytes_remaining_in_packet = packet_len - sizeof(DiagnosticPacketFixed);\n        size_t current_write_offset = 0;\n\n        for (uint16_t i = 0; i < packet_header->num_params; ++i) {\n            if (bytes_remaining_in_packet < sizeof(DiagnosticParamHeaderFixed)) {\n                return false;\n            }\n            const DiagnosticParamHeaderFixed* param_header = reinterpret_cast<const DiagnosticParamHeaderFixed*>(current_read_ptr);\n\n            size_t param_data_source_len = 0;\n            size_t param_data_store_len = 0;\n\n            if (param_header->param_type == 0) {\n                param_data_source_len = sizeof(uint32_t);\n                param_data_store_len = sizeof(uint32_t);\n            } else if (param_header->param_type == 1) {\n                param_data_source_len = param_header->param_len;\n                if (param_data_source_len > std::numeric_limits<size_t>::max() - 1) {\n                    return false;\n                }\n                param_data_store_len = param_data_source_len + 1;\n            } else {\n                return false;\n            }\n\n            if (bytes_remaining_in_packet < sizeof(DiagnosticParamHeaderFixed) + param_data_source_len) {\n                return false;\n            }\n\n            if (current_write_offset > m_buffer_capacity ||\n                param_data_store_len > m_buffer_capacity - current_write_offset) {\n                return false;\n            }\n\n            memcpy(m_param_data_buffer + current_write_offset,\n                   current_read_ptr + sizeof(DiagnosticParamHeaderFixed),\n                   param_data_source_len);\n\n            if (param_header->param_type == 1) {\n                m_param_data_buffer[current_write_offset + param_data_source_len] = '\\0'; \n            }\n            \n            current_write_offset += param_data_store_len; \n\n            current_read_ptr += sizeof(DiagnosticParamHeaderFixed) + param_data_source_len;\n            bytes_remaining_in_packet -= (sizeof(DiagnosticParamHeaderFixed) + param_data_source_len);\n        }\n\n        return true;\n    }\n\n    const uint8_t* getParamDataBuffer() const { return m_param_data_buffer; }\n    size_t getBufferCapacity() const { return m_buffer_capacity; }\n\nprivate:\n    uint8_t* m_param_data_buffer;\n    size_t   m_buffer_capacity;\n};",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <vector>\n\n#pragma pack(push, 1)\n\nstruct EventPacketHeaderVulnerable {\n    uint32_t packet_timestamp;\n    uint16_t num_records;\n    uint32_t total_event_data_payload_size; \n};\n\nstruct EventRecordHeaderVulnerable {\n    uint8_t  record_type;\n    uint16_t record_data_length; \n};\n\nstruct DiagnosticEntry {\n    uint16_t diag_code;\n    uint32_t diag_value;\n};\n\n#pragma pack(pop)\n\nstruct ParsedEventRecord {\n    uint8_t  type;\n    uint16_t actual_length;\n    size_t   data_offset;\n};\n\nclass EventLogProcessorVulnerable {\npublic:\n    EventLogProcessorVulnerable() : m_event_data_buffer(nullptr), m_buffer_capacity(0), m_current_data_size(0) {}\n\n    ~EventLogProcessorVulnerable() {\n        if (m_event_data_buffer) {\n            free(m_event_data_buffer);\n        }\n    }\n\n    bool processEventPacketVulnerable(const uint8_t* raw_packet, size_t packet_len) {\n        if (!raw_packet || packet_len < sizeof(EventPacketHeaderVulnerable)) {\n            return false;\n        }\n\n        const EventPacketHeaderVulnerable* packet_hdr = reinterpret_cast<const EventPacketHeaderVulnerable*>(raw_packet);\n\n        if (packet_len < sizeof(EventPacketHeaderVulnerable) + packet_hdr->total_event_data_payload_size) {\n            return false;\n        }\n\n        size_t desired_buffer_size = packet_hdr->total_event_data_payload_size;\n\n        if (m_event_data_buffer) {\n            free(m_event_data_buffer);\n        }\n        m_event_data_buffer = nullptr;\n        m_buffer_capacity = 0;\n        m_current_data_size = 0;\n        m_parsed_records.clear();\n\n        if (desired_buffer_size > 0) {\n            m_event_data_buffer = (uint8_t*)malloc(desired_buffer_size);\n            if (!m_event_data_buffer) {\n                return false;\n            }\n            m_buffer_capacity = desired_buffer_size;\n            memset(m_event_data_buffer, 0, m_buffer_capacity);\n        }\n\n        size_t current_packet_read_offset = sizeof(EventPacketHeaderVulnerable);\n\n        for (uint16_t i = 0; i < packet_hdr->num_records; ++i) {\n            if (current_packet_read_offset + sizeof(EventRecordHeaderVulnerable) > packet_len) {\n                return false;\n            }\n\n            const EventRecordHeaderVulnerable* record_hdr = reinterpret_cast<const EventRecordHeaderVulnerable*>(raw_packet + current_packet_read_offset);\n            \n            uint8_t record_type = record_hdr->record_type;\n            uint16_t record_data_len_field = record_hdr->record_data_length;\n\n            size_t bytes_to_copy_for_this_record = record_data_len_field;\n\n            if (record_type == 0x05) { \n                // VULNERABILITY: For diagnostic events, record_data_length is interpreted as a count of DiagnosticEntry objects.\n                // The total_event_data_payload_size in the packet header was likely calculated based on record_data_length as bytes.\n                // This multiplication (count * sizeof(DiagnosticEntry)) can result in bytes_to_copy_for_this_record being larger\n                // than what was allocated by total_event_data_payload_size.\n                bytes_to_copy_for_this_record = (size_t)record_data_len_field * sizeof(DiagnosticEntry);\n            }\n\n            if (current_packet_read_offset + sizeof(EventRecordHeaderVulnerable) + record_data_len_field > packet_len) {\n                return false;\n            }\n\n            const uint8_t* source_ptr = raw_packet + current_packet_read_offset + sizeof(EventRecordHeaderVulnerable);\n            uint8_t* dest_ptr = m_event_data_buffer + m_current_data_size;\n\n            // VULNERABILITY: No check here for (m_current_data_size + bytes_to_copy_for_this_record) against m_buffer_capacity.\n            // If bytes_to_copy_for_this_record (especially for type 0x05) causes the cumulative size to exceed m_buffer_capacity,\n            // this loop will write past the end of the heap-allocated m_event_data_buffer.\n            for (size_t k = 0; k < bytes_to_copy_for_this_record; ++k) {\n                // Basic source bounds check\n                if ((source_ptr + k) >= (raw_packet + packet_len)) {\n                    return false;\n                }\n                dest_ptr[k] = source_ptr[k];\n            }\n            \n            ParsedEventRecord p_rec;\n            p_rec.type = record_type;\n            p_rec.actual_length = bytes_to_copy_for_this_record;\n            p_rec.data_offset = m_current_data_size;\n            m_parsed_records.push_back(p_rec);\n\n            m_current_data_size += bytes_to_copy_for_this_record;\n            current_packet_read_offset += sizeof(EventRecordHeaderVulnerable) + record_data_len_field;\n        }\n\n        // This check is too late; the overflow would have already occurred during the copy loop.\n        if (m_current_data_size > m_buffer_capacity) {\n            if (m_event_data_buffer) {\n                free(m_event_data_buffer);\n                m_event_data_buffer = nullptr;\n                m_buffer_capacity = 0;\n                m_current_data_size = 0;\n            }\n            m_parsed_records.clear();\n            return false;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getEventDataBuffer() const { return m_event_data_buffer; }\n    size_t getBufferCapacity() const { return m_buffer_capacity; }\n    size_t getCurrentDataSize() const { return m_current_data_size; }\n    const std::vector<ParsedEventRecord>& getParsedRecords() const { return m_parsed_records; }\n\nprivate:\n    uint8_t* m_event_data_buffer;\n    size_t m_buffer_capacity;\n    size_t m_current_data_size;\n    std::vector<ParsedEventRecord> m_parsed_records;\n};",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <vector>\n#include <limits>\n\n#pragma pack(push, 1)\n\nstruct EventPacketHeaderFixed {\n    uint32_t packet_timestamp;\n    uint16_t num_records;\n    uint32_t total_event_data_payload_size;\n};\n\nstruct EventRecordHeaderFixed {\n    uint8_t  record_type;\n    uint16_t record_data_length;\n};\n\nstruct DiagnosticEntry {\n    uint16_t diag_code;\n    uint32_t diag_value;\n};\n\n#pragma pack(pop)\n\nstruct ParsedEventRecordFixed {\n    uint8_t  type;\n    uint16_t actual_length;\n    size_t   data_offset;\n};\n\nclass EventLogProcessorFixed {\npublic:\n    EventLogProcessorFixed() : m_event_data_buffer(nullptr), m_buffer_capacity(0), m_current_data_size(0) {}\n\n    ~EventLogProcessorFixed() {\n        if (m_event_data_buffer) {\n            free(m_event_data_buffer);\n        }\n    }\n\n    bool processEventPacketFixed(const uint8_t* raw_packet, size_t packet_len) {\n        if (!raw_packet || packet_len < sizeof(EventPacketHeaderFixed)) {\n            return false;\n        }\n\n        const EventPacketHeaderFixed* packet_hdr = reinterpret_cast<const EventPacketHeaderFixed*>(raw_packet);\n\n        if (packet_len < sizeof(EventPacketHeaderFixed) + packet_hdr->total_event_data_payload_size) {\n            return false;\n        }\n\n        // FIX: First pass to calculate the *actual* total required buffer size, accounting for data expansion.\n        size_t actual_total_required_buffer_size = 0;\n        size_t current_packet_scan_offset = sizeof(EventPacketHeaderFixed);\n\n        for (uint16_t i = 0; i < packet_hdr->num_records; ++i) {\n            if (current_packet_scan_offset + sizeof(EventRecordHeaderFixed) > packet_len) {\n                return false;\n            }\n\n            const EventRecordHeaderFixed* record_hdr_scan = reinterpret_cast<const EventRecordHeaderFixed*>(raw_packet + current_packet_scan_offset);\n            \n            uint8_t record_type_scan = record_hdr_scan->record_type;\n            uint16_t record_data_len_field_scan = record_hdr_scan->record_data_length;\n\n            size_t bytes_for_this_record = record_data_len_field_scan;\n\n            if (record_type_scan == 0x05) {\n                // Prevent multiplication overflow\n                if (record_data_len_field_scan > (std::numeric_limits<size_t>::max() / sizeof(DiagnosticEntry))) {\n                    return false;\n                }\n                bytes_for_this_record = (size_t)record_data_len_field_scan * sizeof(DiagnosticEntry);\n            }\n\n            // Check if there's enough data in the raw packet for this record's declared payload\n            if (current_packet_scan_offset + sizeof(EventRecordHeaderFixed) > (std::numeric_limits<size_t>::max() - record_data_len_field_scan) ||\n                current_packet_scan_offset + sizeof(EventRecordHeaderFixed) + record_data_len_field_scan > packet_len) {\n                return false;\n            }\n            \n            // Prevent actual_total_required_buffer_size from overflowing during summation\n            if (actual_total_required_buffer_size > (std::numeric_limits<size_t>::max() - bytes_for_this_record)) {\n                return false;\n            }\n            actual_total_required_buffer_size += bytes_for_this_record;\n\n            current_packet_scan_offset += sizeof(EventRecordHeaderFixed) + record_data_len_field_scan;\n        }\n\n        // FIX: Validate the declared total payload size against the actual calculated size.\n        // If they don't match, the packet is malformed or maliciously crafted.\n        if (packet_hdr->total_event_data_payload_size != actual_total_required_buffer_size) {\n            return false;\n        }\n\n        if (m_event_data_buffer) {\n            free(m_event_data_buffer);\n        }\n        m_event_data_buffer = nullptr;\n        m_buffer_capacity = 0;\n        m_current_data_size = 0;\n        m_parsed_records.clear();\n\n        // FIX: Allocate buffer based on the *correctly calculated* size.\n        if (actual_total_required_buffer_size > 0) {\n            m_event_data_buffer = (uint8_t*)malloc(actual_total_required_buffer_size);\n            if (!m_event_data_buffer) {\n                return false;\n            }\n            m_buffer_capacity = actual_total_required_buffer_size;\n            memset(m_event_data_buffer, 0, m_buffer_capacity);\n        }\n\n        size_t current_packet_read_offset = sizeof(EventPacketHeaderFixed);\n\n        for (uint16_t i = 0; i < packet_hdr->num_records; ++i) {\n            // Headers were already checked in the first pass\n            const EventRecordHeaderFixed* record_hdr = reinterpret_cast<const EventRecordHeaderFixed*>(raw_packet + current_packet_read_offset);\n            \n            uint8_t record_type = record_hdr->record_type;\n            uint16_t record_data_len_field = record_hdr->record_data_length;\n\n            size_t bytes_to_copy_for_this_record = record_data_len_field;\n\n            if (record_type == 0x05) {\n                bytes_to_copy_for_this_record = (size_t)record_data_len_field * sizeof(DiagnosticEntry);\n            }\n\n            // FIX: Ensure there's enough space in the destination buffer before copying.\n            if (m_current_data_size > (m_buffer_capacity - bytes_to_copy_for_this_record)) {\n                if (m_event_data_buffer) { free(m_event_data_buffer); m_event_data_buffer = nullptr; }\n                m_buffer_capacity = 0; m_current_data_size = 0; m_parsed_records.clear();\n                return false;\n            }\n            \n            const uint8_t* source_ptr = raw_packet + current_packet_read_offset + sizeof(EventRecordHeaderFixed);\n            uint8_t* dest_ptr = m_event_data_buffer + m_current_data_size;\n\n            for (size_t k = 0; k < bytes_to_copy_for_this_record; ++k) {\n                // Source bounds check (redundant but safe)\n                if ((source_ptr + k) >= (raw_packet + packet_len)) {\n                    if (m_event_data_buffer) { free(m_event_data_buffer); m_event_data_buffer = nullptr; }\n                    m_buffer_capacity = 0; m_current_data_size = 0; m_parsed_records.clear();\n                    return false;\n                }\n                dest_ptr[k] = source_ptr[k];\n            }\n            \n            ParsedEventRecordFixed p_rec;\n            p_rec.type = record_type;\n            p_rec.actual_length = bytes_to_copy_for_this_record;\n            p_rec.data_offset = m_current_data_size;\n            m_parsed_records.push_back(p_rec);\n\n            m_current_data_size += bytes_to_copy_for_this_record;\n            current_packet_read_offset += sizeof(EventRecordHeaderFixed) + record_data_len_field;\n        }\n\n        // Final consistency checks\n        if (current_packet_read_offset != packet_len) {\n            if (m_event_data_buffer) { free(m_event_data_buffer); m_event_data_buffer = nullptr; }\n            m_buffer_capacity = 0; m_current_data_size = 0; m_parsed_records.clear();\n            return false;\n        }\n\n        if (m_current_data_size != m_buffer_capacity) {\n            if (m_event_data_buffer) { free(m_event_data_buffer); m_event_data_buffer = nullptr; }\n            m_buffer_capacity = 0; m_current_data_size = 0; m_parsed_records.clear();\n            return false;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getEventDataBuffer() const { return m_event_data_buffer; }\n    size_t getBufferCapacity() const { return m_buffer_capacity; }\n    size_t getCurrentDataSize() const { return m_current_data_size; }\n    const std::vector<ParsedEventRecordFixed>& getParsedRecords() const { return m_parsed_records; }\n\nprivate:\n    uint8_t* m_event_data_buffer;\n    size_t m_buffer_capacity;\n    size_t m_current_data_size;\n    std::vector<ParsedEventRecordFixed> m_parsed_records;\n};\n",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <new>\n#include <limits>\n\n#pragma pack(push, 1)\nstruct TelemetryEventHeader {\n    uint16_t event_id;\n    uint16_t data_element_count; \n};\n\nstruct TelemetryDataElement {\n    uint16_t element_tag;\n    uint16_t element_length; \n};\n#pragma pack(pop)\n\nconst size_t MAX_AGGREGATED_TELEMETRY_SIZE = 1 * 1024 * 1024;\n\nclass TelemetryDataAggregatorVulnerable {\nprivate:\n    uint8_t* m_aggregated_data_buffer;\n    size_t   m_current_write_offset;\n    size_t   m_allocated_capacity;\n\npublic:\n    TelemetryDataAggregatorVulnerable() : m_aggregated_data_buffer(nullptr), m_current_write_offset(0), m_allocated_capacity(0) {\n        m_allocated_capacity = 65536;\n        m_aggregated_data_buffer = (uint8_t*)malloc(m_allocated_capacity);\n        if (!m_aggregated_data_buffer) {\n            m_allocated_capacity = 0;\n        }\n    }\n\n    ~TelemetryDataAggregatorVulnerable() {\n        if (m_aggregated_data_buffer) {\n            free(m_aggregated_data_buffer);\n            m_aggregated_data_buffer = nullptr;\n        }\n    }\n\n    bool appendTelemetryPacketVulnerable(const uint8_t* raw_packet, size_t packet_len) {\n        if (!raw_packet || packet_len < sizeof(TelemetryEventHeader)) {\n            return false;\n        }\n\n        const TelemetryEventHeader* event_header = reinterpret_cast<const TelemetryEventHeader*>(raw_packet);\n        size_t current_read_offset_in_packet = sizeof(TelemetryEventHeader);\n\n        size_t total_payload_bytes_for_packet_calculated = 0;\n        for (uint16_t i = 0; i < event_header->data_element_count; ++i) {\n            if (current_read_offset_in_packet + sizeof(TelemetryDataElement) > packet_len) {\n                return false;\n            }\n            const TelemetryDataElement* data_element = reinterpret_cast<const TelemetryDataElement*>(raw_packet + current_read_offset_in_packet);\n            \n            size_t element_full_size = sizeof(TelemetryDataElement) + data_element->element_length;\n            \n            total_payload_bytes_for_packet_calculated += element_full_size;\n\n            if (current_read_offset_in_packet + element_full_size > packet_len) {\n                return false;\n            }\n            current_read_offset_in_packet += element_full_size;\n        }\n\n        if (current_read_offset_in_packet != packet_len) {\n            return false;\n        }\n        \n        size_t required_space_in_agg_buffer = m_current_write_offset + total_payload_bytes_for_packet_calculated;\n\n        if (required_space_in_agg_buffer > MAX_AGGREGATED_TELEMETRY_SIZE) {\n            return false;\n        }\n\n        if (required_space_in_agg_buffer > m_allocated_capacity) {\n            size_t new_capacity = m_allocated_capacity * 2;\n            if (new_capacity < required_space_in_agg_buffer) {\n                new_capacity = required_space_in_agg_buffer;\n            }\n            if (new_capacity > MAX_AGGREGATED_TELEMETRY_SIZE) {\n                new_capacity = MAX_AGGREGATED_TELEMETRY_SIZE;\n            }\n            \n            uint8_t* new_buffer = (uint8_t*)realloc(m_aggregated_data_buffer, new_capacity);\n            if (!new_buffer && new_capacity > 0) {\n                return false;\n            }\n            m_aggregated_data_buffer = new_buffer;\n            m_allocated_capacity = new_capacity;\n        }\n\n        size_t bytes_to_copy_from_packet = packet_len - sizeof(TelemetryEventHeader);\n        \n        for (size_t i = 0; i < bytes_to_copy_from_packet; ++i) {\n            m_aggregated_data_buffer[m_current_write_offset + i] = raw_packet[sizeof(TelemetryEventHeader) + i];\n        }\n\n        m_current_write_offset += bytes_to_copy_from_packet;\n\n        return true;\n    }\n\n    const uint8_t* getAggregatedBuffer() const { return m_aggregated_data_buffer; }\n    size_t getCurrentWriteOffset() const { return m_current_write_offset; }\n    size_t getAllocatedCapacity() const { return m_allocated_capacity; }\n\nprivate:\n    uint8_t* m_aggregated_data_buffer;\n    size_t   m_current_write_offset;\n    size_t   m_allocated_capacity;\n};\n",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <new>\n#include <limits>\n\n#pragma pack(push, 1)\nstruct TelemetryEventHeaderFixed {\n    uint16_t event_id;\n    uint16_t data_element_count; \n};\n\nstruct TelemetryDataElementFixed {\n    uint16_t element_tag;\n    uint16_t element_length; \n};\n#pragma pack(pop)\n\nconst size_t MAX_AGGREGATED_TELEMETRY_SIZE_FIXED = 1 * 1024 * 1024;\n\nclass TelemetryDataAggregatorFixed {\nprivate:\n    uint8_t* m_aggregated_data_buffer;\n    size_t   m_current_write_offset;\n    size_t   m_allocated_capacity;\n\npublic:\n    TelemetryDataAggregatorFixed() : m_aggregated_data_buffer(nullptr), m_current_write_offset(0), m_allocated_capacity(0) {\n        m_allocated_capacity = 65536;\n        m_aggregated_data_buffer = (uint8_t*)malloc(m_allocated_capacity);\n        if (!m_aggregated_data_buffer) {\n            m_allocated_capacity = 0;\n        }\n    }\n\n    ~TelemetryDataAggregatorFixed() {\n        if (m_aggregated_data_buffer) {\n            free(m_aggregated_data_buffer);\n            m_aggregated_data_buffer = nullptr;\n        }\n    }\n\n    bool appendTelemetryPacketFixed(const uint8_t* raw_packet, size_t packet_len) {\n        if (!raw_packet || packet_len < sizeof(TelemetryEventHeaderFixed)) {\n            return false;\n        }\n\n        const TelemetryEventHeaderFixed* event_header = reinterpret_cast<const TelemetryEventHeaderFixed*>(raw_packet);\n        size_t current_read_offset_in_packet = sizeof(TelemetryEventHeaderFixed);\n\n        size_t total_payload_bytes_for_packet_calculated = 0;\n        for (uint16_t i = 0; i < event_header->data_element_count; ++i) {\n            if (current_read_offset_in_packet > (packet_len - sizeof(TelemetryDataElementFixed))) {\n                return false;\n            }\n            const TelemetryDataElementFixed* data_element = reinterpret_cast<const TelemetryDataElementFixed*>(raw_packet + current_read_offset_in_packet);\n            \n            size_t element_data_length = data_element->element_length;\n            if (element_data_length > (std::numeric_limits<size_t>::max() - sizeof(TelemetryDataElementFixed))) {\n                 return false;\n            }\n            size_t element_full_size = sizeof(TelemetryDataElementFixed) + element_data_length;\n\n            if (total_payload_bytes_for_packet_calculated > (std::numeric_limits<size_t>::max() - element_full_size)) {\n                return false;\n            }\n            total_payload_bytes_for_packet_calculated += element_full_size;\n\n            if (current_read_offset_in_packet > (packet_len - element_full_size)) {\n                return false;\n            }\n            current_read_offset_in_packet += element_full_size;\n        }\n\n        if (current_read_offset_in_packet != packet_len) {\n            return false;\n        }\n        \n        if (total_payload_bytes_for_packet_calculated != (packet_len - sizeof(TelemetryEventHeaderFixed))) {\n            return false;\n        }\n\n        size_t required_space_in_agg_buffer;\n        if (m_current_write_offset > (std::numeric_limits<size_t>::max() - total_payload_bytes_for_packet_calculated)) {\n            return false;\n        }\n        required_space_in_agg_buffer = m_current_write_offset + total_payload_bytes_for_packet_calculated;\n\n        if (required_space_in_agg_buffer > MAX_AGGREGATED_TELEMETRY_SIZE_FIXED) {\n            return false;\n        }\n\n        if (required_space_in_agg_buffer > m_allocated_capacity) {\n            size_t new_capacity = m_allocated_capacity;\n            if (new_capacity == 0) {\n                new_capacity = 4096;\n            }\n            while (new_capacity < required_space_in_agg_buffer) {\n                if (new_capacity > (std::numeric_limits<size_t>::max() / 2)) {\n                    new_capacity = std::numeric_limits<size_t>::max();\n                    break;\n                }\n                new_capacity *= 2;\n            }\n            if (new_capacity > MAX_AGGREGATED_TELEMETRY_SIZE_FIXED) {\n                new_capacity = MAX_AGGREGATED_TELEMETRY_SIZE_FIXED;\n            }\n            if (new_capacity < required_space_in_agg_buffer) {\n                return false;\n            }\n\n            uint8_t* new_buffer = (uint8_t*)realloc(m_aggregated_data_buffer, new_capacity);\n            if (!new_buffer && new_capacity > 0) {\n                return false;\n            }\n            m_aggregated_data_buffer = new_buffer;\n            m_allocated_capacity = new_capacity;\n        }\n\n        size_t bytes_to_copy_from_packet = packet_len - sizeof(TelemetryEventHeaderFixed);\n        \n        if (m_current_write_offset > (m_allocated_capacity - bytes_to_copy_from_packet)) {\n            return false; \n        }\n\n        for (size_t i = 0; i < bytes_to_copy_from_packet; ++i) {\n            m_aggregated_data_buffer[m_current_write_offset + i] = raw_packet[sizeof(TelemetryEventHeaderFixed) + i];\n        }\n\n        m_current_write_offset += bytes_to_copy_from_packet;\n\n        return true;\n    }\n\n    const uint8_t* getAggregatedBuffer() const { return m_aggregated_data_buffer; }\n    size_t getCurrentWriteOffset() const { return m_current_write_offset; }\n    size_t getAllocatedCapacity() const { return m_allocated_capacity; }\n\nprivate:\n    uint8_t* m_aggregated_data_buffer;\n    size_t   m_current_write_offset;\n    size_t   m_allocated_capacity;\n};\n",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <new>\n\n#pragma pack(push, 1)\n\nstruct IncomingComponentHeaderVulnerable {\n    uint16_t component_id;\n    uint16_t data_length; \n};\n\nstruct FirmwarePacketHeaderVulnerable {\n    uint32_t packet_timestamp;\n    uint16_t num_components;\n    uint32_t total_declared_payload_and_header_bytes; \n};\n\nstruct StoredComponentEntryHeaderVulnerable {\n    uint16_t stored_component_id;\n    uint16_t stored_data_length;\n    uint8_t status_byte; \n};\n\n#pragma pack(pop)\n\nclass FirmwareImageBuilderVulnerable {\npublic:\n    FirmwareImageBuilderVulnerable() : m_firmware_buffer(nullptr), m_current_buffer_offset(0), m_allocated_capacity(0) {}\n\n    ~FirmwareImageBuilderVulnerable() {\n        if (m_firmware_buffer) {\n            free(m_firmware_buffer);\n            m_firmware_buffer = nullptr;\n        }\n    }\n\n    bool assembleFirmwareVulnerable(const uint8_t* raw_packet_data, size_t packet_length) {\n        if (!raw_packet_data || packet_length < sizeof(FirmwarePacketHeaderVulnerable)) {\n            return false;\n        }\n\n        const FirmwarePacketHeaderVulnerable* packet_hdr = reinterpret_cast<const FirmwarePacketHeaderVulnerable*>(raw_packet_data);\n\n        if (packet_length < (sizeof(FirmwarePacketHeaderVulnerable) + packet_hdr->total_declared_payload_and_header_bytes)) {\n            return false;\n        }\n        if (packet_hdr->num_components == 0 && packet_hdr->total_declared_payload_and_header_bytes != 0) {\n            return false; \n        }\n        if (packet_hdr->num_components > 1000) {\n             return false;\n        }\n\n\n        if (m_firmware_buffer) {\n            free(m_firmware_buffer);\n        }\n        m_allocated_capacity = packet_hdr->total_declared_payload_and_header_bytes;\n        m_firmware_buffer = (uint8_t*)malloc(m_allocated_capacity);\n        if (!m_firmware_buffer && m_allocated_capacity > 0) {\n            m_current_buffer_offset = 0;\n            m_allocated_capacity = 0;\n            return false;\n        }\n        m_current_buffer_offset = 0;\n\n        size_t current_packet_read_offset = sizeof(FirmwarePacketHeaderVulnerable);\n\n        for (uint16_t i = 0; i < packet_hdr->num_components; ++i) {\n            if (current_packet_read_offset + sizeof(IncomingComponentHeaderVulnerable) > packet_length) {\n                return false;\n            }\n\n            const IncomingComponentHeaderVulnerable* incoming_hdr = \n                reinterpret_cast<const IncomingComponentHeaderVulnerable*>(raw_packet_data + current_packet_read_offset);\n\n            uint16_t current_data_len = incoming_hdr->data_length;\n\n            if (current_packet_read_offset + sizeof(IncomingComponentHeaderVulnerable) + current_data_len > packet_length) {\n                return false;\n            }\n\n            if (m_current_buffer_offset + sizeof(StoredComponentEntryHeaderVulnerable) > m_allocated_capacity) {\n                return false;\n            }\n\n            StoredComponentEntryHeaderVulnerable* stored_hdr = \n                reinterpret_cast<StoredComponentEntryHeaderVulnerable*>(m_firmware_buffer + m_current_buffer_offset);\n            \n            stored_hdr->stored_component_id = incoming_hdr->component_id;\n            stored_hdr->stored_data_length = incoming_hdr->data_length;\n            stored_hdr->status_byte = 0x01; \n\n            m_current_buffer_offset += sizeof(StoredComponentEntryHeaderVulnerable);\n\n            memcpy(m_firmware_buffer + m_current_buffer_offset, \n                   raw_packet_data + current_packet_read_offset + sizeof(IncomingComponentHeaderVulnerable),\n                   current_data_len);\n            m_current_buffer_offset += current_data_len;\n\n            current_packet_read_offset += sizeof(IncomingComponentHeaderVulnerable) + current_data_len;\n        }\n\n        if (current_packet_read_offset != packet_length) {\n             return false;\n        }\n        \n        if (m_current_buffer_offset > m_allocated_capacity) {\n            return false;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getFirmwareBuffer() const {\n        return m_firmware_buffer;\n    }\n\n    size_t getCurrentBufferOffset() const {\n        return m_current_buffer_offset;\n    }\n\n    size_t getAllocatedCapacity() const {\n        return m_allocated_capacity;\n    }\n\nprivate:\n    uint8_t* m_firmware_buffer;\n    size_t m_current_buffer_offset;\n    size_t m_allocated_capacity;\n};",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <new>\n#include <limits>\n\n#pragma pack(push, 1)\n\nstruct IncomingComponentHeaderFixed {\n    uint16_t component_id;\n    uint16_t data_length; \n};\n\nstruct FirmwarePacketHeaderFixed {\n    uint32_t packet_timestamp;\n    uint16_t num_components;\n    uint32_t total_declared_payload_and_header_bytes; \n};\n\nstruct StoredComponentEntryHeaderFixed {\n    uint16_t stored_component_id;\n    uint16_t stored_data_length;\n    uint8_t status_byte; \n};\n\n#pragma pack(pop)\n\nclass FirmwareImageBuilderFixed {\npublic:\n    FirmwareImageBuilderFixed() : m_firmware_buffer(nullptr), m_current_buffer_offset(0), m_allocated_capacity(0) {}\n\n    ~FirmwareImageBuilderFixed() {\n        if (m_firmware_buffer) {\n            free(m_firmware_buffer);\n            m_firmware_buffer = nullptr;\n        }\n    }\n\n    bool assembleFirmwareFixed(const uint8_t* raw_packet_data, size_t packet_length) {\n        if (!raw_packet_data || packet_length < sizeof(FirmwarePacketHeaderFixed)) {\n            return false;\n        }\n\n        const FirmwarePacketHeaderFixed* packet_hdr = reinterpret_cast<const FirmwarePacketHeaderFixed*>(raw_packet_data);\n\n        if (packet_length < (sizeof(FirmwarePacketHeaderFixed) + packet_hdr->total_declared_payload_and_header_bytes)) {\n            return false;\n        }\n        if (packet_hdr->num_components == 0 && packet_hdr->total_declared_payload_and_header_bytes != 0) {\n            return false; \n        }\n        if (packet_hdr->num_components > 1000) {\n             return false;\n        }\n\n        size_t calculated_required_capacity = 0;\n        size_t current_packet_scan_offset = sizeof(FirmwarePacketHeaderFixed);\n        uint32_t verified_declared_payload_and_header_bytes = 0;\n\n        for (uint16_t i = 0; i < packet_hdr->num_components; ++i) {\n            if (current_packet_scan_offset + sizeof(IncomingComponentHeaderFixed) > packet_length) {\n                return false;\n            }\n\n            const IncomingComponentHeaderFixed* incoming_hdr = \n                reinterpret_cast<const IncomingComponentHeaderFixed*>(raw_packet_data + current_packet_scan_offset);\n\n            uint16_t current_data_len = incoming_hdr->data_length;\n\n            if (current_packet_scan_offset + sizeof(IncomingComponentHeaderFixed) + current_data_len > packet_length) {\n                return false;\n            }\n\n            if (verified_declared_payload_and_header_bytes > (std::numeric_limits<uint32_t>::max() - (sizeof(IncomingComponentHeaderFixed) + current_data_len))) {\n                return false;\n            }\n            verified_declared_payload_and_header_bytes += (sizeof(IncomingComponentHeaderFixed) + current_data_len);\n\n            size_t space_needed_for_this_entry = sizeof(StoredComponentEntryHeaderFixed) + current_data_len;\n            if (calculated_required_capacity > (std::numeric_limits<size_t>::max() - space_needed_for_this_entry)) {\n                return false;\n            }\n            calculated_required_capacity += space_needed_for_this_entry;\n\n            current_packet_scan_offset += sizeof(IncomingComponentHeaderFixed) + current_data_len;\n        }\n\n        if (verified_declared_payload_and_header_bytes != packet_hdr->total_declared_payload_and_header_bytes) {\n            return false;\n        }\n\n        if (current_packet_scan_offset != packet_length) {\n            return false;\n        }\n\n        if (m_firmware_buffer) {\n            free(m_firmware_buffer);\n        }\n        m_allocated_capacity = calculated_required_capacity;\n        m_firmware_buffer = (uint8_t*)malloc(m_allocated_capacity);\n        if (!m_firmware_buffer && m_allocated_capacity > 0) {\n            m_current_buffer_offset = 0;\n            m_allocated_capacity = 0;\n            return false;\n        }\n        m_current_buffer_offset = 0;\n\n        size_t current_packet_read_offset = sizeof(FirmwarePacketHeaderFixed);\n\n        for (uint16_t i = 0; i < packet_hdr->num_components; ++i) {\n            const IncomingComponentHeaderFixed* incoming_hdr = \n                reinterpret_cast<const IncomingComponentHeaderFixed*>(raw_packet_data + current_packet_read_offset);\n            uint16_t current_data_len = incoming_hdr->data_length;\n\n            size_t space_needed_for_this_entry = sizeof(StoredComponentEntryHeaderFixed) + current_data_len;\n\n            if (m_current_buffer_offset > (m_allocated_capacity - space_needed_for_this_entry)) {\n                return false;\n            }\n\n            StoredComponentEntryHeaderFixed* stored_hdr = \n                reinterpret_cast<StoredComponentEntryHeaderFixed*>(m_firmware_buffer + m_current_buffer_offset);\n            \n            stored_hdr->stored_component_id = incoming_hdr->component_id;\n            stored_hdr->stored_data_length = incoming_hdr->data_length;\n            stored_hdr->status_byte = 0x01; \n\n            m_current_buffer_offset += sizeof(StoredComponentEntryHeaderFixed);\n\n            memcpy(m_firmware_buffer + m_current_buffer_offset, \n                   raw_packet_data + current_packet_read_offset + sizeof(IncomingComponentHeaderFixed),\n                   current_data_len);\n            m_current_buffer_offset += current_data_len;\n\n            current_packet_read_offset += sizeof(IncomingComponentHeaderFixed) + current_data_len;\n        }\n\n        if (m_current_buffer_offset != m_allocated_capacity) {\n            return false;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getFirmwareBuffer() const {\n        return m_firmware_buffer;\n    }\n\n    size_t getCurrentBufferOffset() const {\n        return m_current_buffer_offset;\n    }\n\n    size_t getAllocatedCapacity() const {\n        return m_allocated_capacity;\n    }\n\nprivate:\n    uint8_t* m_firmware_buffer;\n    size_t m_current_buffer_offset;\n    size_t m_allocated_capacity;\n};",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <vector>\n#include <new>\n\n#pragma pack(push, 1)\nstruct DiagnosticMessageHeaderVulnerable {\n    uint16_t message_id;\n    uint16_t base_data_length;\n    uint16_t dynamic_data_length;\n};\n\nstruct StoredDiagnosticMessageVulnerable {\n    uint16_t id;\n    uint8_t* data_buffer;\n    size_t allocated_size;\n};\n#pragma pack(pop)\n\n#define MAX_BASE_LEN_MESSAGE_A 16\n#define MAX_DYNAMIC_LEN_MESSAGE_A 32\n\n#define MAX_BASE_LEN_MESSAGE_B 8\n#define MAX_DYNAMIC_LEN_MESSAGE_B 128\n\nclass DiagnosticGatewayVulnerable {\nprivate:\n    std::vector<StoredDiagnosticMessageVulnerable*> m_stored_messages;\n\npublic:\n    DiagnosticGatewayVulnerable() {}\n\n    ~DiagnosticGatewayVulnerable() {\n        clearStoredMessages();\n    }\n\n    void clearStoredMessages() {\n        for (auto msg : m_stored_messages) {\n            if (msg->data_buffer) {\n                free(msg->data_buffer);\n            }\n            delete msg;\n        }\n        m_stored_messages.clear();\n    }\n\n    bool processDiagnosticMessageVulnerable(const uint8_t* raw_message_data, size_t data_len) {\n        if (!raw_message_data || data_len < sizeof(DiagnosticMessageHeaderVulnerable)) {\n            return false;\n        }\n\n        const DiagnosticMessageHeaderVulnerable* header =\n            reinterpret_cast<const DiagnosticMessageHeaderVulnerable*>(raw_message_data);\n        \n        size_t incoming_total_size = sizeof(DiagnosticMessageHeaderVulnerable) +\n                                     header->base_data_length +\n                                     header->dynamic_data_length;\n\n        if (data_len != incoming_total_size) {\n            return false;\n        }\n\n        StoredDiagnosticMessageVulnerable* new_stored_msg = new (std::nothrow) StoredDiagnosticMessageVulnerable();\n        if (!new_stored_msg) {\n            return false;\n        }\n        new_stored_msg->id = header->message_id;\n        new_stored_msg->data_buffer = nullptr;\n        new_stored_msg->allocated_size = 0;\n\n        size_t required_data_buffer_size = 0;\n\n        if (header->message_id == 0x101) {\n            required_data_buffer_size = MAX_BASE_LEN_MESSAGE_A + MAX_DYNAMIC_LEN_MESSAGE_A;\n        } else if (header->message_id == 0x102) {\n            required_data_buffer_size = MAX_BASE_LEN_MESSAGE_B + MAX_DYNAMIC_LEN_MESSAGE_B;\n        } else {\n            delete new_stored_msg;\n            return false;\n        }\n\n        new_stored_msg->data_buffer = (uint8_t*)malloc(required_data_buffer_size);\n        if (!new_stored_msg->data_buffer) {\n            delete new_stored_msg;\n            return false;\n        }\n        new_stored_msg->allocated_size = required_data_buffer_size;\n\n        size_t total_payload_to_copy = header->base_data_length + header->dynamic_data_length;\n\n        memcpy(new_stored_msg->data_buffer,\n               raw_message_data + sizeof(DiagnosticMessageHeaderVulnerable),\n               total_payload_to_copy);\n\n        m_stored_messages.push_back(new_stored_msg);\n        return true;\n    }\n\n    size_t getNumStoredMessages() const {\n        return m_stored_messages.size();\n    }\n\n    const StoredDiagnosticMessageVulnerable* getStoredMessage(size_t index) const {\n        if (index < m_stored_messages.size()) {\n            return m_stored_messages[index];\n        }\n        return nullptr;\n    }\n};",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <vector>\n#include <new>\n#include <limits>\n\n#pragma pack(push, 1)\nstruct DiagnosticMessageHeaderFixed {\n    uint16_t message_id;\n    uint16_t base_data_length;\n    uint16_t dynamic_data_length;\n};\n\nstruct StoredDiagnosticMessageFixed {\n    uint16_t id;\n    uint8_t* data_buffer;\n    size_t allocated_size;\n};\n#pragma pack(pop)\n\n#define MAX_BASE_LEN_MESSAGE_A 16\n#define MAX_DYNAMIC_LEN_MESSAGE_A 32\n\n#define MAX_BASE_LEN_MESSAGE_B 8\n#define MAX_DYNAMIC_LEN_MESSAGE_B 128\n\n#define GLOBAL_MAX_DYNAMIC_PAYLOAD_SEGMENT 512\n\nclass DiagnosticGatewayFixed {\nprivate:\n    std::vector<StoredDiagnosticMessageFixed*> m_stored_messages;\n\npublic:\n    DiagnosticGatewayFixed() {}\n\n    ~DiagnosticGatewayFixed() {\n        clearStoredMessages();\n    }\n\n    void clearStoredMessages() {\n        for (auto msg : m_stored_messages) {\n            if (msg->data_buffer) {\n                free(msg->data_buffer);\n            }\n            delete msg;\n        }\n        m_stored_messages.clear();\n    }\n\n    bool processDiagnosticMessageFixed(const uint8_t* raw_message_data, size_t data_len) {\n        if (!raw_message_data || data_len < sizeof(DiagnosticMessageHeaderFixed)) {\n            return false;\n        }\n\n        const DiagnosticMessageHeaderFixed* header =\n            reinterpret_cast<const DiagnosticMessageHeaderFixed*>(raw_message_data);\n        \n        if (header->base_data_length > std::numeric_limits<uint16_t>::max() ||\n            header->dynamic_data_length > std::numeric_limits<uint16_t>::max() ||\n            header->dynamic_data_length > GLOBAL_MAX_DYNAMIC_PAYLOAD_SEGMENT) {\n            return false;\n        }\n\n        size_t incoming_total_size_payload;\n        if (header->base_data_length > (std::numeric_limits<uint16_t>::max() - header->dynamic_data_length)) {\n             return false;\n        }\n        incoming_total_size_payload = header->base_data_length + header->dynamic_data_length;\n\n        size_t incoming_total_size;\n        if (incoming_total_size_payload > (std::numeric_limits<size_t>::max() - sizeof(DiagnosticMessageHeaderFixed))) {\n            return false;\n        }\n        incoming_total_size = sizeof(DiagnosticMessageHeaderFixed) + incoming_total_size_payload;\n\n        if (data_len != incoming_total_size) {\n            return false;\n        }\n\n        StoredDiagnosticMessageFixed* new_stored_msg = new (std::nothrow) StoredDiagnosticMessageFixed();\n        if (!new_stored_msg) {\n            return false;\n        }\n        new_stored_msg->id = header->message_id;\n        new_stored_msg->data_buffer = nullptr;\n        new_stored_msg->allocated_size = 0;\n\n        size_t required_data_buffer_size = 0;\n\n        if (header->message_id == 0x101) {\n            if (header->base_data_length > MAX_BASE_LEN_MESSAGE_A || \n                header->dynamic_data_length > MAX_DYNAMIC_LEN_MESSAGE_A) {\n                delete new_stored_msg;\n                return false;\n            }\n            required_data_buffer_size = MAX_BASE_LEN_MESSAGE_A + MAX_DYNAMIC_LEN_MESSAGE_A;\n        } else if (header->message_id == 0x102) {\n            if (header->base_data_length > MAX_BASE_LEN_MESSAGE_B || \n                header->dynamic_data_length > MAX_DYNAMIC_LEN_MESSAGE_B) {\n                delete new_stored_msg;\n                return false;\n            }\n            required_data_buffer_size = MAX_BASE_LEN_MESSAGE_B + MAX_DYNAMIC_LEN_MESSAGE_B;\n        } else {\n            delete new_stored_msg;\n            return false;\n        }\n        \n        if (incoming_total_size_payload > 0 && required_data_buffer_size == 0) {\n            delete new_stored_msg;\n            return false;\n        }\n        \n        new_stored_msg->data_buffer = (uint8_t*)malloc(required_data_buffer_size);\n        if (!new_stored_msg->data_buffer && required_data_buffer_size > 0) {\n            delete new_stored_msg;\n            return false;\n        }\n        new_stored_msg->allocated_size = required_data_buffer_size;\n\n        size_t total_payload_to_copy = header->base_data_length + header->dynamic_data_length;\n\n        if (total_payload_to_copy > new_stored_msg->allocated_size) {\n            if (new_stored_msg->data_buffer) free(new_stored_msg->data_buffer);\n            delete new_stored_msg;\n            return false;\n        }\n\n        memcpy(new_stored_msg->data_buffer,\n               raw_message_data + sizeof(DiagnosticMessageHeaderFixed),\n               total_payload_to_copy);\n\n        m_stored_messages.push_back(new_stored_msg);\n        return true;\n    }\n\n    size_t getNumStoredMessages() const {\n        return m_stored_messages.size();\n    }\n\n    const StoredDiagnosticMessageFixed* getStoredMessage(size_t index) const {\n        if (index < m_stored_messages.size()) {\n            return m_stored_messages[index];\n        }\n        return nullptr;\n    }\n};",
    "analysis": ""
  },
  {
    "cwe_id": "122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <vector>\n#include <numeric>\n#include <cstring>\n\n#pragma pack(push, 1)\nenum ConfigParamTypeVulnerable {\n    TYPE_UINT8_VULNERABLE = 0x01,\n    TYPE_INT16_ARRAY_VULNERABLE = 0x02,\n    TYPE_FLOAT_VULNERABLE = 0x03,\n    TYPE_BYTE_ARRAY_VULNERABLE = 0x04\n};\n\nstruct ConfigEntryHeaderVulnerable {\n    uint16_t param_id;\n    uint8_t  param_type;\n    uint16_t data_count; \n};\n\nstruct ConfigPacketHeaderVulnerable {\n    uint32_t packet_sequence_num;\n    uint16_t num_entries;\n    uint32_t total_expected_data_payload_bytes; \n};\n#pragma pack(pop)\n\nclass ConfigManagerVulnerable {\npublic:\n    ConfigManagerVulnerable() : m_config_storage(nullptr), m_storage_capacity(0), m_current_data_offset(0) {}\n\n    ~ConfigManagerVulnerable() {\n        if (m_config_storage) {\n            free(m_config_storage);\n            m_config_storage = nullptr;\n        }\n    }\n\n    bool processConfigUpdatePacketVulnerable(const uint8_t* raw_packet_data, size_t packet_len) {\n        if (!raw_packet_data || packet_len < sizeof(ConfigPacketHeaderVulnerable)) {\n            return false;\n        }\n\n        const ConfigPacketHeaderVulnerable* packet_header = reinterpret_cast<const ConfigPacketHeaderVulnerable*>(raw_packet_data);\n\n        if (packet_len < sizeof(ConfigPacketHeaderVulnerable) + packet_header->total_expected_data_payload_bytes) {\n            return false;\n        }\n\n        if (m_config_storage) {\n            free(m_config_storage);\n        }\n        m_config_storage = nullptr;\n        m_storage_capacity = 0;\n        m_current_data_offset = 0;\n\n        // VULNERABILITY: The total_expected_data_payload_bytes from the header is used directly\n        // for allocation. This value is assumed to be the sum of 'data_count' fields from all entries.\n        // However, 'data_count' represents 'number of elements', not 'number of bytes', for some types.\n        // If the sender calculated total_expected_data_payload_bytes by simply summing raw data_count values\n        // (e.g., treating 10 INT16s as 10 bytes instead of 20), the allocated buffer will be undersized.\n        if (packet_header->total_expected_data_payload_bytes > 0) {\n            m_config_storage = (uint8_t*)malloc(packet_header->total_expected_data_payload_bytes);\n            if (!m_config_storage) {\n                return false;\n            }\n            m_storage_capacity = packet_header->total_expected_data_payload_bytes;\n            memset(m_config_storage, 0, m_storage_capacity);\n        } else {\n            return false;\n        }\n\n        const uint8_t* current_read_ptr = raw_packet_data + sizeof(ConfigPacketHeaderVulnerable);\n        size_t remaining_packet_bytes = packet_len - sizeof(ConfigPacketHeaderVulnerable);\n\n        for (uint16_t i = 0; i < packet_header->num_entries; ++i) {\n            if (remaining_packet_bytes < sizeof(ConfigEntryHeaderVulnerable)) {\n                return false;\n            }\n\n            const ConfigEntryHeaderVulnerable* entry_header = reinterpret_cast<const ConfigEntryHeaderVulnerable*>(current_read_ptr);\n            \n            uint16_t data_elements_count = entry_header->data_count;\n            size_t bytes_to_copy_for_this_entry = 0;\n            \n            switch (entry_header->param_type) {\n                case TYPE_UINT8_VULNERABLE:\n                case TYPE_BYTE_ARRAY_VULNERABLE:\n                    bytes_to_copy_for_this_entry = data_elements_count;\n                    break;\n                case TYPE_INT16_ARRAY_VULNERABLE:\n                    // Correctly calculates bytes for INT16 array: data_count * 2\n                    bytes_to_copy_for_this_entry = (size_t)data_elements_count * sizeof(uint16_t);\n                    break;\n                case TYPE_FLOAT_VULNERABLE:\n                    // Correctly calculates bytes for float: data_count * 4\n                    bytes_to_copy_for_this_entry = (size_t)data_elements_count * sizeof(float);\n                    break;\n                default:\n                    return false;\n            }\n\n            // Check if there's enough data in the source packet for this entry (based on sender's raw data_count)\n            if (remaining_packet_bytes < (sizeof(ConfigEntryHeaderVulnerable) + data_elements_count)) {\n                return false;\n            }\n\n            // VULNERABILITY: No bounds check here for 'm_config_storage + m_current_data_offset + k'\n            // against 'm_storage_capacity'. If 'bytes_to_copy_for_this_entry' (correctly calculated here)\n            // is larger than what 'm_storage_capacity' (incorrectly allocated based on total_expected_data_payload_bytes)\n            // allows, this loop will write past the end of the heap-allocated buffer.\n            for (size_t k = 0; k < bytes_to_copy_for_this_entry; ++k) {\n                m_config_storage[m_current_data_offset + k] = current_read_ptr[sizeof(ConfigEntryHeaderVulnerable) + k];\n            }\n\n            m_current_data_offset += bytes_to_copy_for_this_entry;\n            current_read_ptr += sizeof(ConfigEntryHeaderVulnerable) + data_elements_count;\n            remaining_packet_bytes -= (sizeof(ConfigEntryHeaderVulnerable) + data_elements_count);\n        }\n\n        // This check is too late; the overflow would have already occurred during the copy loop.\n        if (m_current_data_offset > m_storage_capacity) {\n            if (m_config_storage) { free(m_config_storage); m_config_storage = nullptr; }\n            m_storage_capacity = 0;\n            m_current_data_offset = 0;\n            return false;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getConfigStorage() const {\n        return m_config_storage;\n    }\n\n    size_t getStoredSize() const {\n        return m_current_data_offset;\n    }\n\nprivate:\n    uint8_t* m_config_storage;\n    size_t m_storage_capacity;\n    size_t m_current_data_offset;\n};",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <vector>\n#include <numeric>\n#include <cstring>\n#include <limits>\n\n#pragma pack(push, 1)\nenum ConfigParamTypeFixed {\n    TYPE_UINT8_FIXED = 0x01,\n    TYPE_INT16_ARRAY_FIXED = 0x02,\n    TYPE_FLOAT_FIXED = 0x03,\n    TYPE_BYTE_ARRAY_FIXED = 0x04\n};\n\nstruct ConfigEntryHeaderFixed {\n    uint16_t param_id;\n    uint8_t  param_type;\n    uint16_t data_count; \n};\n\nstruct ConfigPacketHeaderFixed {\n    uint32_t packet_sequence_num;\n    uint16_t num_entries;\n    uint32_t total_expected_data_payload_bytes; \n};\n#pragma pack(pop)\n\nclass ConfigManagerFixed {\npublic:\n    ConfigManagerFixed() : m_config_storage(nullptr), m_storage_capacity(0), m_current_data_offset(0) {}\n\n    ~ConfigManagerFixed() {\n        if (m_config_storage) {\n            free(m_config_storage);\n            m_config_storage = nullptr;\n        }\n    }\n\n    bool processConfigUpdatePacketFixed(const uint8_t* raw_packet_data, size_t packet_len) {\n        if (!raw_packet_data || packet_len < sizeof(ConfigPacketHeaderFixed)) {\n            return false;\n        }\n\n        const ConfigPacketHeaderFixed* packet_header = reinterpret_cast<const ConfigPacketHeaderFixed*>(raw_packet_data);\n\n        if (packet_len < sizeof(ConfigPacketHeaderFixed) + packet_header->total_expected_data_payload_bytes) {\n            return false;\n        }\n        \n        // FIX: First pass to calculate the *actual* total required buffer size, \n        // accounting for different data types, before allocation.\n        size_t actual_total_required_buffer_size = 0;\n        size_t current_packet_scan_offset = sizeof(ConfigPacketHeaderFixed);\n\n        for (uint16_t i = 0; i < packet_header->num_entries; ++i) {\n            if (current_packet_scan_offset + sizeof(ConfigEntryHeaderFixed) > packet_len) {\n                return false;\n            }\n\n            const ConfigEntryHeaderFixed* entry_header_scan = reinterpret_cast<const ConfigEntryHeaderFixed*>(raw_packet_data + current_packet_scan_offset);\n            \n            uint16_t data_elements_count_scan = entry_header_scan->data_count;\n            size_t bytes_for_this_entry_scan = 0;\n\n            switch (entry_header_scan->param_type) {\n                case TYPE_UINT8_FIXED:\n                case TYPE_BYTE_ARRAY_FIXED:\n                    bytes_for_this_entry_scan = data_elements_count_scan;\n                    break;\n                case TYPE_INT16_ARRAY_FIXED:\n                    // FIX: Check for multiplication overflow\n                    if (data_elements_count_scan > std::numeric_limits<size_t>::max() / sizeof(uint16_t)) {\n                        return false;\n                    }\n                    bytes_for_this_entry_scan = (size_t)data_elements_count_scan * sizeof(uint16_t);\n                    break;\n                case TYPE_FLOAT_FIXED:\n                    // FIX: Check for multiplication overflow\n                    if (data_elements_count_scan > std::numeric_limits<size_t>::max() / sizeof(float)) {\n                        return false;\n                    }\n                    bytes_for_this_entry_scan = (size_t)data_elements_count_scan * sizeof(float);\n                    break;\n                default:\n                    return false;\n            }\n\n            // FIX: Check for integer overflow when summing up total required size\n            if (actual_total_required_buffer_size > std::numeric_limits<size_t>::max() - bytes_for_this_entry_scan) {\n                return false; \n            }\n            actual_total_required_buffer_size += bytes_for_this_entry_scan;\n\n            // Check if raw data_count makes packet extend past packet_len\n            if (current_packet_scan_offset + sizeof(ConfigEntryHeaderFixed) > (std::numeric_limits<size_t>::max() - data_elements_count_scan) ||\n                current_packet_scan_offset + sizeof(ConfigEntryHeaderFixed) + data_elements_count_scan > packet_len) {\n                return false; \n            }\n            current_packet_scan_offset += sizeof(ConfigEntryHeaderFixed) + data_elements_count_scan;\n        }\n\n        // FIX: Validate the declared total payload size from the header against the *actual* calculated size.\n        // If they don't match, the packet is malformed or maliciously crafted.\n        if (packet_header->total_expected_data_payload_bytes != actual_total_required_buffer_size) {\n            return false;\n        }\n\n        if (m_config_storage) {\n            free(m_config_storage);\n        }\n        m_config_storage = nullptr;\n        m_storage_capacity = 0;\n        m_current_data_offset = 0;\n\n        // FIX: Allocate buffer based on the *correctly calculated* size.\n        if (actual_total_required_buffer_size > 0) {\n            m_config_storage = (uint8_t*)malloc(actual_total_required_buffer_size);\n            if (!m_config_storage) {\n                return false;\n            }\n            m_storage_capacity = actual_total_required_buffer_size;\n            memset(m_config_storage, 0, m_storage_capacity);\n        } else if (packet_header->num_entries > 0) {\n             return false; \n        }\n\n        // Second pass: Parse and copy data\n        current_packet_scan_offset = sizeof(ConfigPacketHeaderFixed);\n\n        for (uint16_t i = 0; i < packet_header->num_entries; ++i) {\n            const ConfigEntryHeaderFixed* entry_header = reinterpret_cast<const ConfigEntryHeaderFixed*>(raw_packet_data + current_packet_scan_offset);\n            \n            uint16_t data_elements_count = entry_header->data_count;\n            size_t bytes_to_copy_for_this_entry = 0;\n            \n            switch (entry_header->param_type) {\n                case TYPE_UINT8_FIXED:\n                case TYPE_BYTE_ARRAY_FIXED:\n                    bytes_to_copy_for_this_entry = data_elements_count;\n                    break;\n                case TYPE_INT16_ARRAY_FIXED:\n                    bytes_to_copy_for_this_entry = (size_t)data_elements_count * sizeof(uint16_t);\n                    break;\n                case TYPE_FLOAT_FIXED:\n                    bytes_to_copy_for_this_entry = (size_t)data_elements_count * sizeof(float);\n                    break;\n                default:\n                    if (m_config_storage) { free(m_config_storage); m_config_storage = nullptr; }\n                    m_storage_capacity = 0; m_current_data_offset = 0;\n                    return false;\n            }\n            \n            // FIX: Explicit bounds check before writing to the destination buffer.\n            if (m_current_data_offset > (m_storage_capacity - bytes_to_copy_for_this_entry)) {\n                if (m_config_storage) { free(m_config_storage); m_config_storage = nullptr; }\n                m_storage_capacity = 0; m_current_data_offset = 0;\n                return false;\n            }\n\n            for (size_t k = 0; k < bytes_to_copy_for_this_entry; ++k) {\n                if (current_packet_scan_offset + sizeof(ConfigEntryHeaderFixed) + k >= raw_packet_data + packet_len) {\n                    if (m_config_storage) { free(m_config_storage); m_config_storage = nullptr; }\n                    m_storage_capacity = 0; m_current_data_offset = 0;\n                    return false;\n                }\n                m_config_storage[m_current_data_offset + k] = raw_packet_data[current_packet_scan_offset + sizeof(ConfigEntryHeaderFixed) + k];\n            }\n\n            m_current_data_offset += bytes_to_copy_for_this_entry;\n            current_packet_scan_offset += sizeof(ConfigEntryHeaderFixed) + data_elements_count;\n        }\n\n        // Final consistency check\n        if (m_current_data_offset != m_storage_capacity) {\n            if (m_config_storage) { free(m_config_storage); m_config_storage = nullptr; }\n            m_storage_capacity = 0; m_current_data_offset = 0;\n            return false;\n        }\n\n        return true;\n    }\n\n    const uint8_t* getConfigStorage() const {\n        return m_config_storage;\n    }\n\n    size_t getStoredSize() const {\n        return m_current_data_offset;\n    }\n\nprivate:\n    uint8_t* m_config_storage;\n    size_t m_storage_capacity;\n    size_t m_current_data_offset;\n};",
    "analysis": ""
  },
  {
    "cwe_id": "CWE-122",
    "cwe_description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
    "vulnerable_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n\n#pragma pack(push, 1)\nstruct TelemetryRecordHeader {\n    uint16_t record_id;\n    uint16_t payload_len;\n    uint32_t timestamp;\n};\n#pragma pack(pop)\n\n#define TELEMETRY_SLOT_SIZE 256\n#define MAX_TELEMETRY_RECORDS 10\n\nclass TelemetryDataManagerVulnerable {\nprivate:\n    uint8_t* m_storage_buffer;\n    size_t m_current_record_count;\n    size_t m_total_allocated_size;\n\npublic:\n    TelemetryDataManagerVulnerable() :\n        m_storage_buffer(nullptr),\n        m_current_record_count(0),\n        m_total_allocated_size(0)\n    {\n        m_total_allocated_size = MAX_TELEMETRY_RECORDS * TELEMETRY_SLOT_SIZE;\n        m_storage_buffer = (uint8_t*)malloc(m_total_allocated_size);\n        if (!m_storage_buffer) {\n            m_total_allocated_size = 0;\n        }\n    }\n\n    ~TelemetryDataManagerVulnerable() {\n        if (m_storage_buffer) {\n            free(m_storage_buffer);\n            m_storage_buffer = nullptr;\n        }\n    }\n\n    bool addTelemetryRecordVulnerable(const uint8_t* raw_packet, size_t packet_len) {\n        if (!raw_packet || packet_len < sizeof(TelemetryRecordHeader)) {\n            return false;\n        }\n\n        const TelemetryRecordHeader* header = reinterpret_cast<const TelemetryRecordHeader*>(raw_packet);\n\n        size_t full_record_size = sizeof(TelemetryRecordHeader) + header->payload_len;\n\n        if (packet_len < full_record_size) {\n            return false;\n        }\n\n        if (m_current_record_count >= MAX_TELEMETRY_RECORDS) {\n            return false;\n        }\n\n        size_t write_offset_in_buffer = m_current_record_count * TELEMETRY_SLOT_SIZE;\n\n        // VULNERABILITY: No check that 'full_record_size' (derived from user-controlled header->payload_len)\n        // fits within 'TELEMETRY_SLOT_SIZE'. If full_record_size > TELEMETRY_SLOT_SIZE,\n        // memcpy will write past the end of the current record slot,\n        // causing a heap overflow into subsequent allocated memory or heap metadata.\n        memcpy(m_storage_buffer + write_offset_in_buffer, raw_packet, full_record_size);\n\n        m_current_record_count++;\n        return true;\n    }\n\n    size_t getStoredRecordCount() const {\n        return m_current_record_count;\n    }\n\n    const uint8_t* getStorageBuffer() const {\n        return m_storage_buffer;\n    }\n    size_t getTotalAllocatedSize() const {\n        return m_total_allocated_size;\n    }\n};",
    "fixed_code": "#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <limits>\n\n#pragma pack(push, 1)\nstruct TelemetryRecordHeaderFixed {\n    uint16_t record_id;\n    uint16_t payload_len;\n    uint32_t timestamp;\n};\n#pragma pack(pop)\n\n#define TELEMETRY_SLOT_SIZE_FIXED 256\n#define MAX_TELEMETRY_RECORDS_FIXED 10\n\nclass TelemetryDataManagerFixed {\nprivate:\n    uint8_t* m_storage_buffer;\n    size_t m_current_record_count;\n    size_t m_total_allocated_size;\n\npublic:\n    TelemetryDataManagerFixed() :\n        m_storage_buffer(nullptr),\n        m_current_record_count(0),\n        m_total_allocated_size(0)\n    {\n        if (MAX_TELEMETRY_RECORDS_FIXED > 0 &&\n            TELEMETRY_SLOT_SIZE_FIXED > (std::numeric_limits<size_t>::max() / MAX_TELEMETRY_RECORDS_FIXED)) {\n            m_total_allocated_size = 0;\n            return;\n        }\n\n        m_total_allocated_size = MAX_TELEMETRY_RECORDS_FIXED * TELEMETRY_SLOT_SIZE_FIXED;\n        m_storage_buffer = (uint8_t*)malloc(m_total_allocated_size);\n        if (!m_storage_buffer && m_total_allocated_size > 0) {\n            m_total_allocated_size = 0;\n        }\n    }\n\n    ~TelemetryDataManagerFixed() {\n        if (m_storage_buffer) {\n            free(m_storage_buffer);\n            m_storage_buffer = nullptr;\n        }\n    }\n\n    bool addTelemetryRecordFixed(const uint8_t* raw_packet, size_t packet_len) {\n        if (!m_storage_buffer || !raw_packet || packet_len < sizeof(TelemetryRecordHeaderFixed)) {\n            return false;\n        }\n\n        const TelemetryRecordHeaderFixed* header = reinterpret_cast<const TelemetryRecordHeaderFixed*>(raw_packet);\n\n        if (header->payload_len > (std::numeric_limits<uint16_t>::max() - sizeof(TelemetryRecordHeaderFixed))) {\n            return false;\n        }\n        size_t full_record_size = sizeof(TelemetryRecordHeaderFixed) + header->payload_len;\n\n        if (packet_len < full_record_size) {\n            return false;\n        }\n\n        if (m_current_record_count >= MAX_TELEMETRY_RECORDS_FIXED) {\n            return false;\n        }\n\n        size_t write_offset_in_buffer = m_current_record_count * TELEMETRY_SLOT_SIZE_FIXED;\n\n        // FIX: Ensure that 'full_record_size' does not exceed the fixed size of the allocated slot.\n        // If the incoming record is larger than a slot, reject it or truncate it as per design.\n        if (full_record_size > TELEMETRY_SLOT_SIZE_FIXED) {\n            return false;\n        }\n\n        // Defensive check: ensure the copy operation will not exceed the total allocated buffer space.\n        if (write_offset_in_buffer > m_total_allocated_size - full_record_size) {\n            return false;\n        }\n\n        memcpy(m_storage_buffer + write_offset_in_buffer, raw_packet, full_record_size);\n\n        m_current_record_count++;\n        return true;\n    }\n\n    size_t getStoredRecordCount() const {\n        return m_current_record_count;\n    }\n\n    const uint8_t* getStorageBuffer() const {\n        return m_storage_buffer;\n    }\n    size_t getTotalAllocatedSize() const {\n        return m_total_allocated_size;\n    }\n};",
    "analysis": ""
  }
]