{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_INCOMING_FAULT_MSG_SIZE 256\n#define MAX_FAULT_DESCRIPTION_LEN 64\n\ntypedef enum {\n    SEVERITY_INFO = 0,\n    SEVERITY_WARNING,\n    SEVERITY_CRITICAL\n} FaultSeverity;\n\ntypedef struct {\n    uint16_t      fault_id;\n    FaultSeverity severity;\n    char          description[MAX_FAULT_DESCRIPTION_LEN];\n} ParsedFaultEntry;\n\nstatic ParsedFaultEntry g_lastFaultEntry;\n\nvoid initFaultEntry() {\n    memset(&g_lastFaultEntry, 0, sizeof(ParsedFaultEntry));\n}\n\nint processFaultMessage(const uint8_t* raw_msg, uint16_t msg_len) {\n    if (raw_msg == NULL || msg_len < (sizeof(uint16_t) + sizeof(uint8_t) + sizeof(uint8_t))) {\n        return -1;\n    }\n\n    if (msg_len > MAX_INCOMING_FAULT_MSG_SIZE) {\n        return -2;\n    }\n\n    uint16_t current_offset = 0;\n\n    g_lastFaultEntry.fault_id = (raw_msg[current_offset] << 8) | raw_msg[current_offset + 1];\n    current_offset += sizeof(uint16_t);\n\n    g_lastFaultEntry.severity = (FaultSeverity)raw_msg[current_offset];\n    current_offset += sizeof(uint8_t);\n\n    uint8_t incoming_description_len = raw_msg[current_offset];\n    current_offset += sizeof(uint8_t);\n\n    if (current_offset + incoming_description_len > msg_len) {\n        return -3;\n    }\n\n    uint8_t bytes_to_copy = incoming_description_len;\n    if (bytes_to_copy >= MAX_FAULT_DESCRIPTION_LEN) {\n        bytes_to_copy = MAX_FAULT_DESCRIPTION_LEN - 1;\n    }\n    \n    memcpy(g_lastFaultEntry.description, raw_msg + current_offset, bytes_to_copy);\n    g_lastFaultEntry.description[bytes_to_copy] = '\\0';\n\n    return 0;\n}\n\nconst ParsedFaultEntry* getLastFaultEntry() {\n    return &g_lastFaultEntry;\n}\n\nvoid receiveSimulatedFaultData(const uint8_t* data, uint16_t len) {\n    processFaultMessage(data, len);\n}", "is_vuln": 0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define VEHICLE_CONFIG_STORAGE_SIZE 1024\n#define DIAG_RESPONSE_BUFFER_SIZE 256\n\nstatic uint8_t g_vehicleConfig[VEHICLE_CONFIG_STORAGE_SIZE];\n\nvoid initVehicleConfig() {\n    for (int i = 0; i < VEHICLE_CONFIG_STORAGE_SIZE; ++i) {\n        g_vehicleConfig[i] = (uint8_t)(i % 0xFF);\n    }\n}\n\ntypedef struct {\n    uint16_t serviceId;\n    uint16_t configAreaOffset;\n    uint16_t bytesToRead;\n} DiagReadConfigRequest;\n\ntypedef struct {\n    uint16_t serviceIdResponse;\n    uint8_t data[DIAG_RESPONSE_BUFFER_SIZE];\n    uint16_t dataLength;\n} DiagReadConfigResponse;\n\nint handleDiagReadConfigRequest(const DiagReadConfigRequest* request, DiagReadConfigResponse* response) {\n    if (request == NULL || response == NULL) {\n        return -1;\n    }\n\n    if (request->serviceId != 0x22) {\n        return -1;\n    }\n\n    uint16_t offset = request->configAreaOffset;\n    uint16_t length = request->bytesToRead;\n\n    uint16_t total_read_end_idx = offset + length;\n\n    if (total_read_end_idx > VEHICLE_CONFIG_STORAGE_SIZE) {\n        return -2;\n    }\n\n    if (offset >= VEHICLE_CONFIG_STORAGE_SIZE) {\n        return -2;\n    }\n\n    uint16_t bytes_to_copy = length;\n    if (bytes_to_copy > DIAG_RESPONSE_BUFFER_SIZE) {\n        bytes_to_copy = DIAG_RESPONSE_BUFFER_SIZE;\n    }\n\n    memcpy(response->data, g_vehicleConfig + offset, bytes_to_copy);\n\n    response->serviceIdResponse = 0x62;\n    response->dataLength = bytes_to_copy;\n\n    return 0;\n}", "is_vuln": 1}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_REPORT_PAYLOAD_SIZE 128\n#define DIAG_DATA_BUFFER_SIZE 64\n#define MAX_DIAG_DATA_ID_ENTRIES 5\n\ntypedef struct {\n    uint16_t id;\n    uint8_t  data[DIAG_DATA_BUFFER_SIZE];\n    uint8_t  current_len;\n} DiagnosticDataEntry;\n\nstatic DiagnosticDataEntry g_diagDataStore[MAX_DIAG_DATA_ID_ENTRIES];\nstatic uint8_t g_diagDataCount = 0;\n\nvoid initDiagnosticDataStore() {\n    memset(g_diagDataStore, 0, sizeof(g_diagDataStore));\n}\n\nint processDiagnosticReport(uint16_t report_id, const uint8_t* payload, uint16_t payload_len) {\n    if (payload == NULL || payload_len == 0 || payload_len > MAX_REPORT_PAYLOAD_SIZE) {\n        return -1;\n    }\n\n    if (report_id == 0x10) {\n        if (payload_len < (1 + 2 + 1)) {\n            return -2;\n        }\n\n        uint8_t entry_index = payload[0];\n        uint16_t data_id = (payload[1] << 8) | payload[2];\n        uint8_t data_len = payload[3];\n\n        if (entry_index >= MAX_DIAG_DATA_ID_ENTRIES) {\n            return -3;\n        }\n\n        if (data_len > (payload_len - (1 + 2 + 1))) {\n            return -4;\n        }\n        \n        int found_idx = -1;\n        for (int i = 0; i < g_diagDataCount; ++i) {\n            if (g_diagDataStore[i].id == data_id) {\n                found_idx = i;\n                break;\n            }\n        }\n\n        if (found_idx == -1) {\n            if (g_diagDataCount < MAX_DIAG_DATA_ID_ENTRIES) {\n                found_idx = g_diagDataCount++;\n                g_diagDataStore[found_idx].id = data_id;\n            } else {\n                return -5;\n            }\n        }\n\n        uint8_t bytes_to_copy = data_len;\n        if (bytes_to_copy > DIAG_DATA_BUFFER_SIZE) {\n            bytes_to_copy = DIAG_DATA_BUFFER_SIZE;\n        }\n\n        memcpy(g_diagDataStore[found_idx].data, payload + (1 + 2 + 1), bytes_to_copy);\n        g_diagDataStore[found_idx].current_len = bytes_to_copy;\n\n        if (data_len > DIAG_DATA_BUFFER_SIZE) {\n            return -6;\n        }\n\n        return 0;\n\n    } else if (report_id == 0x20) {\n        return 0;\n    }\n\n    return -99;\n}", "is_vuln": 0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define DIAG_MESSAGE_MAX_SIZE 1024\n#define MAX_RECORD_PAYLOAD_SIZE 128\n#define TEMP_PROCESSING_BUFFER_SIZE 64\n\ntypedef struct {\n    uint16_t message_id;\n    uint16_t total_payload_len;\n} DiagnosticMessageHeader;\n\ntypedef struct {\n    uint8_t record_type;\n    uint8_t record_len;\n} DiagnosticRecordMinimalHeader;\n\nint processDiagnosticMessage(const uint8_t* msg_buffer, uint16_t msg_len) {\n    if (msg_buffer == NULL || msg_len < sizeof(DiagnosticMessageHeader)) {\n        return -1;\n    }\n\n    uint16_t current_offset = 0;\n    \n    uint16_t message_id = (msg_buffer[0] << 8) | msg_buffer[1];\n    current_offset += sizeof(uint16_t);\n\n    uint16_t total_payload_len = (msg_buffer[current_offset] << 8) | msg_buffer[current_offset+1];\n    current_offset += sizeof(uint16_t);\n\n    if (current_offset + total_payload_len > msg_len) {\n        return -2;\n    }\n\n    uint16_t payload_bytes_processed = 0;\n    while (payload_bytes_processed < total_payload_len) {\n        if (payload_bytes_processed + sizeof(DiagnosticRecordMinimalHeader) > total_payload_len) {\n            return -3;\n        }\n\n        const DiagnosticRecordMinimalHeader* record_header = \n            (const DiagnosticRecordMinimalHeader*)(msg_buffer + current_offset + payload_bytes_processed);\n        \n        uint8_t record_type = record_header->record_type;\n        uint8_t record_data_len = record_header->record_len; \n\n        if (record_data_len > MAX_RECORD_PAYLOAD_SIZE ||\n            payload_bytes_processed + sizeof(DiagnosticRecordMinimalHeader) + record_data_len > total_payload_len) {\n            return -4;\n        }\n\n        const uint8_t* record_data_ptr = msg_buffer + current_offset + payload_bytes_processed + sizeof(DiagnosticRecordMinimalHeader);\n\n        if (record_type == 0x05) {\n            char temp_processing_buffer[TEMP_PROCESSING_BUFFER_SIZE];\n            uint8_t bytes_to_copy = record_data_len;\n\n            if (bytes_to_copy >= TEMP_PROCESSING_BUFFER_SIZE) {\n                bytes_to_copy = TEMP_PROCESSING_BUFFER_SIZE - 1;\n            }\n            \n            memcpy(temp_processing_buffer, record_data_ptr, bytes_to_copy);\n            temp_processing_buffer[bytes_to_copy] = '\\0';\n        }\n\n        payload_bytes_processed += sizeof(DiagnosticRecordMinimalHeader) + record_data_len;\n    }\n\n    return 0;\n}\n\nvoid simulateIncomingDiagnosticFrame(const uint8_t* data, uint16_t length) {\n    processDiagnosticMessage(data, length);\n}", "is_vuln": 0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define AGGREGATED_DATA_BUFFER_SIZE 256\n#define MAX_INCOMING_PACKET_SIZE 512\n\nstatic uint8_t g_aggregatedDataBuffer[AGGREGATED_DATA_BUFFER_SIZE];\nstatic uint16_t g_currentAggregatedLen = 0;\n\nvoid initDataAggregator() {\n    memset(g_aggregatedDataBuffer, 0, AGGREGATED_DATA_BUFFER_SIZE);\n    g_currentAggregatedLen = 0;\n}\n\ntypedef struct {\n    uint8_t record_type;\n    uint8_t record_length;\n} DataRecordHeader;\n\nint processDiagnosticDataPacket(const uint8_t* packet, uint16_t packet_len) {\n    if (packet == NULL || packet_len < 1) {\n        return -1;\n    }\n\n    uint16_t current_packet_offset = 0;\n    uint8_t record_count = packet[current_packet_offset++];\n\n    if (record_count == 0) {\n        g_currentAggregatedLen = 0;\n        return 0;\n    }\n    if (current_packet_offset >= packet_len) {\n        return -2;\n    }\n\n    g_currentAggregatedLen = 0;\n\n    for (int i = 0; i < record_count; ++i) {\n        if (current_packet_offset + sizeof(DataRecordHeader) > packet_len) {\n            return -3;\n        }\n\n        DataRecordHeader header;\n        header.record_type = packet[current_packet_offset];\n        current_packet_offset++;\n        header.record_length = packet[current_packet_offset];\n        current_packet_offset++;\n\n        if (current_packet_offset + header.record_length > packet_len) {\n            return -4;\n        }\n\n        for (uint8_t j = 0; j < header.record_length; ++j) {\n            g_aggregatedDataBuffer[g_currentAggregatedLen++] = packet[current_packet_offset++];\n        }\n    }\n\n    return 0;\n}\n\nvoid receiveDataPacket(const uint8_t* data, uint16_t len) {\n    processDiagnosticDataPacket(data, len);\n}", "is_vuln": 1}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_CONFIG_BLOCK_SIZE 512\n\n#define MAX_VEHICLE_NAME_LEN 32\n#define MAX_LICENSE_PLATE_LEN 16\n\n#define CONFIG_ID_VEHICLE_NAME 0x01\n#define CONFIG_ID_LICENSE_PLATE 0x02\n#define CONFIG_ID_SPEED_LIMIT_ENABLED 0x03\n#define CONFIG_ID_MAX_SPEED_VALUE 0x04\n\nstatic char g_vehicleName[MAX_VEHICLE_NAME_LEN + 1];\nstatic char g_licensePlate[MAX_LICENSE_PLATE_LEN + 1];\nstatic uint8_t g_speedLimitEnabled = 0;\nstatic uint16_t g_maxSpeedValue = 0;\n\ntypedef struct {\n    uint8_t param_id;\n    uint8_t param_len;\n} ConfigParamHeader;\n\nvoid resetVehicleConfig() {\n    memset(g_vehicleName, 0, sizeof(g_vehicleName));\n    memset(g_licensePlate, 0, sizeof(g_licensePlate));\n    g_speedLimitEnabled = 0;\n    g_maxSpeedValue = 0;\n    strcpy(g_vehicleName, \"DEFAULT_VEHICLE\");\n    strcpy(g_licensePlate, \"DEFAULT_PLATE\");\n}\n\nint applyVehicleConfiguration(const uint8_t* config_data_block, uint16_t block_len) {\n    if (config_data_block == NULL || block_len == 0 || block_len > MAX_CONFIG_BLOCK_SIZE) {\n        return -1;\n    }\n\n    uint16_t current_offset = 0;\n\n    while (current_offset < block_len) {\n        if (current_offset + sizeof(ConfigParamHeader) > block_len) {\n            return -2;\n        }\n\n        const ConfigParamHeader* header = (const ConfigParamHeader*)(config_data_block + current_offset);\n        uint8_t param_id = header->param_id;\n        uint8_t param_len = header->param_len;\n\n        if (current_offset + sizeof(ConfigParamHeader) + param_len > block_len) {\n            return -3;\n        }\n\n        const uint8_t* param_value_ptr = config_data_block + current_offset + sizeof(ConfigParamHeader);\n\n        switch (param_id) {\n            case CONFIG_ID_VEHICLE_NAME:\n                memcpy(g_vehicleName, param_value_ptr, param_len);\n                if (param_len < MAX_VEHICLE_NAME_LEN + 1) {\n                    g_vehicleName[param_len] = '\\0';\n                } else {\n                    g_vehicleName[MAX_VEHICLE_NAME_LEN] = '\\0';\n                }\n                break;\n            case CONFIG_ID_LICENSE_PLATE:\n                memcpy(g_licensePlate, param_value_ptr, param_len);\n                if (param_len < MAX_LICENSE_PLATE_LEN + 1) {\n                    g_licensePlate[param_len] = '\\0';\n                } else {\n                    g_licensePlate[MAX_LICENSE_PLATE_LEN] = '\\0';\n                }\n                break;\n            case CONFIG_ID_SPEED_LIMIT_ENABLED:\n                if (param_len == 1) {\n                    g_speedLimitEnabled = param_value_ptr[0];\n                }\n                break;\n            case CONFIG_ID_MAX_SPEED_VALUE:\n                if (param_len == sizeof(uint16_t)) {\n                    g_maxSpeedValue = (param_value_ptr[0] << 8) | param_value_ptr[1];\n                }\n                break;\n            default:\n                break;\n        }\n\n        current_offset += sizeof(ConfigParamHeader) + param_len;\n    }\n\n    return 0;\n}\n\nvoid simulateConfigUpdate(const uint8_t* data, uint16_t len) {\n    resetVehicleConfig();\n    applyVehicleConfiguration(data, len);\n}\n\nconst char* getVehicleName() {\n    return g_vehicleName;\n}\n\nconst char* getLicensePlate() {\n    return g_licensePlate;\n}", "is_vuln": 1}
{"Function before": "#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_PACKET_SIZE 1500\n#define PARAMETER_RECORD_FIXED_HEADER_SIZE (sizeof(uint16_t) + sizeof(uint8_t)) \n#define MAX_TOTAL_CONFIG_PAYLOAD_SIZE (MAX_PACKET_SIZE - sizeof(uint16_t))\n\nstatic uint8_t g_vehicleConfigMemory[512];\n\nint processVehicleConfigUpdate(const uint8_t* message_data, uint16_t message_len) {\n    if (message_data == NULL || message_len < sizeof(uint16_t)) {\n        return -1;\n    }\n\n    uint16_t num_params = (message_data[0] << 8) | message_data[1];\n    uint16_t current_read_offset = sizeof(uint16_t);\n\n    uint32_t total_payload_bytes_expected = 0;\n\n    for (uint16_t i = 0; i < num_params; ++i) {\n        if (current_read_offset + PARAMETER_RECORD_FIXED_HEADER_SIZE > message_len) {\n            return -2;\n        }\n\n        uint8_t data_len = message_data[current_read_offset + sizeof(uint16_t)];\n\n        if (current_read_offset + PARAMETER_RECORD_FIXED_HEADER_SIZE + data_len > message_len) {\n            return -3;\n        }\n\n        uint32_t param_record_size = (uint32_t)PARAMETER_RECORD_FIXED_HEADER_SIZE + data_len;\n        \n        if (total_payload_bytes_expected > (MAX_TOTAL_CONFIG_PAYLOAD_SIZE - param_record_size)) {\n            return -6;\n        }\n        total_payload_bytes_expected += param_record_size;\n\n        current_read_offset += param_record_size;\n    }\n\n    if (current_read_offset != message_len) {\n        return -4;\n    }\n\n    if (total_payload_bytes_expected > MAX_TOTAL_CONFIG_PAYLOAD_SIZE) {\n        return -8;\n    }\n    \n    uint8_t* temp_stage_buffer = (uint8_t*)malloc(total_payload_bytes_expected);\n    if (temp_stage_buffer == NULL) {\n        return -5;\n    }\n\n    memcpy(temp_stage_buffer, message_data + sizeof(uint16_t), total_payload_bytes_expected);\n\n    free(temp_stage_buffer);\n\n    return 0;\n}", "is_vuln": 0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_FIRMWARE_CHUNK_SIZE 256\n#define FIRMWARE_BLOCK_BUFFER_SIZE 4096\n#define TOTAL_FIRMWARE_IMAGE_SIZE 1048576\n\ntypedef struct {\n    uint32_t address_offset;\n    uint16_t data_length;\n    uint8_t  data[MAX_FIRMWARE_CHUNK_SIZE];\n} FirmwarePacket;\n\ntypedef struct {\n    uint32_t current_block_address;\n    uint8_t  firmware_block_buffer[FIRMWARE_BLOCK_BUFFER_SIZE];\n    uint32_t bytes_in_current_block;\n    bool     update_in_progress;\n} FirmwareUpdateContext;\n\nstatic FirmwareUpdateContext g_fwUpdateContext = {0};\n\nvoid initFirmwareUpdater() {\n    memset(&g_fwUpdateContext, 0, sizeof(FirmwareUpdateContext));\n    g_fwUpdateContext.update_in_progress = false;\n}\n\nint handleFirmwarePacket(const FirmwarePacket* packet) {\n    if (packet == NULL || packet->data_length == 0 || packet->data_length > MAX_FIRMWARE_CHUNK_SIZE) {\n        return -1;\n    }\n\n    if (!g_fwUpdateContext.update_in_progress) {\n        return -1;\n    }\n\n    uint32_t global_target_offset = packet->address_offset;\n    uint16_t chunk_len = packet->data_length;\n\n    if (global_target_offset + chunk_len > TOTAL_FIRMWARE_IMAGE_SIZE) {\n        return -2;\n    }\n\n    uint32_t packet_block_base_address = global_target_offset / FIRMWARE_BLOCK_BUFFER_SIZE * FIRMWARE_BLOCK_BUFFER_SIZE;\n    uint32_t offset_within_block = global_target_offset % FIRMWARE_BLOCK_BUFFER_SIZE;\n\n    if (g_fwUpdateContext.current_block_address != packet_block_base_address) {\n        memset(g_fwUpdateContext.firmware_block_buffer, 0, FIRMWARE_BLOCK_BUFFER_SIZE);\n        g_fwUpdateContext.bytes_in_current_block = 0;\n        g_fwUpdateContext.current_block_address = packet_block_base_address;\n    }\n\n    memcpy(g_fwUpdateContext.firmware_block_buffer + offset_within_block, packet->data, chunk_len);\n\n    if (offset_within_block + chunk_len > g_fwUpdateContext.bytes_in_current_block) {\n        g_fwUpdateContext.bytes_in_current_block = offset_within_block + chunk_len;\n    }\n\n    return 0;\n}\n\nvoid startFirmwareUpdate() {\n    g_fwUpdateContext.update_in_progress = true;\n    g_fwUpdateContext.current_block_address = 0;\n    g_fwUpdateContext.bytes_in_current_block = 0;\n    memset(g_fwUpdateContext.firmware_block_buffer, 0, FIRMWARE_BLOCK_BUFFER_SIZE);\n}\n\nvoid endFirmwareUpdate() {\n    g_fwUpdateContext.update_in_progress = false;\n}", "is_vuln": 1}
