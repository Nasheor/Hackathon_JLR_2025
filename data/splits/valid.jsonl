{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define NUM_VEHICLE_COMPONENTS 10\n#define BASE_INTERVAL_ARRAY_SIZE NUM_VEHICLE_COMPONENTS\n#define PROFILE_MODIFIER_ARRAY_SIZE (NUM_VEHICLE_COMPONENTS * 2) \n\nstatic uint16_t g_componentBaseIntervals[BASE_INTERVAL_ARRAY_SIZE];\nstatic int16_t g_componentProfileModifiers[PROFILE_MODIFIER_ARRAY_SIZE];\n\ntypedef struct {\n    uint8_t component_idx;\n    uint8_t profile_offset;\n    int8_t adjustment_value;\n} MaintenanceUpdateReq;\n\nvoid initMaintenanceSystem() {\n    memset(g_componentBaseIntervals, 0, sizeof(g_componentBaseIntervals));\n    memset(g_componentProfileModifiers, 0, sizeof(g_componentProfileModifiers));\n    for (uint8_t i = 0; i < NUM_VEHICLE_COMPONENTS; ++i) {\n        g_componentBaseIntervals[i] = 1000 + (i * 10);\n        g_componentProfileModifiers[i * 2] = 0;\n        g_componentProfileModifiers[i * 2 + 1] = -50;\n    }\n}\n\nint applyMaintenanceScheduleUpdate(const MaintenanceUpdateReq* req) {\n    if (req == NULL) {\n        return -1;\n    }\n\n    if (req->component_idx >= NUM_VEHICLE_COMPONENTS) {\n        return -2;\n    }\n\n    uint16_t effective_modifier_index = (uint16_t)(req->component_idx * 2) + req->profile_offset;\n\n    g_componentProfileModifiers[effective_modifier_index] += req->adjustment_value;\n\n    g_componentBaseIntervals[req->component_idx] += (req->adjustment_value / 2);\n\n    return 0;\n}\n\nvoid simulateMaintenanceRequest(uint8_t comp_id, uint8_t profile_off, int8_t adj_val) {\n    MaintenanceUpdateReq request = { .component_idx = comp_id, .profile_offset = profile_off, .adjustment_value = adj_val };\n    applyMaintenanceScheduleUpdate(&request);\n}", "is_vuln": 1}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define DIAG_DATA_REGION_SIZE 512\n#define MAX_COMMAND_PAYLOAD_SIZE 64\n\nstatic uint8_t g_diagDataRegion[DIAG_DATA_REGION_SIZE];\n\ntypedef struct {\n    uint16_t target_address;\n    uint8_t  data_length;\n    uint8_t  data[MAX_COMMAND_PAYLOAD_SIZE];\n} DiagWriteCommand;\n\nvoid initDiagDataRegion() {\n    memset(g_diagDataRegion, 0x00, DIAG_DATA_REGION_SIZE);\n}\n\nint processDiagWriteCommand_Fixed(const uint8_t* raw_command_data, uint16_t raw_command_len) {\n    if (raw_command_data == NULL || raw_command_len < (sizeof(uint16_t) + sizeof(uint8_t))) {\n        return -1;\n    }\n\n    DiagWriteCommand cmd;\n    cmd.target_address = (raw_command_data[0] << 8) | raw_command_data[1];\n    cmd.data_length = raw_command_data[2];\n\n    if (raw_command_len != (sizeof(uint16_t) + sizeof(uint8_t) + cmd.data_length)) {\n        return -2;\n    }\n\n    if (cmd.data_length > MAX_COMMAND_PAYLOAD_SIZE) {\n        return -3;\n    }\n\n    if (cmd.target_address >= DIAG_DATA_REGION_SIZE || (uint32_t)cmd.target_address + cmd.data_length > DIAG_DATA_REGION_SIZE) {\n        return -4;\n    }\n\n    for (uint8_t i = 0; i < cmd.data_length; ++i) {\n        g_diagDataRegion[cmd.target_address + i] = raw_command_data[3 + i];\n    }\n\n    return 0;\n}\n\nvoid receiveDiagnosticCommand_Fixed(const uint8_t* data, uint16_t len) {\n    processDiagWriteCommand_Fixed(data, len);\n}\n\nuint8_t getDiagDataByte(uint16_t index) {\n    if (index < DIAG_DATA_REGION_SIZE) {\n        return g_diagDataRegion[index];\n    }\n    return 0xFF;\n}", "is_vuln": 0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define FIRMWARE_STAGING_BUFFER_SIZE 2048 \n#define MAX_FW_PACKAGE_SIZE 4096 \n#define MAX_FW_BLOCKS 16 \n\ntypedef struct {\n    uint16_t block_id;\n    uint16_t block_offset; \n    uint16_t block_length;\n} FirmwareBlockDescriptor;\n\ntypedef struct {\n    uint16_t total_data_length; \n    uint8_t num_blocks;\n} FirmwarePackageHeader;\n\nstatic uint8_t g_firmwareStagingBuffer[FIRMWARE_STAGING_BUFFER_SIZE];\nstatic uint16_t g_stagingWritePointer = 0; \n\nvoid initFirmwareStagingSystem() {\n    memset(g_firmwareStagingBuffer, 0, FIRMWARE_STAGING_BUFFER_SIZE);\n    g_stagingWritePointer = 0;\n}\n\nint processFirmwareUpdatePackage(const uint8_t* package_payload, uint16_t payload_len) {\n    if (package_payload == NULL || payload_len < sizeof(FirmwarePackageHeader)) {\n        return -1; \n    }\n\n    FirmwarePackageHeader header;\n    header.total_data_length = (uint16_t)(package_payload[0] << 8 | package_payload[1]);\n    header.num_blocks = package_payload[2];\n\n    if (payload_len < sizeof(FirmwarePackageHeader) + (header.num_blocks * sizeof(FirmwareBlockDescriptor))) {\n        return -2; \n    }\n    if (header.num_blocks > MAX_FW_BLOCKS) {\n        return -3; \n    }\n\n    uint16_t descriptor_offset = sizeof(FirmwarePackageHeader);\n    uint16_t data_offset = descriptor_offset + (header.num_blocks * sizeof(FirmwareBlockDescriptor));\n\n    if (data_offset + header.total_data_length > payload_len) {\n        return -4; \n    }\n\n    g_stagingWritePointer = 0; \n\n    for (uint8_t i = 0; i < header.num_blocks; ++i) {\n        uint16_t current_descriptor_pos = descriptor_offset + (i * sizeof(FirmwareBlockDescriptor));\n        if (current_descriptor_pos + sizeof(FirmwareBlockDescriptor) > payload_len) {\n            return -5; \n        }\n\n        FirmwareBlockDescriptor block_desc;\n        block_desc.block_id = (uint16_t)(package_payload[current_descriptor_pos] << 8 | package_payload[current_descriptor_pos + 1]);\n        block_desc.block_offset = (uint16_t)(package_payload[current_descriptor_pos + 2] << 8 | package_payload[current_descriptor_pos + 3]);\n        block_desc.block_length = (uint16_t)(package_payload[current_descriptor_pos + 4] << 8 | package_payload[current_descriptor_pos + 5]);\n\n        if (block_desc.block_offset + block_desc.block_length > header.total_data_length) {\n            return -6; \n        }\n        if (data_offset + block_desc.block_offset + block_desc.block_length > payload_len) {\n            return -7; \n        }\n\n        if (g_stagingWritePointer + block_desc.block_length > FIRMWARE_STAGING_BUFFER_SIZE) {\n            return -8;\n        }\n\n        for (uint16_t j = 0; j < block_desc.block_length; ++j) {\n            g_firmwareStagingBuffer[g_stagingWritePointer] = package_payload[data_offset + block_desc.block_offset + j];\n            g_stagingWritePointer++;\n        }\n    }\n\n    return 0; \n}\n\nvoid receiveFirmwarePackage(const uint8_t* data, uint16_t length) {\n    initFirmwareStagingSystem();\n    processFirmwareUpdatePackage(data, length);\n}", "is_vuln": 0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define GLOBAL_CONFIG_BUFFER_SIZE 512\n\nstatic uint8_t g_vehicleConfiguration[GLOBAL_CONFIG_BUFFER_SIZE];\n\ntypedef struct {\n    uint16_t param_did;\n    uint16_t offset_in_buffer;\n    uint16_t param_size;\n} ConfigurationParameterInfo;\n\nstatic const ConfigurationParameterInfo g_configParams[] = {\n    {0x1001, 0,    128},\n    {0x1002, 128,  64},\n    {0x1003, 192,  32},\n    {0x1004, 224,  256}\n};\n#define NUM_CONFIG_PARAMS (sizeof(g_configParams) / sizeof(g_configParams[0]))\n\nvoid initVehicleConfiguration() {\n    memset(g_vehicleConfiguration, 0, GLOBAL_CONFIG_BUFFER_SIZE);\n    for (uint16_t i = 0; i < GLOBAL_CONFIG_BUFFER_SIZE; ++i) {\n        g_vehicleConfiguration[i] = (uint8_t)(i % 256);\n    }\n}\n\nint updateConfigurationSegment(uint16_t did, uint16_t segment_offset, uint16_t segment_length, const uint8_t* data) {\n    if (data == NULL || segment_length == 0) {\n        return -1;\n    }\n\n    uint16_t param_idx = (uint16_t)-1;\n    for (uint16_t i = 0; i < NUM_CONFIG_PARAMS; ++i) {\n        if (g_configParams[i].param_did == did) {\n            param_idx = i;\n            break;\n        }\n    }\n\n    if (param_idx == (uint16_t)-1) {\n        return -2;\n    }\n\n    const ConfigurationParameterInfo* param_info = &g_configParams[param_idx];\n\n    if ((uint32_t)segment_offset + segment_length > param_info->param_size) {\n        return -3;\n    }\n\n    uint16_t dest_abs_offset = param_info->offset_in_buffer + segment_offset;\n\n    if ((uint32_t)dest_abs_offset + segment_length > GLOBAL_CONFIG_BUFFER_SIZE) {\n        return -4;\n    }\n\n    for (uint16_t i = 0; i < segment_length; ++i) {\n        g_vehicleConfiguration[dest_abs_offset + i] = data[i];\n    }\n\n    return 0;\n}\n\nvoid handleDiagnosticRequest(uint16_t did, uint16_t offset, uint16_16t len, const uint8_t* payload) {\n    updateConfigurationSegment(did, offset, len, payload);\n}", "is_vuln": 0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define NUM_CONFIG_BANKS 4\n#define CONFIG_BANK_SIZE 128\n\nstatic uint8_t g_vehicleConfigMemory[NUM_CONFIG_BANKS][CONFIG_BANK_SIZE];\n\ntypedef struct {\n    uint8_t* current_bank_ptr;\n    uint8_t  bank_index;\n    uint16_t total_banks_size;\n} ConfigManagerContext;\n\nstatic ConfigManagerContext g_configManager;\n\nvoid initConfigManager() {\n    memset(g_vehicleConfigMemory, 0, sizeof(g_vehicleConfigMemory));\n    g_configManager.current_bank_ptr = NULL;\n    g_configManager.bank_index = 0xFF;\n    g_configManager.total_banks_size = NUM_CONFIG_BANKS * CONFIG_BANK_SIZE;\n}\n\nint selectConfigBank(uint8_t bank_idx) {\n    if (bank_idx >= NUM_CONFIG_BANKS) {\n        g_configManager.current_bank_ptr = NULL;\n        g_configManager.bank_index = 0xFF;\n        return -1;\n    }\n    g_configManager.current_bank_ptr = g_vehicleConfigMemory[bank_idx];\n    g_configManager.bank_index = bank_idx;\n    return 0;\n}\n\nint updateConfigParameter(const uint8_t* raw_msg, uint16_t msg_len) {\n    if (g_configManager.current_bank_ptr == NULL || g_configManager.bank_index == 0xFF) {\n        return -1;\n    }\n\n    if (raw_msg == NULL || msg_len < 2) {\n        return -2;\n    }\n\n    uint8_t offset_in_bank = raw_msg[0];\n    uint8_t data_len = raw_msg[1];\n\n    if (data_len == 0) {\n        return 0;\n    }\n\n    if (msg_len < (2 + data_len)) {\n        return -3;\n    }\n\n    if ((uint16_t)offset_in_bank + data_len > CONFIG_BANK_SIZE) {\n        return -4;\n    }\n\n    const uint8_t* data_source = raw_msg + 2;\n\n    for (uint8_t i = 0; i < data_len; ++i) {\n        g_configManager.current_bank_ptr[offset_in_bank + i] = data_source[i];\n    }\n\n    return 0;\n}\n\nvoid handleIncomingConfigMessage(uint8_t bank_id, const uint8_t* data, uint16_t len) {\n    if (selectConfigBank(bank_id) == 0) {\n        updateConfigParameter(data, len);\n    }\n}", "is_vuln": 0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX_PACKET_PAYLOAD_SIZE 500\n#define TELEMETRY_HEADER_SIZE 5\n\n#define TEMP_DISPLAY_BUFFER_CAPACITY 80\n\ntypedef enum {\n    TELEMETRY_TYPE_INVALID = 0x00,\n    TELEMETRY_TYPE_SENSOR_READING = 0x01,\n    TELEMETRY_TYPE_EVENT_LOG = 0x02,\n    TELEMETRY_TYPE_DIAGNOSTIC_FAULT = 0x03\n} TelemetryPacketType;\n\nvoid displayEventDescription(const uint8_t* description_data, uint8_t description_len) {\n    char temp_display_buffer[TEMP_DISPLAY_BUFFER_CAPACITY];\n\n    if (description_data == NULL) {\n        return;\n    }\n\n    memcpy(temp_display_buffer, description_data, description_len);\n\n    if (description_len < TEMP_DISPLAY_BUFFER_CAPACITY) {\n        temp_display_buffer[description_len] = '\\0';\n    } else {\n        temp_display_buffer[TEMP_DISPLAY_BUFFER_CAPACITY - 1] = '\\0';\n    }\n}\n\nint handleIncomingTelemetryFrame(const uint8_t* frame_data, uint16_t frame_len) {\n    if (frame_data == NULL || frame_len < TELEMETRY_HEADER_SIZE) {\n        return -1;\n    }\n\n    uint16_t packet_id = (frame_data[0] << 8) | frame_data[1];\n    uint8_t packet_type = frame_data[2];\n    uint16_t payload_len = (frame_data[3] << 8) | frame_data[4];\n\n    if (TELEMETRY_HEADER_SIZE + payload_len > frame_len) {\n        return -1;\n    }\n\n    if (payload_len > MAX_PACKET_PAYLOAD_SIZE) {\n        return -1;\n    }\n\n    const uint8_t* payload_ptr = frame_data + TELEMETRY_HEADER_SIZE;\n\n    switch (packet_type) {\n        case TELEMETRY_TYPE_EVENT_LOG: {\n            uint16_t min_event_payload_size = sizeof(uint32_t) + sizeof(uint16_t) + sizeof(uint8_t);\n            if (payload_len < min_event_payload_size) {\n                return -1;\n            }\n\n            uint32_t timestamp = (payload_ptr[0] << 24) | (payload_ptr[1] << 16) |\n                                 (payload_ptr[2] << 8) | payload_ptr[3];\n            uint16_t event_code = (payload_ptr[4] << 8) | payload_ptr[5];\n            uint8_t description_len = payload_ptr[6];\n\n            if (description_len > (payload_len - min_event_payload_size)) {\n                return -1;\n            }\n\n            const uint8_t* description_ptr = payload_ptr + min_event_payload_size;\n\n            displayEventDescription(description_ptr, description_len);\n            break;\n        }\n        case TELEMETRY_TYPE_SENSOR_READING:\n            break;\n        case TELEMETRY_TYPE_DIAGNOSTIC_FAULT:\n            break;\n        default:\n            return -1;\n    }\n\n    return 0;\n}", "is_vuln": 1}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_DIAG_PAYLOAD 64\n#define DIAG_EVENT_LOG_CAPACITY 10\n\ntypedef struct {\n    uint8_t  event_type;\n    uint8_t  log_level;\n    uint8_t  payload_actual_len;\n    uint8_t  payload[MAX_DIAG_PAYLOAD];\n    uint32_t timestamp;\n} DiagnosticEvent;\n\nstatic DiagnosticEvent g_diagEventLog[DIAG_EVENT_LOG_CAPACITY];\nstatic uint8_t g_currentLogIndex = 0;\n\nvoid initDiagEventLog() {\n    memset(g_diagEventLog, 0, sizeof(g_diagEventLog));\n    g_currentLogIndex = 0;\n}\n\nstatic int addEventToLog(const DiagnosticEvent* event) {\n    if (g_currentLogIndex >= DIAG_EVENT_LOG_CAPACITY) {\n        return -1;\n    }\n    memcpy(&g_diagEventLog[g_currentLogIndex], event, sizeof(DiagnosticEvent));\n    g_currentLogIndex++;\n    return 0;\n}\n\nint processIncomingDiagData(const uint8_t* raw_data, uint16_t raw_data_len) {\n    if (raw_data == NULL || raw_data_len < 3) {\n        return -1;\n    }\n\n    uint8_t event_type = raw_data[0];\n    uint8_t log_level = raw_data[1];\n    uint8_t incoming_payload_len = raw_data[2];\n\n    if (raw_data_len < (3 + incoming_payload_len)) {\n        return -2;\n    }\n\n    DiagnosticEvent temp_event;\n    temp_event.event_type = event_type;\n    temp_event.log_level = log_level;\n    temp_event.payload_actual_len = incoming_payload_len;\n    temp_event.timestamp = 0xDEADBEEF;\n\n    memcpy(temp_event.payload, raw_data + 3, incoming_payload_len);\n\n    return addEventToLog(&temp_event);\n}\n\nvoid receiveNetworkDiagMessage(const uint8_t* message_buffer, uint16_t buffer_len) {\n    processIncomingDiagData(message_buffer, buffer_len);\n}", "is_vuln": 1}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_COMMAND_PACKET_SIZE 512\n#define VEHICLE_STATUS_BUFFER_SIZE 128\n#define COMMAND_HEADER_SIZE (sizeof(uint16_t) * 2)\n\nstatic uint8_t g_vehicleStatusData[VEHICLE_STATUS_BUFFER_SIZE];\n\nvoid initializeVehicleStatus() {\n    memset(g_vehicleStatusData, 0, VEHICLE_STATUS_BUFFER_SIZE);\n}\n\nint processStatusUpdatePayload(uint8_t target_offset, const uint8_t* source_data_ptr, uint16_t data_to_copy_len) {\n    if (source_data_ptr == NULL || data_to_copy_len == 0) {\n        return -1;\n    }\n\n    if (target_offset >= VEHICLE_STATUS_BUFFER_SIZE) {\n        return -3;\n    }\n\n    for (uint16_t i = 0; i < data_to_copy_len; ++i) {\n        g_vehicleStatusData[target_offset + i] = source_data_ptr[i];\n    }\n\n    return 0;\n}\n\nint handleVehicleCommandPacket(const uint8_t* packet_data, uint16_t packet_len) {\n    if (packet_data == NULL || packet_len < COMMAND_HEADER_SIZE) {\n        return -1;\n    }\n\n    uint16_t current_read_offset = 0;\n\n    while (current_read_offset + COMMAND_HEADER_SIZE <= packet_len) {\n        uint16_t cmd_id = (packet_data[current_read_offset] << 8) | packet_data[current_read_offset + 1];\n        uint16_t cmd_payload_len = (packet_data[current_read_offset + 2] << 8) | packet_data[current_read_offset + 3];\n        current_read_offset += COMMAND_HEADER_SIZE;\n\n        if (cmd_payload_len > (packet_len - current_read_offset)) {\n            return -2;\n        }\n\n        const uint8_t* command_payload_data_ptr = packet_data + current_read_offset;\n\n        if (cmd_id == 0x0101) {\n            if (cmd_payload_len >= 1) {\n                uint8_t target_offset = command_payload_data_ptr[0];\n                const uint8_t* data_to_copy_ptr = command_payload_data_ptr + 1;\n                uint16_t actual_data_len = cmd_payload_len - 1;\n\n                int res = processStatusUpdatePayload(target_offset, data_to_copy_ptr, actual_data_len);\n                if (res != 0) {\n                    return res;\n                }\n            }\n        }\n        \n        current_read_offset += cmd_payload_len;\n    }\n    return 0;\n}\n\nuint8_t getVehicleStatusByte(uint8_t index) {\n    if (index < VEHICLE_STATUS_BUFFER_SIZE) {\n        return g_vehicleStatusData[index];\n    }\n    return 0xFF;\n}", "is_vuln": 1}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define CONFIG_TABLE_SIZE 256 \n\nstatic uint8_t g_configTable[CONFIG_TABLE_SIZE];\n\ntypedef enum {\n    CFG_TYPE_UINT8 = 0,\n    CFG_TYPE_UINT16,\n    CFG_TYPE_UINT32,\n    CFG_TYPE_MAX\n} ConfigDataType;\n\nstatic uint8_t getConfigTypeSize(ConfigDataType type) {\n    switch (type) {\n        case CFG_TYPE_UINT8:  return 1;\n        case CFG_TYPE_UINT16: return 2;\n        case CFG_TYPE_UINT32: return 4;\n        default: return 0;\n    }\n}\n\ntypedef struct {\n    uint16_t entry_id;\n    uint16_t offset;\n    ConfigDataType data_type;\n} ConfigEntryDescriptor;\n\nstatic const ConfigEntryDescriptor g_cfgDescriptors[] = {\n    {0x1001, 0, CFG_TYPE_UINT16},\n    {0x1002, 2, CFG_TYPE_UINT8},\n    {0x1003, 3, CFG_TYPE_UINT32},\n    {0x1004, 7, CFG_TYPE_UINT16},\n    {0x2001, 250, CFG_TYPE_UINT8},\n    {0x2002, 255, CFG_TYPE_UINT16}\n};\n#define NUM_CFG_ENTRIES (sizeof(g_cfgDescriptors) / sizeof(ConfigEntryDescriptor))\n\nvoid initConfigTable() {\n    memset(g_configTable, 0, CONFIG_TABLE_SIZE);\n}\n\nint updateConfigEntryValue(uint16_t entry_id, const uint8_t* new_value_bytes, uint8_t max_value_len) {\n    if (new_value_bytes == NULL || max_value_len == 0) {\n        return -1;\n    }\n\n    const ConfigEntryDescriptor* target_entry = NULL;\n    for (int i = 0; i < NUM_CFG_ENTRIES; ++i) {\n        if (g_cfgDescriptors[i].entry_id == entry_id) {\n            target_entry = &g_cfgDescriptors[i];\n            break;\n        }\n    }\n\n    if (target_entry == NULL) {\n        return -2;\n    }\n\n    uint8_t required_size = getConfigTypeSize(target_entry->data_type);\n\n    if (required_size == 0 || required_size > max_value_len) {\n        return -3;\n    }\n\n    if ((uint32_t)target_entry->offset + required_size > CONFIG_TABLE_SIZE) {\n        return -5;\n    }\n\n    switch (target_entry->data_type) {\n        case CFG_TYPE_UINT8:\n            g_configTable[target_entry->offset] = new_value_bytes[0];\n            break;\n        case CFG_TYPE_UINT16:\n            *(uint16_t*)(g_configTable + target_entry->offset) = *(uint16_t*)new_value_bytes;\n            break;\n        case CFG_TYPE_UINT32:\n            *(uint32_t*)(g_configTable + target_entry->offset) = *(uint32_t*)new_value_bytes;\n            break;\n        default:\n            return -4;\n    }\n\n    return 0;\n}\n\nvoid simulateConfigUpdate(uint16_t id, const uint8_t* data, uint8_t len) {\n    updateConfigEntryValue(id, data, len);\n}\n\nuint8_t getConfigByte(uint16_t offset) {\n    if (offset < CONFIG_TABLE_SIZE) {\n        return g_configTable[offset];\n    }\n    return 0xFF;\n}", "is_vuln": 0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define SENSOR_CALIBRATION_MAX_POINTS 128\n#define DIAG_PACKET_MAX_PAYLOAD_SIZE 256\n\nstatic uint16_t g_sensorCalibration[SENSOR_CALIBRATION_MAX_POINTS];\n\ntypedef struct {\n    uint8_t command_id;\n    uint8_t sub_command;\n    uint16_t start_index;\n    uint16_t num_points;\n    uint8_t  payload[DIAG_PACKET_MAX_PAYLOAD_SIZE];\n} DiagnosticCommandPacket;\n\nvoid initSensorCalibration() {\n    for (int i = 0; i < SENSOR_CALIBRATION_MAX_POINTS; ++i) {\n        g_sensorCalibration[i] = 0xAAAA;\n    }\n}\n\nint processCalibrationUpdateCommand(const DiagnosticCommandPacket* packet, uint16_t packet_size) {\n    if (packet == NULL || packet_size < sizeof(DiagnosticCommandPacket) - DIAG_PACKET_MAX_PAYLOAD_SIZE) {\n        return -1;\n    }\n\n    if (packet->command_id != 0x01 || packet->sub_command != 0x01) {\n        return -2;\n    }\n\n    uint16_t requested_start_index = packet->start_index;\n    uint16_t requested_num_points = packet->num_points;\n\n    if (requested_num_points > (DIAG_PACKET_MAX_PAYLOAD_SIZE / sizeof(uint16_t))) {\n        return -3;\n    }\n\n    if (requested_start_index >= SENSOR_CALIBRATION_MAX_POINTS) {\n        return -4;\n    }\n\n    const uint16_t* new_values = (const uint16_t*)packet->payload;\n\n    for (uint16_t i = 0; i < requested_num_points; ++i) {\n        g_sensorCalibration[requested_start_index + i] = new_values[i];\n    }\n\n    return 0;\n}\n\nvoid receiveDiagnosticMessage(const uint8_t* raw_message, uint16_t raw_message_len) {\n    initSensorCalibration();\n    processCalibrationUpdateCommand((const DiagnosticCommandPacket*)raw_message, raw_message_len);\n}\n\nuint16_t getSensorCalibrationValue(uint16_t index) {\n    if (index < SENSOR_CALIBRATION_MAX_POINTS) {\n        return g_sensorCalibration[index];\n    }\n    return 0xFFFF;\n}", "is_vuln": 1}
{"Function before": "#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_PACKET_SIZE 1500\n#define PARAMETER_RECORD_FIXED_HEADER_SIZE (sizeof(uint16_t) + sizeof(uint8_t)) \n\nstatic uint8_t g_vehicleConfigMemory[512];\n\nint processVehicleConfigUpdate(const uint8_t* message_data, uint16_t message_len) {\n    if (message_data == NULL || message_len < sizeof(uint16_t)) {\n        return -1;\n    }\n\n    uint16_t num_params = (message_data[0] << 8) | message_data[1];\n    uint16_t current_read_offset = sizeof(uint16_t);\n\n    uint16_t total_payload_bytes_expected = 0;\n\n    for (uint16_t i = 0; i < num_params; ++i) {\n        if (current_read_offset + PARAMETER_RECORD_FIXED_HEADER_SIZE > message_len) {\n            return -2;\n        }\n\n        uint8_t data_len = message_data[current_read_offset + sizeof(uint16_t)];\n\n        if (current_read_offset + PARAMETER_RECORD_FIXED_HEADER_SIZE + data_len > message_len) {\n            return -3;\n        }\n\n        uint16_t param_record_size = PARAMETER_RECORD_FIXED_HEADER_SIZE + data_len;\n        total_payload_bytes_expected += param_record_size;\n\n        current_read_offset += param_record_size;\n    }\n\n    if (current_read_offset != message_len) {\n        return -4;\n    }\n\n    uint8_t* temp_stage_buffer = (uint8_t*)malloc(total_payload_bytes_expected);\n    if (temp_stage_buffer == NULL) {\n        return -5;\n    }\n\n    memcpy(temp_stage_buffer, message_data + sizeof(uint16_t), message_len - sizeof(uint16_t));\n\n    free(temp_stage_buffer);\n\n    return 0;\n}", "is_vuln": 1}
{"Function before": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define CONFIG_NAME_MAX_LEN 32\n#define CONFIG_VALUE_MAX_LEN 64\n#define MAX_CONFIG_PARAMS 10\n\ntypedef enum {\n    PARAM_TYPE_UINT8,\n    PARAM_TYPE_UINT16,\n    PARAM_TYPE_UINT32,\n    PARAM_TYPE_STRING,\n    PARAM_TYPE_BOOL\n} ConfigParamType;\n\ntypedef struct {\n    char name[CONFIG_NAME_MAX_LEN];\n    ConfigParamType type;\n    uint8_t value_len;\n    union {\n        uint8_t  u8_val;\n        uint16_t u16_val;\n        uint32_t u32_val;\n        char     str_val[CONFIG_VALUE_MAX_LEN];\n        bool     bool_val;\n    } value;\n} ConfigurationParameter;\n\nstatic ConfigurationParameter g_vehicleConfig[MAX_CONFIG_PARAMS];\nstatic uint8_t g_numConfigParams = 0;\n\nint parseConfigurationParameter(const uint8_t* stream, uint16_t stream_len, ConfigurationParameter* param_out) {\n    if (stream == NULL || param_out == NULL || stream_len < 2) {\n        return -1;\n    }\n\n    uint16_t bytes_consumed = 0;\n\n    uint8_t name_len = stream[bytes_consumed++];\n    if (name_len >= CONFIG_NAME_MAX_LEN || bytes_consumed + name_len > stream_len) {\n        return -1;\n    }\n    memcpy(param_out->name, stream + bytes_consumed, name_len);\n    param_out->name[name_len] = '\\0';\n    bytes_consumed += name_len;\n\n    param_out->type = (ConfigParamType)stream[bytes_consumed++];\n    if (bytes_consumed > stream_len) {\n        return -1;\n    }\n\n    switch (param_out->type) {\n        case PARAM_TYPE_UINT8:\n            if (bytes_consumed + sizeof(uint8_t) > stream_len) return -1;\n            param_out->value.u8_val = stream[bytes_consumed];\n            param_out->value_len = sizeof(uint8_t);\n            bytes_consumed += sizeof(uint8_t);\n            break;\n        case PARAM_TYPE_UINT16:\n            if (bytes_consumed + sizeof(uint16_t) > stream_len) return -1;\n            param_out->value.u16_val = (uint16_t)((stream[bytes_consumed] << 8) | stream[bytes_consumed+1]);\n            param_out->value_len = sizeof(uint16_t);\n            bytes_consumed += sizeof(uint16_t);\n            break;\n        case PARAM_TYPE_UINT32:\n            if (bytes_consumed + sizeof(uint32_t) > stream_len) return -1;\n            param_out->value.u32_val = (uint32_t)((stream[bytes_consumed] << 24) | (stream[bytes_consumed+1] << 16) |\n                                                   (stream[bytes_consumed+2] << 8) | stream[bytes_consumed+3]);\n            param_out->value_len = sizeof(uint32_t);\n            bytes_consumed += sizeof(uint32_t);\n            break;\n        case PARAM_TYPE_BOOL:\n            if (bytes_consumed + sizeof(bool) > stream_len) return -1;\n            param_out->value.bool_val = (bool)stream[bytes_consumed];\n            param_out->value_len = sizeof(bool);\n            bytes_consumed += sizeof(bool);\n            break;\n        case PARAM_TYPE_STRING:\n            if (bytes_consumed >= stream_len) return -1;\n            uint8_t str_actual_len = stream[bytes_consumed++];\n            if (str_actual_len >= CONFIG_VALUE_MAX_LEN || bytes_consumed + str_actual_len > stream_len) {\n                return -1;\n            }\n            memcpy(param_out->value.str_val, stream + bytes_consumed, str_actual_len);\n            param_out->value.str_val[str_actual_len] = '\\0';\n            param_out->value_len = str_actual_len;\n            bytes_consumed += str_actual_len;\n            break;\n        default:\n            return -1;\n    }\n\n    return bytes_consumed;\n}\n\nint loadVehicleConfiguration(const uint8_t* config_stream, uint16_t stream_total_len) {\n    if (config_stream == NULL || stream_total_len == 0) {\n        return -1;\n    }\n\n    uint16_t current_stream_pos = 0;\n    g_numConfigParams = 0;\n\n    while (current_stream_pos < stream_total_len && g_numConfigParams < MAX_CONFIG_PARAMS) {\n        int bytes_parsed = parseConfigurationParameter(\n                                config_stream + current_stream_pos,\n                                stream_total_len - current_stream_pos,\n                                &g_vehicleConfig[g_numConfigParams]\n                           );\n\n        if (bytes_parsed <= 0) {\n            return -1;\n        }\n        current_stream_pos += bytes_parsed;\n        g_numConfigParams++;\n    }\n\n    return 0;\n}", "is_vuln": 0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_LOG_ENTRIES 200\n#define LOG_ENTRY_SIZE 10\n#define TELEMETRY_BUFFER_TOTAL_SIZE (MAX_LOG_ENTRIES * LOG_ENTRY_SIZE)\n\nstatic uint8_t g_telemetryLogBuffer[TELEMETRY_BUFFER_TOTAL_SIZE];\nstatic uint16_t g_logWriteHead = 0;\nstatic uint16_t g_currentValidBytes = 0;\n\nvoid initTelemetryLogger() {\n    memset(g_telemetryLogBuffer, 0, TELEMETRY_BUFFER_TOTAL_SIZE);\n    g_logWriteHead = 0;\n    g_currentValidBytes = 0;\n}\n\nint addTelemetryEntry(const uint8_t* entry_data) {\n    if (entry_data == NULL) {\n        return -1;\n    }\n\n    for (uint8_t i = 0; i < LOG_ENTRY_SIZE; ++i) {\n        g_telemetryLogBuffer[g_logWriteHead] = entry_data[i];\n        g_logWriteHead = (g_logWriteHead + 1) % TELEMETRY_BUFFER_TOTAL_SIZE;\n    }\n\n    if (g_currentValidBytes < TELEMETRY_BUFFER_TOTAL_SIZE) {\n        g_currentValidBytes += LOG_ENTRY_SIZE;\n    }\n    return 0;\n}\n\nint getLatestTelemetryEntries(uint16_t num_requested_entries, uint8_t* response_buffer, uint16_t response_buffer_size) {\n    if (response_buffer == NULL) {\n        return -1;\n    }\n\n    if (num_requested_entries == 0) {\n        return 0;\n    }\n\n    uint16_t max_entries_for_dest_buffer = response_buffer_size / LOG_ENTRY_SIZE;\n    uint16_t max_entries_available_in_log = g_currentValidBytes / LOG_ENTRY_SIZE;\n\n    uint16_t actual_entries_to_copy = num_requested_entries;\n    if (actual_entries_to_copy > max_entries_for_dest_buffer) {\n        actual_entries_to_copy = max_entries_for_dest_buffer;\n    }\n    if (actual_entries_to_copy > max_entries_available_in_log) {\n        actual_entries_to_copy = max_entries_available_in_log;\n    }\n    \n    uint16_t actual_bytes_to_copy = actual_entries_to_copy * LOG_ENTRY_SIZE;\n\n    if (actual_entries_to_copy == 0) {\n        return 0;\n    }\n\n    uint16_t start_byte_offset;\n    if (g_currentValidBytes < TELEMETRY_BUFFER_TOTAL_SIZE) {\n        if (actual_bytes_to_copy > g_currentValidBytes) {\n            start_byte_offset = 0;\n        } else {\n            start_byte_offset = (g_logWriteHead + TELEMETRY_BUFFER_TOTAL_SIZE - g_currentValidBytes + (g_currentValidBytes - actual_bytes_to_copy)) % TELEMETRY_BUFFER_TOTAL_SIZE;\n        }\n    } else {\n        start_byte_offset = (g_logWriteHead + TELEMETRY_BUFFER_TOTAL_SIZE - actual_bytes_to_copy) % TELEMETRY_BUFFER_TOTAL_SIZE;\n    }\n    start_byte_offset %= TELEMETRY_BUFFER_TOTAL_SIZE;\n\n    for (uint16_t i = 0; i < actual_entries_to_copy; ++i) {\n        for (uint8_t j = 0; j < LOG_ENTRY_SIZE; ++j) {\n            uint16_t source_idx = (start_byte_offset + (i * LOG_ENTRY_SIZE) + j) % TELEMETRY_BUFFER_TOTAL_SIZE;\n            response_buffer[(i * LOG_ENTRY_SIZE) + j] = g_telemetryLogBuffer[source_idx];\n        }\n    }\n\n    return actual_bytes_to_copy;\n}\n\nvoid handleDiagnosticRequest(uint16_t command_id, uint16_t param1, uint8_t* diag_resp_buf, uint16_t diag_resp_buf_len) {\n    if (command_id == 0x1234) {\n        getLatestTelemetryEntries(param1, diag_resp_buf, diag_resp_buf_len);\n    }\n}\n", "is_vuln": 0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define TELEMETRY_BUFFER_SIZE 256\n#define MAX_PAYLOAD_PER_EVENT 64 \n\nstatic uint8_t g_telemetryCircularBuffer[TELEMETRY_BUFFER_SIZE];\nstatic uint16_t g_writeIndex = 0; \nstatic uint16_t g_dataLength = 0; \n\ntypedef struct {\n    uint16_t timestamp;   \n    uint8_t event_id;     \n    uint8_t payload_len;  \n} TelemetryEventHeader;\n\nvoid initTelemetryBuffer() {\n    memset(g_telemetryCircularBuffer, 0, TELEMETRY_BUFFER_SIZE);\n    g_writeIndex = 0;\n    g_dataLength = 0;\n}\n\nint addTelemetryEvent(const uint8_t* event_data, uint16_t data_len) {\n    if (event_data == NULL || data_len < sizeof(TelemetryEventHeader)) {\n        return -1; \n    }\n\n    uint16_t received_timestamp = (event_data[0] << 8) | event_data[1];\n    uint8_t received_event_id = event_data[2];\n    uint8_t received_payload_len = event_data[3];\n\n    uint16_t total_event_size = sizeof(TelemetryEventHeader) + received_payload_len;\n\n    if (received_payload_len > MAX_PAYLOAD_PER_EVENT) {\n        return -2; \n    }\n\n    if (total_event_size != data_len) {\n        return -3; \n    }\n\n    for (uint16_t i = 0; i < total_event_size; ++i) {\n        g_telemetryCircularBuffer[g_writeIndex + i] = event_data[i]; \n    }\n\n    g_writeIndex = (g_writeIndex + total_event_size) % TELEMETRY_BUFFER_SIZE;\n\n    g_dataLength += total_event_size;\n    if (g_dataLength > TELEMETRY_BUFFER_SIZE) {\n        g_dataLength = TELEMETRY_BUFFER_SIZE; \n    }\n\n    return 0; \n}\n\nvoid receiveTelemetryData(const uint8_t* data, uint16_t len) {\n    addTelemetryEvent(data, len);\n}\n\nuint8_t getTelemetryByte(uint16_t index) {\n    if (index < TELEMETRY_BUFFER_SIZE) {\n        return g_telemetryCircularBuffer[index];\n    }\n    return 0xFF;\n}", "is_vuln": 1}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define DATA_LOG_BUFFER_SIZE 256\n#define MAX_LOG_ENTRY_PAYLOAD_SIZE 60\n\ntypedef struct {\n    uint8_t  type;\n    uint8_t  payload_len;\n} LogEntryHeader;\n\nstatic uint8_t g_logBuffer[DATA_LOG_BUFFER_SIZE];\nstatic uint16_t g_logBufferWriteHead = 0;\n\nvoid initDataLogger() {\n    memset(g_logBuffer, 0, DATA_LOG_BUFFER_SIZE);\n    g_logBufferWriteHead = 0;\n}\n\nint addLogEntry(uint8_t type, const uint8_t* payload_data, uint8_t payload_len) {\n    if (payload_data == NULL) {\n        return -1;\n    }\n\n    if (payload_len > MAX_LOG_ENTRY_PAYLOAD_SIZE) {\n        return -2;\n    }\n\n    uint16_t required_total_entry_size = sizeof(LogEntryHeader) + payload_len;\n\n    if (required_total_entry_size > DATA_LOG_BUFFER_SIZE) {\n        return -3;\n    }\n\n    // Construct the header\n    LogEntryHeader header = { .type = type, .payload_len = payload_len };\n\n    // Write header to current position\n    memcpy(g_logBuffer + g_logBufferWriteHead, &header, sizeof(LogEntryHeader));\n    uint16_t current_entry_payload_offset = g_logBufferWriteHead + sizeof(LogEntryHeader);\n\n    // Write payload data following the header\n    // VULNERABILITY: If current_entry_payload_offset + payload_len extends beyond DATA_LOG_BUFFER_SIZE,\n    // this memcpy will write out-of-bounds, even though the total required_total_entry_size fits\n    // into the conceptual circular buffer space. The single memcpy doesn't handle wrapping.\n    memcpy(g_logBuffer + current_entry_payload_offset, payload_data, payload_len);\n\n    // Update write head for the next entry, correctly handling circular buffer logic\n    g_logBufferWriteHead = (g_logBufferWriteHead + required_total_entry_size) % DATA_LOG_BUFFER_SIZE;\n\n    return 0;\n}\n\n// Dummy function to simulate usage in a larger context (e.g., error handling)\nvoid simulateSensorDTCLog(uint8_t dtc_code, const uint8_t* dtc_data, uint8_t data_len) {\n    // In a real scenario, dtc_data might contain additional diagnostic info\n    // The dtc_code itself could be part of the payload or processed separately.\n    // Here, we just pass the raw data.\n    addLogEntry(dtc_code, dtc_data, data_len);\n}", "is_vuln": 1}
{"Function before": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define DIAG_MESSAGE_MAX_SIZE 1024\n#define MAX_RECORD_PAYLOAD_SIZE 128\n#define TEMP_PROCESSING_BUFFER_SIZE 64\n\ntypedef struct {\n    uint16_t message_id;\n    uint16_t total_payload_len;\n} DiagnosticMessageHeader;\n\ntypedef struct {\n    uint8_t record_type;\n    uint8_t record_len;\n} DiagnosticRecordMinimalHeader;\n\nint processDiagnosticMessage(const uint8_t* msg_buffer, uint16_t msg_len) {\n    if (msg_buffer == NULL || msg_len < sizeof(DiagnosticMessageHeader)) {\n        return -1;\n    }\n\n    uint16_t current_offset = 0;\n    \n    uint16_t message_id = (msg_buffer[0] << 8) | msg_buffer[1];\n    current_offset += sizeof(uint16_t);\n\n    uint16_t total_payload_len = (msg_buffer[current_offset] << 8) | msg_buffer[current_offset+1];\n    current_offset += sizeof(uint16_t);\n\n    if (current_offset + total_payload_len > msg_len) {\n        return -2;\n    }\n\n    uint16_t payload_bytes_processed = 0;\n    while (payload_bytes_processed < total_payload_len) {\n        if (payload_bytes_processed + sizeof(DiagnosticRecordMinimalHeader) > total_payload_len) {\n            return -3;\n        }\n\n        const DiagnosticRecordMinimalHeader* record_header = \n            (const DiagnosticRecordMinimalHeader*)(msg_buffer + current_offset + payload_bytes_processed);\n        \n        uint8_t record_type = record_header->record_type;\n        uint8_t record_data_len = record_header->record_len; \n\n        if (record_data_len > MAX_RECORD_PAYLOAD_SIZE ||\n            payload_bytes_processed + sizeof(DiagnosticRecordMinimalHeader) + record_data_len > total_payload_len) {\n            return -4;\n        }\n\n        const uint8_t* record_data_ptr = msg_buffer + current_offset + payload_bytes_processed + sizeof(DiagnosticRecordMinimalHeader);\n\n        if (record_type == 0x05) {\n            char temp_processing_buffer[TEMP_PROCESSING_BUFFER_SIZE];\n\n            memcpy(temp_processing_buffer, record_data_ptr, record_data_len);\n\n            if (record_data_len < TEMP_PROCESSING_BUFFER_SIZE) {\n                temp_processing_buffer[record_data_len] = '\\0';\n            } else {\n                temp_processing_buffer[TEMP_PROCESSING_BUFFER_SIZE - 1] = '\\0';\n            }\n        }\n\n        payload_bytes_processed += sizeof(DiagnosticRecordMinimalHeader) + record_data_len;\n    }\n\n    return 0;\n}\n\nvoid simulateIncomingDiagnosticFrame(const uint8_t* data, uint16_t length) {\n    processDiagnosticMessage(data, length);\n}", "is_vuln": 1}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define FIRMWARE_CONFIG_BUFFER_SIZE 256\n#define MAX_INCOMING_PARAM_DATA_SIZE 64\n\nstatic uint8_t g_firmwareConfigData[FIRMWARE_CONFIG_BUFFER_SIZE];\n\nvoid initFirmwareConfig() {\n    memset(g_firmwareConfigData, 0x00, FIRMWARE_CONFIG_BUFFER_SIZE);\n    g_firmwareConfigData[0] = 0xAA;\n    g_firmwareConfigData[1] = 0xBB;\n}\n\nint updateFirmwareConfigSegment(const uint8_t* packet_data, uint16_t packet_len) {\n    if (packet_data == NULL || packet_len < 2) {\n        return -1;\n    }\n\n    uint8_t config_area_offset = packet_data[0];\n    uint8_t data_segment_length = packet_data[1];\n\n    if (2 + data_segment_length > packet_len) {\n        return -2;\n    }\n\n    if (data_segment_length > MAX_INCOMING_PARAM_DATA_SIZE) {\n        return -3;\n    }\n\n    if (config_area_offset >= FIRMWARE_CONFIG_BUFFER_SIZE) {\n        return -4;\n    }\n\n    if (config_area_offset + data_segment_length > FIRMWARE_CONFIG_BUFFER_SIZE) {\n        return -5;\n    }\n\n    const uint8_t* actual_data_ptr = packet_data + 2;\n\n    for (uint8_t i = 0; i < data_segment_length; ++i) {\n        g_firmwareConfigData[config_area_offset + i] = actual_data_ptr[i];\n    }\n\n    return 0;\n}\n\nvoid handleFirmwareUpdateMessage(const uint8_t* msg_payload, uint16_t payload_size) {\n    updateFirmwareConfigSegment(msg_payload, payload_size);\n}", "is_vuln": 0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define DIAG_DATA_STORAGE_SIZE 250\n\nstatic uint8_t g_diagDataStore[DIAG_DATA_STORAGE_SIZE];\n\nvoid initDiagnosticDataStore() {\n    memset(g_diagDataStore, 0, DIAG_DATA_STORAGE_SIZE);\n}\n\nint updateDiagnosticBlock(uint16_t offset, uint8_t len, const uint8_t* data) {\n    if (data == NULL || len == 0) {\n        return -1;\n    }\n\n    if (offset >= DIAG_DATA_STORAGE_SIZE) {\n        return -2;\n    }\n\n    for (uint8_t i = 0; i < len; ++i) {\n        g_diagDataStore[offset + i] = data[i];\n    }\n\n    return 0;\n}\n\nvoid handleDiagnosticUpdateMessage(const uint8_t* msg_raw, uint16_t msg_raw_len) {\n    if (msg_raw == NULL || msg_raw_len < 3) {\n        return;\n    }\n\n    uint16_t current_read_pos = 0;\n\n    uint16_t block_offset = (msg_raw[current_read_pos] << 8) | msg_raw[current_read_pos + 1];\n    current_read_pos += 2;\n\n    uint8_t block_len = msg_raw[current_read_pos];\n    current_read_pos += 1;\n\n    if (current_read_pos + block_len > msg_raw_len) {\n        return;\n    }\n\n    const uint8_t* payload_ptr = msg_raw + current_read_pos;\n\n    updateDiagnosticBlock(block_offset, block_len, payload_ptr);\n}\n\nuint8_t getDiagDataByte(uint16_t index) {\n    if (index < DIAG_DATA_STORAGE_SIZE) {\n        return g_diagDataStore[index];\n    }\n    return 0xFF;\n}", "is_vuln": 1}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_STORED_TELEMETRY_RECORDS_DATA_SIZE 256\n#define MAX_INCOMING_PACKET_SIZE 512\n\nstatic uint8_t g_telemetryStorageBuffer[MAX_STORED_TELEMETRY_RECORDS_DATA_SIZE];\nstatic uint16_t g_currentStorageWriteOffset = 0;\n\nvoid initTelemetryStorage() {\n    memset(g_telemetryStorageBuffer, 0, MAX_STORED_TELEMETRY_RECORDS_DATA_SIZE);\n    g_currentStorageWriteOffset = 0;\n}\n\nint processTelemetryDataPacket(const uint8_t* packet_data, uint16_t packet_len) {\n    if (packet_data == NULL || packet_len == 0 || packet_len > MAX_INCOMING_PACKET_SIZE) {\n        return -1;\n    }\n\n    uint16_t current_packet_read_offset = 0;\n\n    while (current_packet_read_offset < packet_len) {\n        if (current_packet_read_offset + 2 > packet_len) {\n            return -1;\n        }\n\n        uint8_t record_id = packet_data[current_packet_read_offset];\n        uint8_t data_len = packet_data[current_packet_read_offset + 1];\n\n        if (current_packet_read_offset + 2 + data_len > packet_len) {\n            return -1;\n        }\n\n        uint16_t record_storage_size = 2 + data_len;\n\n        if (g_currentStorageWriteOffset + record_storage_size > MAX_STORED_TELEMETRY_RECORDS_DATA_SIZE) {\n            return -2;\n        }\n\n        const uint8_t* record_data_ptr = packet_data + current_packet_read_offset + 2;\n\n        g_telemetryStorageBuffer[g_currentStorageWriteOffset] = record_id;\n        g_currentStorageWriteOffset++;\n\n        g_telemetryStorageBuffer[g_currentStorageWriteOffset] = data_len;\n        g_currentStorageWriteOffset++;\n\n        for (int i = 0; i < data_len; ++i) {\n            g_telemetryStorageBuffer[g_currentStorageWriteOffset + i] = record_data_ptr[i];\n        }\n        g_currentStorageWriteOffset += data_len;\n\n        current_packet_read_offset += 2 + data_len;\n    }\n\n    return 0;\n}\n\nvoid systemReceiveTelemetry(const uint8_t* raw_telemetry_packet, uint16_t packet_size) {\n    if (g_currentStorageWriteOffset == 0) {\n        initTelemetryStorage();\n    }\n    processTelemetryDataPacket(raw_telemetry_packet, packet_size);\n}", "is_vuln": 0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_PID_CONTROLLERS 5\n#define PID_PARAM_SET_SIZE sizeof(PID_Parameters)\n\ntypedef struct {\n    float Kp;\n    float Ki;\n    float Kd;\n    int32_t min_output;\n    int32_t max_output;\n    uint8_t loop_status;\n    uint8_t reserved[3];\n} PID_Parameters;\n\nstatic PID_Parameters g_pidConfigs[MAX_PID_CONTROLLERS];\n\nvoid initPIDControllers() {\n    for (int i = 0; i < MAX_PID_CONTROLLERS; ++i) {\n        g_pidConfigs[i].Kp = 0.0f;\n        g_pidConfigs[i].Ki = 0.0f;\n        g_pidConfigs[i].Kd = 0.0f;\n        g_pidConfigs[i].min_output = 0;\n        g_pidConfigs[i].max_output = 0;\n        g_pidConfigs[i].loop_status = 0;\n        memset(g_pidConfigs[i].reserved, 0, sizeof(g_pidConfigs[i].reserved));\n    }\n}\n\nint updatePIDParameter(const uint8_t* msg_data, uint16_t msg_len) {\n    if (msg_data == NULL || msg_len < 3) {\n        return -1;\n    }\n\n    uint8_t controller_id = msg_data[0];\n    uint8_t parameter_offset_bytes = msg_data[1];\n    uint16_t data_value_len = msg_len - 2;\n\n    if (controller_id >= MAX_PID_CONTROLLERS) {\n        return -2;\n    }\n\n    if ((uint16_t)parameter_offset_bytes + data_value_len > PID_PARAM_SET_SIZE) {\n        return -3;\n    }\n\n    memcpy((uint8_t*)&g_pidConfigs[controller_id] + parameter_offset_bytes, msg_data + 2, data_value_len);\n\n    return 0;\n}\n\nvoid handleVehicleConfigMessage(const uint8_t* network_data, uint16_t network_len) {\n    if (network_len < 3) {\n        return;\n    }\n    updatePIDParameter(network_data, network_len);\n}\n\nfloat getPIDKp(uint8_t id) {\n    if (id < MAX_PID_CONTROLLERS) {\n        return g_pidConfigs[id].Kp;\n    }\n    return 0.0f;\n}", "is_vuln": 0}
