{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_STORED_TELEMETRY_RECORDS_DATA_SIZE 256\n#define MAX_INCOMING_PACKET_SIZE 512\n\nstatic uint8_t g_telemetryStorageBuffer[MAX_STORED_TELEMETRY_RECORDS_DATA_SIZE];\nstatic uint16_t g_currentStorageWriteOffset = 0;\n\nvoid initTelemetryStorage() {\n    memset(g_telemetryStorageBuffer, 0, MAX_STORED_TELEMETRY_RECORDS_DATA_SIZE);\n    g_currentStorageWriteOffset = 0;\n}\n\nint processTelemetryDataPacket(const uint8_t* packet_data, uint16_t packet_len) {\n    if (packet_data == NULL || packet_len == 0 || packet_len > MAX_INCOMING_PACKET_SIZE) {\n        return -1;\n    }\n\n    uint16_t current_packet_read_offset = 0;\n\n    while (current_packet_read_offset < packet_len) {\n        if (current_packet_read_offset + 2 > packet_len) {\n            return -1;\n        }\n\n        uint8_t record_id = packet_data[current_packet_read_offset];\n        uint8_t data_len = packet_data[current_packet_read_offset + 1];\n\n        if (current_packet_read_offset + 2 + data_len > packet_len) {\n            return -1;\n        }\n\n        const uint8_t* record_data_ptr = packet_data + current_packet_read_offset + 2;\n\n        g_telemetryStorageBuffer[g_currentStorageWriteOffset] = record_id;\n        g_currentStorageWriteOffset++;\n\n        g_telemetryStorageBuffer[g_currentStorageWriteOffset] = data_len;\n        g_currentStorageWriteOffset++;\n\n        for (int i = 0; i < data_len; ++i) {\n            g_telemetryStorageBuffer[g_currentStorageWriteOffset + i] = record_data_ptr[i];\n        }\n        g_currentStorageWriteOffset += data_len;\n\n        current_packet_read_offset += 2 + data_len;\n    }\n\n    return 0;\n}\n\nvoid systemReceiveTelemetry(const uint8_t* raw_telemetry_packet, uint16_t packet_size) {\n    if (g_currentStorageWriteOffset == 0) {\n        initTelemetryStorage();\n    }\n    processTelemetryDataPacket(raw_telemetry_packet, packet_size);\n}", "is_vuln": 1}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define ENGINE_PARAM_MAP_SIZE 256\n#define MAX_PARAM_UPDATE_LENGTH 64\n\nstatic uint8_t g_engineParamMap[ENGINE_PARAM_MAP_SIZE];\n\nvoid initializeEngineParameters() {\n    memset(g_engineParamMap, 0x00, ENGINE_PARAM_MAP_SIZE);\n    for (uint16_t i = 0; i < ENGINE_PARAM_MAP_SIZE; ++i) {\n        g_engineParamMap[i] = (uint8_t)(i % 0xFF);\n    }\n}\n\nint updateEngineParameterSegment(uint8_t param_offset, const uint8_t* update_data, uint8_t update_len) {\n    if (update_data == NULL || update_len == 0) {\n        return -1;\n    }\n\n    if (param_offset >= ENGINE_PARAM_MAP_SIZE) {\n        return -2;\n    }\n\n    if (update_len > MAX_PARAM_UPDATE_LENGTH) {\n        return -3;\n    }\n\n    if ((uint16_t)param_offset + update_len > ENGINE_PARAM_MAP_SIZE) {\n        return -4;\n    }\n\n    for (uint8_t i = 0; i < update_len; ++i) {\n        g_engineParamMap[param_offset + i] = update_data[i];\n    }\n\n    return 0;\n}\n\nvoid handleParamUpdateMessage(uint8_t offset, const uint8_t* data, uint8_t len) {\n    updateEngineParameterSegment(offset, data, len);\n}\n\nuint8_t getEngineParameter(uint8_t index) {\n    if (index < ENGINE_PARAM_MAP_SIZE) {\n        return g_engineParamMap[index];\n    }\n    return 0xFF;\n}", "is_vuln": 0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_LOG_ENTRY_PAYLOAD_SIZE 62\n#define LOG_ACCUMULATOR_BUFFER_SIZE 256\n\ntypedef enum {\n    LOG_TYPE_GENERIC_INFO = 0x01,\n    LOG_TYPE_CRITICAL_FAULT = 0x02,\n    LOG_TYPE_SENSOR_DATA = 0x03,\n    LOG_TYPE_TELEMETRY_EVENT = 0x04\n} LogEntryType;\n\ntypedef struct {\n    uint8_t type;\n    uint8_t data_length;\n    uint8_t data[MAX_LOG_ENTRY_PAYLOAD_SIZE];\n} InternalLogEntry;\n\nstatic uint8_t g_logAccumulatorBuffer[LOG_ACCUMULATOR_BUFFER_SIZE];\nstatic uint16_t g_logAccumulatorCurrentPos = 0;\n\ntypedef struct {\n    const uint8_t* stream_ptr;\n    uint16_t stream_total_len;\n    uint16_t current_stream_offset;\n} DataStreamReaderContext;\n\nint processIncomingLogEntry(DataStreamReaderContext* reader_ctx) {\n    if (reader_ctx == NULL || reader_ctx->stream_ptr == NULL) {\n        return -1;\n    }\n\n    if (reader_ctx->current_stream_offset + 2 > reader_ctx->stream_total_len) {\n        return -1;\n    }\n\n    uint8_t log_type = reader_ctx->stream_ptr[reader_ctx->current_stream_offset];\n    uint8_t payload_len_from_stream = reader_ctx->stream_ptr[reader_ctx->current_stream_offset + 1];\n\n    if (reader_ctx->current_stream_offset + 2 + payload_len_from_stream > reader_ctx->stream_total_len) {\n        return -1;\n    }\n\n    InternalLogEntry temp_log_entry;\n    temp_log_entry.type = log_type;\n    temp_log_entry.data_length = payload_len_from_stream;\n\n    memcpy(temp_log_entry.data, reader_ctx->stream_ptr + reader_ctx->current_stream_offset + 2, payload_len_from_stream);\n\n    uint16_t total_entry_size_to_accumulate = 2 + payload_len_from_stream;\n\n    if (g_logAccumulatorCurrentPos + total_entry_size_to_accumulate > LOG_ACCUMULATOR_BUFFER_SIZE) {\n        return -1;\n    }\n\n    memcpy(g_logAccumulatorBuffer + g_logAccumulatorCurrentPos, &temp_log_entry, total_entry_size_to_accumulate);\n    g_logAccumulatorCurrentPos += total_entry_size_to_accumulate;\n\n    return total_entry_size_to_accumulate;\n}\n\nint processDiagnosticDataBlock(const uint8_t* diagnostic_data, uint16_t data_block_len) {\n    if (diagnostic_data == NULL || data_block_len < 2) {\n        return -1;\n    }\n\n    DataStreamReaderContext reader_ctx = {\n        .stream_ptr = diagnostic_data,\n        .stream_total_len = data_block_len,\n        .current_stream_offset = 0\n    };\n\n    g_logAccumulatorCurrentPos = 0;\n\n    while (reader_ctx.current_stream_offset < reader_ctx.stream_total_len) {\n        int bytes_consumed = processIncomingLogEntry(&reader_ctx);\n        if (bytes_consumed <= 0) {\n            return -1;\n        }\n        reader_ctx.current_stream_offset += bytes_consumed;\n    }\n\n    return g_logAccumulatorCurrentPos;\n}", "is_vuln": 1}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_DIAG_PAYLOAD_SIZE 256\n#define MAX_VEHICLE_FEATURES 32\n\ntypedef struct {\n    uint8_t feature_index; \n    uint8_t new_state;     \n} FeatureUpdateRequest;\n\nstatic uint8_t g_vehicleFeatureStates[MAX_VEHICLE_FEATURES]; \n\nvoid initVehicleFeatures() {\n    memset(g_vehicleFeatureStates, 0, sizeof(g_vehicleFeatureStates));\n}\n\nint processFeatureUpdateCommand(const uint8_t* payload, uint16_t payload_len) {\n    if (payload == NULL || payload_len < 1) {\n        return -1; \n    }\n\n    uint8_t num_updates = payload[0];\n    uint16_t expected_len = 1 + (num_updates * sizeof(FeatureUpdateRequest));\n\n    if (expected_len > payload_len) {\n        return -1; \n    }\n\n    for (uint8_t i = 0; i < num_updates; ++i) {\n        uint16_t current_offset = 1 + (i * sizeof(FeatureUpdateRequest));\n        \n        if (current_offset + sizeof(FeatureUpdateRequest) > payload_len) {\n            return -1; \n        }\n\n        FeatureUpdateRequest current_request;\n        current_request.feature_index = payload[current_offset];\n        current_request.new_state = payload[current_offset + 1];\n\n        g_vehicleFeatureStates[current_request.feature_index] = current_request.new_state;\n    }\n\n    return 0; \n}", "is_vuln": 1}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_STORED_TELEMETRY_RECORDS_DATA_SIZE 256\n#define MAX_INCOMING_PACKET_SIZE 512\n\nstatic uint8_t g_telemetryStorageBuffer[MAX_STORED_TELEMETRY_RECORDS_DATA_SIZE];\nstatic uint16_t g_currentStorageWriteOffset = 0;\n\nvoid initTelemetryStorage() {\n    memset(g_telemetryStorageBuffer, 0, MAX_STORED_TELEMETRY_RECORDS_DATA_SIZE);\n    g_currentStorageWriteOffset = 0;\n}\n\nint processTelemetryDataPacket(const uint8_t* packet_data, uint16_t packet_len) {\n    if (packet_data == NULL || packet_len == 0 || packet_len > MAX_INCOMING_PACKET_SIZE) {\n        return -1;\n    }\n\n    uint16_t current_packet_read_offset = 0;\n\n    while (current_packet_read_offset < packet_len) {\n        if (current_packet_read_offset + 2 > packet_len) {\n            return -1;\n        }\n\n        uint8_t record_id = packet_data[current_packet_read_offset];\n        uint8_t data_len = packet_data[current_packet_read_offset + 1];\n\n        if (current_packet_read_offset + 2 + data_len > packet_len) {\n            return -1;\n        }\n\n        uint16_t record_storage_size = 2 + data_len;\n\n        if (g_currentStorageWriteOffset + record_storage_size > MAX_STORED_TELEMETRY_RECORDS_DATA_SIZE) {\n            return -2;\n        }\n\n        const uint8_t* record_data_ptr = packet_data + current_packet_read_offset + 2;\n\n        g_telemetryStorageBuffer[g_currentStorageWriteOffset] = record_id;\n        g_currentStorageWriteOffset++;\n\n        g_telemetryStorageBuffer[g_currentStorageWriteOffset] = data_len;\n        g_currentStorageWriteOffset++;\n\n        for (int i = 0; i < data_len; ++i) {\n            g_telemetryStorageBuffer[g_currentStorageWriteOffset + i] = record_data_ptr[i];\n        }\n        g_currentStorageWriteOffset += data_len;\n\n        current_packet_read_offset += 2 + data_len;\n    }\n\n    return 0;\n}\n\nvoid systemReceiveTelemetry(const uint8_t* raw_telemetry_packet, uint16_t packet_size) {\n    if (g_currentStorageWriteOffset == 0) {\n        initTelemetryStorage();\n    }\n    processTelemetryDataPacket(raw_telemetry_packet, packet_size);\n}", "is_vuln": 0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n// Max number of distinct sensor data types\n#define MAX_SENSORS 4\n\n// Fixed size buffer for each sensor's aggregated data\n// This is intentionally smaller than MAX_TELEMETRY_PACKET_PAYLOAD\n#define SENSOR_DATA_BUFFER_SIZE 32\n\n// Maximum payload size for an incoming telemetry packet\n// This represents the maximum data that can be carried by the communication protocol.\n#define MAX_TELEMETRY_PACKET_PAYLOAD 64\n\n// Storage for sensor data. Each sensor has its own fixed-size buffer.\nstatic uint8_t g_sensorDataBuffers[MAX_SENSORS][SENSOR_DATA_BUFFER_SIZE];\n// Current valid length for each sensor's buffer\nstatic uint8_t g_sensorDataLengths[MAX_SENSORS];\n\n// Structure representing an incoming telemetry packet\ntypedef struct {\n    uint8_t  sensor_id;  // Identifier for the sensor (0 to MAX_SENSORS-1)\n    uint16_t data_len;   // Length of the data payload in this packet\n    uint8_t  data[MAX_TELEMETRY_PACKET_PAYLOAD]; // Raw data payload\n} TelemetryPacket;\n\n// Initialize sensor data buffers to zeros and lengths to zero\nvoid initSensorDataStorage() {\n    for (int i = 0; i < MAX_SENSORS; ++i) {\n        memset(g_sensorDataBuffers[i], 0, SENSOR_DATA_BUFFER_SIZE);\n        g_sensorDataLengths[i] = 0;\n    }\n}\n\n// Process an incoming telemetry packet\n// This function stores the sensor data into the respective buffer based on sensor_id.\nint processTelemetryPacket(const TelemetryPacket* packet) {\n    if (packet == NULL) {\n        return -1; // Invalid packet pointer\n    }\n\n    // 1. Validate sensor ID against the maximum number of sensors\n    if (packet->sensor_id >= MAX_SENSORS) {\n        return -2; // Invalid sensor ID, out of bounds for the array of buffers\n    }\n\n    // 2. Validate incoming data length against the packet's maximum allowed payload size.\n    // This check ensures the data doesn't exceed what the packet structure can hold.\n    if (packet->data_len > MAX_TELEMETRY_PACKET_PAYLOAD) {\n        return -3; // Data length exceeds the maximum payload defined for the packet format\n    }\n\n    // VULNERABILITY: Improper Restriction of Operations within the Bounds of a Memory Buffer (CWE-119)\n    // The 'packet->data_len' is checked against 'MAX_TELEMETRY_PACKET_PAYLOAD' (64 bytes), which is\n    // the maximum size the incoming packet *can* carry. However, the destination buffer\n    // 'g_sensorDataBuffers[packet->sensor_id]' is only 'SENSOR_DATA_BUFFER_SIZE' (32 bytes).\n    // If an attacker sends a 'data_len' value that is valid for the packet (e.g., 40 bytes),\n    // but larger than 'SENSOR_DATA_BUFFER_SIZE', the 'memcpy' will write beyond the bounds of\n    // the targeted sensor's buffer, potentially overwriting data in adjacent buffers\n    // or other critical memory regions.\n    memcpy(g_sensorDataBuffers[packet->sensor_id], packet->data, packet->data_len);\n    \n    // Update the stored length, note that it will be truncated if packet->data_len > 255,\n    // but the overflow happens during memcpy if packet->data_len > SENSOR_DATA_BUFFER_SIZE\n    g_sensorDataLengths[packet->sensor_id] = (uint8_t)packet->data_len;\n\n    return 0; // Success\n}\n\n// Dummy function to simulate receiving a raw data buffer from a communication interface.\n// In a real system, 'raw_data_buffer' would be parsed into a 'TelemetryPacket' structure.\nvoid receiveSensorData(const uint8_t* raw_data_buffer) {\n    processTelemetryPacket((const TelemetryPacket*)raw_data_buffer);\n}", "is_vuln": 1}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define VEHICLE_CONFIG_BUFFER_SIZE 64\n#define MAX_COMMAND_PAYLOAD_SIZE 128\n\ntypedef struct {\n    uint8_t command_id;\n    uint8_t parameter_idx;\n    uint8_t data_length;\n    uint8_t data[MAX_COMMAND_PAYLOAD_SIZE - 3];\n} VehicleCommand;\n\nstatic uint8_t g_vehicleConfigArea[VEHICLE_CONFIG_BUFFER_SIZE];\n\nvoid initVehicleConfigArea() {\n    memset(g_vehicleConfigArea, 0x00, VEHICLE_CONFIG_BUFFER_SIZE);\n}\n\n#define CMD_UPDATE_CONFIG_DATA 0x05\n#define CMD_READ_CONFIG_DATA   0x06\n\nint processVehicleCommand(const VehicleCommand* cmd) {\n    if (cmd == NULL) {\n        return -1;\n    }\n\n    if (cmd->command_id == CMD_UPDATE_CONFIG_DATA) {\n        uint8_t start_offset = cmd->parameter_idx;\n        uint8_t data_to_copy = cmd->data_length;\n\n        if (start_offset >= VEHICLE_CONFIG_BUFFER_SIZE) {\n            return -2;\n        }\n\n        if (data_to_copy > (MAX_COMMAND_PAYLOAD_SIZE - (sizeof(cmd->command_id) + sizeof(cmd->parameter_idx) + sizeof(cmd->data_length)))) {\n             return -3;\n        }\n\n        uint8_t available_space = VEHICLE_CONFIG_BUFFER_SIZE - start_offset;\n        uint8_t actual_bytes_to_copy = data_to_copy;\n\n        if (actual_bytes_to_copy > available_space) {\n            actual_bytes_to_copy = available_space;\n        }\n\n        memcpy(g_vehicleConfigArea + start_offset, cmd->data, actual_bytes_to_copy);\n\n        if (data_to_copy > actual_bytes_to_copy) {\n            return -5;\n        }\n\n        return 0;\n    } else if (cmd->command_id == CMD_READ_CONFIG_DATA) {\n        return 0;\n    }\n    \n    return -4;\n}", "is_vuln": 0}
{"Function before": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_CAN_FRAME_DATA_LENGTH 8\n#define VEHICLE_STATE_SENSOR_ID 0x01\n#define TIRE_PRESSURE_SENSOR_ID 0x02\n#define FUEL_LEVEL_SENSOR_ID 0x03\n#define VEHICLE_DIAGNOSTIC_DATA_ID 0x04\n\n#define MAX_SENSOR_DATA_PAYLOAD 60 \n\n#define DIAGNOSTIC_STRING_BUFFER_SIZE 30\n\ntypedef struct {\n    uint8_t sensor_id;\n    uint8_t data_length; \n    uint8_t data[MAX_SENSOR_DATA_PAYLOAD]; \n} SensorPacketSegment;\n\nint processSensorTelemetryStream(const uint8_t* msg_buffer, uint16_t msg_len) {\n    if (msg_buffer == NULL || msg_len < (sizeof(uint8_t) * 2)) {\n        return -1;\n    }\n\n    uint16_t current_offset = 0;\n\n    while (current_offset < msg_len) {\n        if (current_offset + sizeof(uint8_t) * 2 > msg_len) {\n            return -2;\n        }\n\n        uint8_t sensor_id = msg_buffer[current_offset];\n        uint8_t data_len = msg_buffer[current_offset + 1];\n\n        if (current_offset + sizeof(uint8_t) * 2 + data_len > msg_len) {\n            return -3;\n        }\n        \n        const uint8_t* sensor_data_ptr = msg_buffer + current_offset + sizeof(uint8_t) * 2;\n\n        if (sensor_id == VEHICLE_DIAGNOSTIC_DATA_ID) {\n            char diagnostic_buffer[DIAGNOSTIC_STRING_BUFFER_SIZE];\n            memset(diagnostic_buffer, 0, DIAGNOSTIC_STRING_BUFFER_SIZE); \n\n            uint8_t bytes_to_copy = data_len;\n            if (bytes_to_copy >= DIAGNOSTIC_STRING_BUFFER_SIZE) {\n                bytes_to_copy = DIAGNOSTIC_STRING_BUFFER_SIZE - 1; \n            }\n\n            for (int i = 0; i < bytes_to_copy; ++i) {\n                diagnostic_buffer[i] = (char)sensor_data_ptr[i];\n            }\n            diagnostic_buffer[bytes_to_copy] = '\\0'; \n\n        }\n\n        current_offset += (sizeof(uint8_t) * 2 + data_len);\n    }\n\n    return 0;\n}\n\nvoid handleTelemetryStream(const uint8_t* stream, uint16_t len) {\n    processSensorTelemetryStream(stream, len);\n}", "is_vuln": 0}
