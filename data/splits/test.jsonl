{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_CAN_PAYLOAD_SIZE 8 \n#define RESPONSE_HEADER_SIZE 3 \n\nint constructDiagnosticResponse(uint8_t* output_buffer, uint16_t output_buffer_max_len,\n                                uint8_t message_id, uint8_t sub_id,\n                                const uint8_t* data_to_send, uint8_t data_len) {\n    if (output_buffer == NULL || data_to_send == NULL) {\n        return -1;\n    }\n\n    uint16_t required_payload_size = (uint16_t)RESPONSE_HEADER_SIZE + data_len;\n\n    if (required_payload_size > output_buffer_max_len) {\n        return -2;\n    }\n\n    output_buffer[0] = message_id;\n    output_buffer[1] = sub_id;\n    output_buffer[2] = data_len;\n\n    uint16_t current_payload_offset = RESPONSE_HEADER_SIZE;\n\n    for (uint8_t i = 0; i < data_len; ++i) { /* FIX: Changed <= to < to correctly limit iterations */\n        output_buffer[current_payload_offset + i] = data_to_send[i];\n    }\n\n    return required_payload_size;\n}\n\nvoid simulateCanRxHandler() {\n    uint8_t can_data_buffer[MAX_CAN_PAYLOAD_SIZE];\n    uint8_t sensor_data_to_reply[5];\n    memset(sensor_data_to_reply, 0xAA, sizeof(sensor_data_to_reply));\n\n    constructDiagnosticResponse(can_data_buffer, MAX_CAN_PAYLOAD_SIZE, 0x01, 0x10, sensor_data_to_reply, sizeof(sensor_data_to_reply));\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define VEHICLE_DIAG_LOG_BUFFER_SIZE 256\n#define DIAG_RECORD_MAX_DATA_LEN 100 \n\ntypedef struct {\n    uint8_t record_type;\n    uint8_t flags;\n    uint8_t data_len; \n} DiagLogRecordHeader;\n\nstatic uint8_t g_diagLogBuffer[VEHICLE_DIAG_LOG_BUFFER_SIZE];\nstatic uint16_t g_logWriteCursor = 0; \n\nvoid initDiagLogger() {\n    memset(g_diagLogBuffer, 0, VEHICLE_DIAG_LOG_BUFFER_SIZE);\n    g_logWriteCursor = 0;\n}\n\nint storeDiagEvent(const uint8_t* record_payload, uint16_t payload_total_len) {\n    if (record_payload == NULL || payload_total_len < sizeof(DiagLogRecordHeader)) {\n        return -1;\n    }\n\n    uint8_t record_type = record_payload[0];\n    uint8_t flags = record_payload[1];\n    uint8_t data_len = record_payload[2];\n\n    if (data_len > DIAG_RECORD_MAX_DATA_LEN) {\n        return -2;\n    }\n    \n    uint16_t current_record_size = sizeof(DiagLogRecordHeader) + data_len;\n\n    if (payload_total_len < current_record_size) {\n        return -3;\n    }\n\n    uint16_t effective_write_pos = g_logWriteCursor;\n\n    if (effective_write_pos + current_record_size > VEHICLE_DIAG_LOG_BUFFER_SIZE) { \n        effective_write_pos = 0;\n        if (current_record_size > VEHICLE_DIAG_LOG_BUFFER_SIZE) {\n            return -4;\n        }\n    }\n\n    g_diagLogBuffer[effective_write_pos++] = record_type;\n    g_diagLogBuffer[effective_write_pos++] = flags;\n    g_diagLogBuffer[effective_write_pos++] = data_len;\n\n    for (uint8_t i = 0; i < data_len; ++i) {\n        g_diagLogBuffer[effective_write_pos + i] = record_payload[sizeof(DiagLogRecordHeader) + i];\n    }\n\n    g_logWriteCursor = (effective_write_pos + data_len) % VEHICLE_DIAG_LOG_BUFFER_SIZE;\n\n    return 0;\n}\n\nvoid receiveNewDiagEventMessage(const uint8_t* msg, uint16_t len) {\n    if (g_logWriteCursor == 0) {\n        initDiagLogger();\n    }\n    storeDiagEvent(msg, len);\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_CONFIG_FEATURES 10\n#define CONFIG_STORAGE_BUFFER_SIZE (MAX_CONFIG_FEATURES * sizeof(FeatureConfig))\n\n// Structure for a single feature configuration, representing a calibration or setting.\ntypedef struct {\n    uint16_t feature_id;\n    uint8_t  config_value;\n} FeatureConfig;\n\n// Global buffer to store parsed feature configurations for an ECU module.\nstatic FeatureConfig g_featureConfigStorage[MAX_CONFIG_FEATURES];\nstatic uint8_t g_currentFeatureCount = 0;\n\n// Initializes the feature configuration storage.\nvoid initFeatureConfigStorage() {\n    memset(g_featureConfigStorage, 0, CONFIG_STORAGE_BUFFER_SIZE);\n    g_currentFeatureCount = 0;\n}\n\n// Parses a received configuration data block from an external source (e.g., diagnostic tool or bootloader).\n// The format of 'raw_data_block' is expected to be:\n// [uint8_t magic_byte] [uint8_t num_entries] [entry1_id_high] [entry1_id_low] [entry1_value] ...\n// Each entry is 3 bytes (2 for ID, 1 for value).\nint parseConfigDataBlock(const uint8_t* raw_data_block, uint16_t block_len) {\n    if (raw_data_block == NULL || block_len < 2) {\n        return -1; // Invalid input: NULL block or too short for header\n    }\n\n    if (raw_data_block[0] != 0xAC) {\n        return -2; // Invalid magic byte: Not a recognized config block\n    }\n\n    uint8_t num_entries_from_stream = raw_data_block[1];\n\n    // FIX: Add bounds check for the number of entries against the internal buffer capacity.\n    // This prevents an attacker from causing an out-of-bounds write by specifying too many entries.\n    if (num_entries_from_stream > MAX_CONFIG_FEATURES) {\n        return -5; // Too many entries for internal storage capacity\n    }\n    \n    // Calculate the total expected length based on the number of entries declared in the stream.\n    uint16_t expected_data_len = 2 + (num_entries_from_stream * (sizeof(uint16_t) + sizeof(uint8_t)));\n\n    // Check if the provided 'block_len' is sufficient for the declared number of entries.\n    if (expected_data_len > block_len) {\n        return -3; // Data block too short for declared entries\n    }\n\n    uint16_t current_read_offset = 2; // Start reading data after magic byte and num_entries\n\n    // Reset current feature count for new block processing\n    g_currentFeatureCount = 0;\n\n    // Iterate through each declared entry in the data block.\n    // The loop bound 'num_entries_from_stream' is now guaranteed not to exceed MAX_CONFIG_FEATURES.\n    for (uint8_t i = 0; i < num_entries_from_stream; ++i) {\n        // Ensure there's enough remaining data in the block for the current entry.\n        if (current_read_offset + sizeof(FeatureConfig) > block_len) {\n            return -4; // Malformed data: insufficient bytes for an entry\n        }\n\n        // Read feature_id (uint16_t, assumed big-endian for simplicity).\n        g_featureConfigStorage[i].feature_id = ((uint16_t)raw_data_block[current_read_offset] << 8) | raw_data_block[current_read_offset + 1];\n        current_read_offset += 2;\n\n        // Read config_value (uint8_t).\n        g_featureConfigStorage[i].config_value = raw_data_block[current_read_offset];\n        current_read_offset += 1;\n\n        g_currentFeatureCount++; // Increment count of processed features\n    }\n\n    return 0; // Successfully processed the configuration block\n}\n\n// Example usage in an automotive context\nvoid loadVehicleSpecificConfigs(const uint8_t* config_stream, uint16_t stream_size) {\n    initFeatureConfigStorage();\n    parseConfigDataBlock(config_stream, stream_size);\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <stddef.h>\n\n#define ECU_CONFIG_DATA_MAX_SIZE 128\n#define PARAM_ID_CUSTOM_SETTING 0x1A\n#define PARAM_ID_DIAG_MODE 0x05\n\nstatic uint8_t g_ecuConfigData[ECU_CONFIG_DATA_MAX_SIZE];\n\nvoid initEcuConfig() {\n    for (size_t i = 0; i < ECU_CONFIG_DATA_MAX_SIZE; ++i) {\n        g_ecuConfigData[i] = 0x00;\n    }\n    g_ecuConfigData[0] = 0xAA;\n    g_ecuConfigData[1] = 0xBB;\n    g_ecuConfigData[2] = 0xCC;\n}\n\nint processConfigParameter(const uint8_t* param_stream, uint16_t stream_len) {\n    if (param_stream == NULL || stream_len < 4) {\n        return -1;\n    }\n\n    uint16_t param_id = (param_stream[0] << 8) | param_stream[1];\n    uint16_t data_len = (param_stream[2] << 8) | param_stream[3];\n    const uint8_t* data_src_ptr = param_stream + 4;\n\n    if (4 + data_len > stream_len) {\n        return -2;\n    }\n\n    if (param_id == PARAM_ID_CUSTOM_SETTING) {\n        const uint8_t CUSTOM_SETTING_OFFSET = 10; \n\n        if (CUSTOM_SETTING_OFFSET >= ECU_CONFIG_DATA_MAX_SIZE) {\n            return -3;\n        }\n\n        if ((uint16_t)CUSTOM_SETTING_OFFSET + data_len > ECU_CONFIG_DATA_MAX_SIZE) {\n            return -5; \n        }\n        \n        uint8_t* dest_ptr = &g_ecuConfigData[CUSTOM_SETTING_OFFSET];\n        for (uint16_t i = 0; i < data_len; ++i) {\n            *dest_ptr = data_src_ptr[i];\n            dest_ptr++;\n        }\n    } else if (param_id == PARAM_ID_DIAG_MODE) {\n        if (data_len != 1) return -4;\n        g_ecuConfigData[0] = data_src_ptr[0];\n    } else {\n        return -99;\n    }\n\n    return 0;\n}\n\nuint8_t getEcuConfigByte(uint8_t index) {\n    if (index < ECU_CONFIG_DATA_MAX_SIZE) {\n        return g_ecuConfigData[index];\n    }\n    return 0xFF;\n}\n\nvoid receiveConfigUpdate(const uint8_t* msg_data, uint16_t msg_len) {\n    processConfigParameter(msg_data, msg_len);\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define ENGINE_CONFIG_BUFFER_SIZE 64\n#define TRANSMISSION_CONFIG_BUFFER_SIZE 32\n#define BRAKE_CONFIG_BUFFER_SIZE 48\n#define INFOTAINMENT_CONFIG_BUFFER_SIZE 128\n\nstatic uint8_t g_engineConfig[ENGINE_CONFIG_BUFFER_SIZE];\nstatic uint8_t g_transmissionConfig[TRANSMISSION_CONFIG_BUFFER_SIZE];\nstatic uint8_t g_brakeConfig[BRAKE_CONFIG_BUFFER_SIZE];\nstatic uint8_t g_infotainmentConfig[INFOTAINMENT_CONFIG_BUFFER_SIZE];\n\ntypedef enum {\n    PARAM_ENGINE = 0,\n    PARAM_TRANSMISSION = 1,\n    PARAM_BRAKE = 2,\n    PARAM_INFOTAINMENT = 3,\n    PARAM_MAX_ID = 4\n} VehicleParamID;\n\nvoid initVehicleConfigBuffers() {\n    memset(g_engineConfig, 0, ENGINE_CONFIG_BUFFER_SIZE);\n    memset(g_transmissionConfig, 0, TRANSMISSION_CONFIG_BUFFER_SIZE);\n    memset(g_brakeConfig, 0, BRAKE_CONFIG_BUFFER_SIZE);\n    memset(g_infotainmentConfig, 0, INFOTAINMENT_CONFIG_BUFFER_SIZE);\n}\n\nint updateVehicleParameter(uint8_t param_id, uint8_t offset, uint8_t length, const uint8_t* data) {\n    if (data == NULL || length == 0) {\n        return -1;\n    }\n    if (param_id >= PARAM_MAX_ID) {\n        return -2;\n    }\n\n    uint8_t* target_buffer = NULL;\n    uint16_t buffer_size = 0;\n    \n    switch (param_id) {\n        case PARAM_ENGINE:\n            target_buffer = g_engineConfig;\n            buffer_size = ENGINE_CONFIG_BUFFER_SIZE;\n            break;\n        case PARAM_TRANSMISSION:\n            target_buffer = g_transmissionConfig;\n            buffer_size = TRANSMISSION_CONFIG_BUFFER_SIZE;\n            break;\n        case PARAM_BRAKE:\n            target_buffer = g_brakeConfig;\n            buffer_size = BRAKE_CONFIG_BUFFER_SIZE;\n            break;\n        case PARAM_INFOTAINMENT:\n            target_buffer = g_infotainmentConfig;\n            buffer_size = INFOTAINMENT_CONFIG_BUFFER_SIZE;\n            break;\n        default:\n            return -3;\n    }\n\n    if (offset >= buffer_size) {\n        return -4;\n    }\n\n    for (uint8_t i = 0; i < length; ++i) {\n        target_buffer[offset + i] = data[i];\n    }\n\n    return 0;\n}\n\nvoid receiveDiagnosticCommand(const uint8_t* command_packet, uint16_t packet_len) {\n    if (command_packet == NULL || packet_len < 3) {\n        return;\n    }\n\n    uint8_t param_id = command_packet[0];\n    uint8_t offset = command_packet[1];\n    uint8_t length = command_packet[2];\n    const uint8_t* data = command_packet + 3;\n\n    if (3 + length > packet_len) {\n        return;\n    }\n\n    updateVehicleParameter(param_id, offset, length, data);\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define DIAG_RESPONSE_BUFFER_SIZE 256\n#define MAX_DIAG_ITEMS 10\n#define DIAG_ITEM_DATA_MAX_LEN 30 \n\nstatic uint8_t g_unpackedDiagData[DIAG_RESPONSE_BUFFER_SIZE];\nstatic uint16_t g_currentUnpackedOffset = 0;\n\ntypedef struct {\n    uint16_t item_id;\n    uint8_t  item_len; \n} DiagnosticItemHeader;\n\nvoid initDiagnosticSystem() {\n    memset(g_unpackedDiagData, 0, DIAG_RESPONSE_BUFFER_SIZE);\n    g_currentUnpackedOffset = 0;\n}\n\nint processDiagResponse(const uint8_t* response_msg, uint16_t msg_len) {\n    if (response_msg == NULL || msg_len < (sizeof(uint8_t) + sizeof(uint8_t))) {\n        return -1; \n    }\n\n    uint16_t current_msg_offset = 0;\n\n    uint8_t num_items = response_msg[current_msg_offset++];\n\n    uint8_t status_flag = response_msg[current_msg_offset++];\n\n    if (num_items == 0) {\n        g_currentUnpackedOffset = 0; \n        return 0;\n    }\n\n    if (num_items > MAX_DIAG_ITEMS) {\n        return -2; \n    }\n\n    g_currentUnpackedOffset = 0;\n\n    for (uint8_t i = 0; i < num_items; ++i) {\n        if (current_msg_offset + sizeof(DiagnosticItemHeader) > msg_len) {\n            return -3; \n        }\n\n        DiagnosticItemHeader header;\n        header.item_id = (response_msg[current_msg_offset] << 8) | response_msg[current_msg_offset + 1];\n        current_msg_offset += 2; \n\n        header.item_len = response_msg[current_msg_offset++]; \n        \n        if (header.item_len > DIAG_ITEM_DATA_MAX_LEN) {\n            return -6; \n        }\n\n        if (current_msg_offset + header.item_len > msg_len) {\n            return -4; \n        }\n\n        for (uint8_t j = 0; j < header.item_len; ++j) {\n            g_unpackedDiagData[g_currentUnpackedOffset + j] = response_msg[current_msg_offset + j];\n        }\n        g_currentUnpackedOffset += header.item_len; \n        current_msg_offset += header.item_len;      \n    }\n\n    return 0;\n}\n\nvoid simulateDiagMessageReceive(const uint8_t* data, uint16_t len) {\n    initDiagnosticSystem();\n    processDiagResponse(data, len);\n}\n\nvoid triggerVulnerability() {\n    uint8_t malicious_msg[332]; \n    uint16_t offset = 0;\n\n    malicious_msg[offset++] = MAX_DIAG_ITEMS; \n    malicious_msg[offset++] = 0; \n\n    for (uint8_t i = 0; i < MAX_DIAG_ITEMS; ++i) {\n        malicious_msg[offset++] = (uint8_t)(0x0001 >> 8); \n        malicious_msg[offset++] = (uint8_t)(0x0001 & 0xFF); \n        malicious_msg[offset++] = DIAG_ITEM_DATA_MAX_LEN; \n\n        for (uint8_t j = 0; j < DIAG_ITEM_DATA_MAX_LEN; ++j) {\n            malicious_msg[offset++] = 'A'; \n        }\n    }\n\n    simulateDiagMessageReceive(malicious_msg, offset);\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <string.h>\n#include <stdint.h>\n#include <stdbool.h>\n\n// Vehicle parameter IDs\n#define VEHICLE_PARAM_SENSOR_CALIBRATION_A 0x10\n#define VEHICLE_PARAM_VEHICLE_IDENTIFIER   0x11\n#define VEHICLE_PARAM_DIAG_LIFETIME_COUNTER 0x12\n\n// Maximum length for vehicle identifier string\n#define VEHICLE_IDENTIFIER_MAX_LEN 16\n\n// Structure to hold vehicle configuration parameters\ntypedef struct {\n    uint16_t sensorCalibrationValueA;       // 2 bytes\n    char     vehicleIdentifier[VEHICLE_IDENTIFIER_MAX_LEN]; // 16 bytes buffer for C string\n    uint32_t diagnosticLifetimeCounter;     // 4 bytes\n    uint8_t  featureFlags[4];               // 4 bytes of feature flags\n} VehicleSystemConfiguration;\n\n// Global instance of the vehicle configuration\nstatic VehicleSystemConfiguration g_systemConfig;\n\n// Function to initialize the configuration\nvoid systemConfigInit() {\n    g_systemConfig.sensorCalibrationValueA = 512;\n    strncpy(g_systemConfig.vehicleIdentifier, \"DEFAULT_VIN_XYZ\", VEHICLE_IDENTIFIER_MAX_LEN - 1);\n    g_systemConfig.vehicleIdentifier[VEHICLE_IDENTIFIER_MAX_LEN - 1] = '\\0';\n    g_systemConfig.diagnosticLifetimeCounter = 0;\n    memset(g_systemConfig.featureFlags, 0, sizeof(g_systemConfig.featureFlags));\n}\n\n// Function to process an incoming update request for a specific vehicle parameter\n// This function could be called by a diagnostic service handler or a CAN message handler.\n// paramId: The ID of the parameter to update.\n// data: Pointer to the new data for the parameter.\n// dataLen: The length of the new data in bytes.\nint updateVehicleParameter(uint8_t paramId, const uint8_t* data, uint16_t dataLen) {\n    if (data == NULL || dataLen == 0) {\n        return -1; // Invalid input\n    }\n\n    switch (paramId) {\n        case VEHICLE_PARAM_SENSOR_CALIBRATION_A:\n            if (dataLen == sizeof(uint16_t)) {\n                // Assuming little-endian or byte-order handled by caller/system\n                g_systemConfig.sensorCalibrationValueA = *(uint16_t*)data;\n            } else {\n                return -2; // Incorrect data length for calibration value\n            }\n            break;\n\n        case VEHICLE_PARAM_VEHICLE_IDENTIFIER:\n            // Fix: Add explicit length check against the buffer's capacity\n            uint16_t bytesToCopy = dataLen;\n            if (bytesToCopy >= VEHICLE_IDENTIFIER_MAX_LEN) { // Use >= to account for null terminator space if applicable\n                bytesToCopy = VEHICLE_IDENTIFIER_MAX_LEN - 1; // Truncate to fit, leaving space for null terminator\n            }\n            memcpy(g_systemConfig.vehicleIdentifier, data, bytesToCopy);\n            g_systemConfig.vehicleIdentifier[bytesToCopy] = '\\0'; // Ensure null termination\n            break;\n\n        case VEHICLE_PARAM_DIAG_LIFETIME_COUNTER:\n            if (dataLen == sizeof(uint32_t)) {\n                g_systemConfig.diagnosticLifetimeCounter = *(uint32_t*)data;\n            } else {\n                return -2; // Incorrect data length for lifetime counter\n            }\n            break;\n\n        default:\n            return -3; // Unknown parameter ID\n    }\n\n    return 0; // Parameter updated successfully\n}\n\n// Example usage context (not part of the vulnerability, just for completeness)\nvoid simulateIncomingMessage(uint8_t id, const uint8_t* payload, uint16_t len) {\n    updateVehicleParameter(id, payload, len);\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_INCOMING_FAULT_MSG_SIZE 256\n#define MAX_FAULT_DESCRIPTION_LEN 64\n\ntypedef enum {\n    SEVERITY_INFO = 0,\n    SEVERITY_WARNING,\n    SEVERITY_CRITICAL\n} FaultSeverity;\n\ntypedef struct {\n    uint16_t      fault_id;\n    FaultSeverity severity;\n    char          description[MAX_FAULT_DESCRIPTION_LEN];\n} ParsedFaultEntry;\n\nstatic ParsedFaultEntry g_lastFaultEntry;\n\nvoid initFaultEntry() {\n    memset(&g_lastFaultEntry, 0, sizeof(ParsedFaultEntry));\n}\n\nint processFaultMessage(const uint8_t* raw_msg, uint16_t msg_len) {\n    if (raw_msg == NULL || msg_len < (sizeof(uint16_t) + sizeof(uint8_t) + sizeof(uint8_t))) {\n        return -1;\n    }\n\n    if (msg_len > MAX_INCOMING_FAULT_MSG_SIZE) {\n        return -2;\n    }\n\n    uint16_t current_offset = 0;\n\n    g_lastFaultEntry.fault_id = (raw_msg[current_offset] << 8) | raw_msg[current_offset + 1];\n    current_offset += sizeof(uint16_t);\n\n    g_lastFaultEntry.severity = (FaultSeverity)raw_msg[current_offset];\n    current_offset += sizeof(uint8_t);\n\n    uint8_t incoming_description_len = raw_msg[current_offset];\n    current_offset += sizeof(uint8_t);\n\n    if (current_offset + incoming_description_len > msg_len) {\n        return -3;\n    }\n\n    uint8_t bytes_to_copy = incoming_description_len;\n    if (bytes_to_copy >= MAX_FAULT_DESCRIPTION_LEN) {\n        bytes_to_copy = MAX_FAULT_DESCRIPTION_LEN - 1;\n    }\n    \n    memcpy(g_lastFaultEntry.description, raw_msg + current_offset, bytes_to_copy);\n    g_lastFaultEntry.description[bytes_to_copy] = '\\0';\n\n    return 0;\n}\n\nconst ParsedFaultEntry* getLastFaultEntry() {\n    return &g_lastFaultEntry;\n}\n\nvoid receiveSimulatedFaultData(const uint8_t* data, uint16_t len) {\n    processFaultMessage(data, len);\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_FIRMWARE_CHUNK_SIZE 256\n#define FIRMWARE_BLOCK_BUFFER_SIZE 4096\n#define TOTAL_FIRMWARE_IMAGE_SIZE 1048576\n\ntypedef struct {\n    uint32_t address_offset;\n    uint16_t data_length;\n    uint8_t  data[MAX_FIRMWARE_CHUNK_SIZE];\n} FirmwarePacket;\n\ntypedef struct {\n    uint32_t current_block_address;\n    uint8_t  firmware_block_buffer[FIRMWARE_BLOCK_BUFFER_SIZE];\n    uint32_t bytes_in_current_block;\n    bool     update_in_progress;\n} FirmwareUpdateContext;\n\nstatic FirmwareUpdateContext g_fwUpdateContext = {0};\n\nvoid initFirmwareUpdater() {\n    memset(&g_fwUpdateContext, 0, sizeof(FirmwareUpdateContext));\n    g_fwUpdateContext.update_in_progress = false;\n}\n\nint handleFirmwarePacket(const FirmwarePacket* packet) {\n    if (packet == NULL || packet->data_length == 0 || packet->data_length > MAX_FIRMWARE_CHUNK_SIZE) {\n        return -1;\n    }\n\n    if (!g_fwUpdateContext.update_in_progress) {\n        return -1;\n    }\n\n    uint32_t global_target_offset = packet->address_offset;\n    uint16_t chunk_len = packet->data_length;\n\n    if (global_target_offset + chunk_len > TOTAL_FIRMWARE_IMAGE_SIZE) {\n        return -2;\n    }\n\n    uint32_t packet_block_base_address = global_target_offset / FIRMWARE_BLOCK_BUFFER_SIZE * FIRMWARE_BLOCK_BUFFER_SIZE;\n    uint32_t offset_within_block = global_target_offset % FIRMWARE_BLOCK_BUFFER_SIZE;\n\n    if (g_fwUpdateContext.current_block_address != packet_block_base_address) {\n        memset(g_fwUpdateContext.firmware_block_buffer, 0, FIRMWARE_BLOCK_BUFFER_SIZE);\n        g_fwUpdateContext.bytes_in_current_block = 0;\n        g_fwUpdateContext.current_block_address = packet_block_base_address;\n    }\n\n    memcpy(g_fwUpdateContext.firmware_block_buffer + offset_within_block, packet->data, chunk_len);\n\n    if (offset_within_block + chunk_len > g_fwUpdateContext.bytes_in_current_block) {\n        g_fwUpdateContext.bytes_in_current_block = offset_within_block + chunk_len;\n    }\n\n    return 0;\n}\n\nvoid startFirmwareUpdate() {\n    g_fwUpdateContext.update_in_progress = true;\n    g_fwUpdateContext.current_block_address = 0;\n    g_fwUpdateContext.bytes_in_current_block = 0;\n    memset(g_fwUpdateContext.firmware_block_buffer, 0, FIRMWARE_BLOCK_BUFFER_SIZE);\n}\n\nvoid endFirmwareUpdate() {\n    g_fwUpdateContext.update_in_progress = false;\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_TELEMETRY_DATA_BLOCKS 4\n#define TELEMETRY_DATA_BLOCK_SIZE 64\n\nstatic uint8_t g_telemetryDataBlocks[MAX_TELEMETRY_DATA_BLOCKS][TELEMETRY_DATA_BLOCK_SIZE];\n\ntypedef struct {\n    uint8_t command_id;\n    uint8_t block_idx;\n    uint8_t start_offset;\n    uint8_t data_len;\n} TelemetryUpdateCommandHeader;\n\nvoid initTelemetryData() {\n    for (int i = 0; i < MAX_TELEMETRY_DATA_BLOCKS; ++i) {\n        memset(g_telemetryDataBlocks[i], 0x00, TELEMETRY_DATA_BLOCK_SIZE);\n    }\n}\n\nint processTelemetryUpdate(const uint8_t* msg_payload, uint16_t payload_total_len) {\n    if (msg_payload == NULL || payload_total_len < sizeof(TelemetryUpdateCommandHeader)) {\n        return -1;\n    }\n\n    const TelemetryUpdateCommandHeader* header = (const TelemetryUpdateCommandHeader*)msg_payload;\n\n    if (header->command_id != 0x01) {\n        return -2;\n    }\n\n    if (header->block_idx >= MAX_TELEMETRY_DATA_BLOCKS) {\n        return -3;\n    }\n    if (header->start_offset >= TELEMETRY_DATA_BLOCK_SIZE) {\n        return -4;\n    }\n\n    if (payload_total_len < sizeof(TelemetryUpdateCommandHeader) + header->data_len) {\n        return -5;\n    }\n\n    const uint8_t* data_to_write = msg_payload + sizeof(TelemetryUpdateCommandHeader);\n\n    for (uint8_t i = 0; i < header->data_len; ++i) {\n        g_telemetryDataBlocks[header->block_idx][header->start_offset + i] = data_to_write[i];\n    }\n\n    return 0;\n}\n\nvoid receiveCANTelemetryCommand(const uint8_t* data, uint16_t len) {\n    initTelemetryData();\n    processTelemetryUpdate(data, len);\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_LOG_MESSAGE_SIZE 256 // Maximum size of an incoming diagnostic log message\n#define INTERNAL_RECORD_BUFFER_SIZE 64 // Fixed-size buffer for a single log record entry\n\n// A simplified log record structure stored internally\ntypedef struct {\n    uint8_t type;\n    uint8_t length; // Actual length of 'data' copied\n    uint8_t data[INTERNAL_RECORD_BUFFER_SIZE];\n} DiagnosticLogRecord;\n\n// Global instance of the current log record being processed/stored\nstatic DiagnosticLogRecord currentLogRecord;\n\n// Initializes the log record buffer with zeros\nvoid initDiagnosticLogRecord() {\n    memset(&currentLogRecord, 0, sizeof(DiagnosticLogRecord));\n}\n\n// Function to process an incoming diagnostic message and store relevant part\n// This function is now fixed against buffer overflow by limiting the copy length.\nint processDiagnosticMessage(const uint8_t* message_data, uint16_t message_len) {\n    if (message_data == NULL || message_len < 2) { // Requires at least tag and length\n        return -1; // Invalid input message\n    }\n\n    uint16_t current_offset = 0;\n\n    // Assume message_data format: [tag (1 byte)][length (1 byte)][data (length bytes)]\n    uint8_t data_tag = message_data[current_offset];\n    current_offset++;\n    uint8_t data_length = message_data[current_offset]; // Length of the data payload\n    current_offset++;\n\n    // Check if the declared data_length fits within the remainder of the incoming message\n    if (current_offset + data_length > message_len) {\n        return -2; // Malformed message: declared length exceeds actual message bounds\n    }\n\n    const uint8_t* source_data_ptr = message_data + current_offset;\n\n    // Determine the actual number of bytes to copy to prevent overflow\n    uint8_t bytes_to_copy = data_length;\n    if (bytes_to_copy > INTERNAL_RECORD_BUFFER_SIZE) {\n        bytes_to_copy = INTERNAL_RECORD_BUFFER_SIZE; // Truncate if incoming data is too large\n    }\n\n    // Store the processed data into the internal log record structure.\n    currentLogRecord.type = data_tag;\n    // The 'length' field should reflect the actual data copied, not the requested length.\n    currentLogRecord.length = bytes_to_copy;\n\n    // FIXED: The loop now uses 'bytes_to_copy' which is bounded by INTERNAL_RECORD_BUFFER_SIZE.\n    for (uint8_t i = 0; i < bytes_to_copy; ++i) {\n        currentLogRecord.data[i] = source_data_ptr[i];\n    }\n\n    // It might be necessary to pad the rest of the buffer with zeros if partial data is copied,\n    // but for simplicity, we only focus on preventing the overflow here.\n\n    return 0;\n}\n\n// Public interface to simulate receiving a diagnostic message\nvoid receiveDiagnosticData(const uint8_t* data, uint16_t len) {\n    initDiagnosticLogRecord();\n    processDiagnosticMessage(data, len);\n}\n\n// Helper function to get a byte from the stored log record data\nuint8_t getLogRecordByte(uint8_t index) {\n    if (index < INTERNAL_RECORD_BUFFER_SIZE) {\n        return currentLogRecord.data[index];\n    }\n    return 0xFF; // Indicate out of bounds read or invalid index\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define DIAG_LOG_TOTAL_BUFFER_SIZE 256\n#define DIAG_LOG_ENTRY_HEADER_SIZE 8 // Example header: Event ID (1), Reserved (5), DataLength (2)\n#define DIAG_LOG_MAX_PAYLOAD_SIZE 64 // Max size of data payload for a single entry\n\n// The main circular buffer for diagnostic logs\nstatic uint8_t g_diagLogBuffer[DIAG_LOG_TOTAL_BUFFER_SIZE];\n// Pointer to the start of the current active log entry being filled\n// This pointer moves in a circular fashion within g_diagLogBuffer.\nstatic uint16_t g_currentEntryStart = 0;\n\nvoid initDiagnosticLogger() {\n    memset(g_diagLogBuffer, 0, DIAG_LOG_TOTAL_BUFFER_SIZE);\n    g_currentEntryStart = 0;\n}\n\n// This function is called to prepare space for a new log entry.\n// It reserves the space and writes a simplified header.\n// 'intended_payload_len' is the expected maximum length of data for this entry's payload.\nint createNewLogEntry(uint8_t event_type, uint16_t intended_payload_len) {\n    uint16_t total_entry_size = DIAG_LOG_ENTRY_HEADER_SIZE + intended_payload_len;\n\n    if (intended_payload_len > DIAG_LOG_MAX_PAYLOAD_SIZE) {\n        return -1; // Payload length exceeds maximum allowed for any single entry\n    }\n    if (total_entry_size > DIAG_LOG_TOTAL_BUFFER_SIZE) {\n        return -2; // Entry too large for the entire buffer\n    }\n\n    // Handle circular buffer wrap-around for the start of the new entry.\n    // If the new entry doesn't fit contiguously, wrap to the beginning.\n    if (g_currentEntryStart + total_entry_size > DIAG_LOG_TOTAL_BUFFER_SIZE) {\n        g_currentEntryStart = 0; // Wrap to beginning of buffer\n    }\n\n    // Write simplified header data at g_currentEntryStart\n    g_diagLogBuffer[g_currentEntryStart] = event_type; // Byte 0: Event Type\n    // Bytes 1-5 reserved/other header fields (for simplicity, assumed to be 0)\n    // Bytes 6-7: Data Length (MSB, LSB) - stored here for later reference\n    g_diagLogBuffer[g_currentEntryStart + DIAG_LOG_ENTRY_HEADER_SIZE - 2] = (uint8_t)(intended_payload_len >> 8);\n    g_diagLogBuffer[g_currentEntryStart + DIAG_LOG_ENTRY_HEADER_SIZE - 1] = (uint8_t)(intended_payload_len & 0xFF);\n\n    return 0; // Success\n}\n\n// This function is used to update a specific byte within the payload\n// of the *current* active log entry. This is often used for incrementally\n// filling or correcting log data.\n// 'payload_offset': The offset FROM THE START OF THE PAYLOAD AREA of the current entry.\n// 'value': The byte value to write.\n//\n// VULNERABILITY: Improper Restriction of Operations within the Bounds of a Memory Buffer (CWE-119)\n// The function calculates an absolute write position based on 'g_currentEntryStart',\n// 'DIAG_LOG_ENTRY_HEADER_SIZE', and the user-controlled 'payload_offset'.\n// It only checks if the 'absolute_write_pos' is within the 'DIAG_LOG_TOTAL_BUFFER_SIZE'.\n// It *does not* check if 'payload_offset' exceeds the 'intended_payload_len' (or\n// 'DIAG_LOG_MAX_PAYLOAD_SIZE') that was declared when the entry was created.\n// An attacker can provide a 'payload_offset' value that is greater than the \n// current entry's intended payload length, but still within the total buffer size.\n// This leads to writing past the end of the current log entry's designated payload area,\n// potentially corrupting the header of the next log entry or other critical adjacent data.\nint updateLogEntryPayloadByte(uint16_t payload_offset, uint8_t value) {\n    uint16_t absolute_write_pos = g_currentEntryStart + DIAG_LOG_ENTRY_HEADER_SIZE + payload_offset;\n\n    // This check is insufficient. It only prevents writing outside the entire static buffer.\n    // It does not prevent writing outside the *allocated space for the current entry's payload*.\n    if (absolute_write_pos >= DIAG_LOG_TOTAL_BUFFER_SIZE) {\n        return -1; // Attempt to write beyond total log buffer boundaries\n    }\n\n    g_diagLogBuffer[absolute_write_pos] = value;\n    return 0;\n}\n\n// After an entry is fully populated, this function advances the write pointer.\n// 'actual_payload_len': The actual number of payload bytes written for this entry.\nvoid finalizeLogEntry(uint16_t actual_payload_len) {\n    g_currentEntryStart = (g_currentEntryStart + DIAG_LOG_ENTRY_HEADER_SIZE + actual_payload_len) % DIAG_LOG_TOTAL_BUFFER_SIZE;\n}\n\n// Public interface to simulate logging a vehicle event with a given data block.\n// This function itself appears safe by respecting effective_payload_len.\nvoid logVehicleEvent(uint8_t event_type, const uint8_t* event_data, uint16_t event_data_len) {\n    if (event_data == NULL || event_data_len == 0) return;\n\n    uint16_t effective_payload_len = event_data_len;\n    if (effective_payload_len > DIAG_LOG_MAX_PAYLOAD_SIZE) {\n        effective_payload_len = DIAG_LOG_MAX_PAYLOAD_SIZE;\n    }\n\n    if (createNewLogEntry(event_type, effective_payload_len) == 0) {\n        for (uint16_t i = 0; i < effective_payload_len; ++i) {\n            // This loop iterates within the correctly bounded effective_payload_len.\n            // The vulnerability is in `updateLogEntryPayloadByte` if called directly\n            // with a manipulated offset.\n            updateLogEntryPayloadByte(i, event_data[i]);\n        }\n        finalizeLogEntry(effective_payload_len);\n    }\n}\n\n// Function simulating an external call that might exploit the vulnerability.\n// In a real system, 'payload_offset' might be extracted from a malicious CAN message\n// or a diagnostic command that allows direct memory access for debugging.\nvoid maliciousDiagnosticPoke(uint16_t offset_from_payload_start, uint8_t value) {\n    // This call directly exploits the lack of bounds checking for payload_offset\n    // within updateLogEntryPayloadByte, allowing a write outside the current entry's\n    // logical payload boundary but within the overall buffer.\n    updateLogEntryPayloadByte(offset_from_payload_start, value);\n}\n\n// Example of how a diagnostic command handler might use these functions\nvoid processDiagnosticCommand(uint8_t command_id, uint8_t* command_payload, uint16_t payload_len) {\n    initDiagnosticLogger(); // Initialize for demonstration\n\n    switch(command_id) {\n        case 0x01: // Standard event logging command\n            logVehicleEvent(0x55, command_payload, payload_len);\n            break;\n        case 0x02: // Special command to 'poke' a byte in the current log entry's data area\n            if (payload_len >= 3) {\n                uint16_t offset = (command_payload[0] << 8) | command_payload[1];\n                uint8_t val = command_payload[2];\n                maliciousDiagnosticPoke(offset, val); // Attacker controls 'offset'\n            }\n            break;\n        // ... other commands\n    }\n}\n", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define CALIBRATION_BLOCK_SIZE 64\n#define NUM_CALIBRATION_BLOCKS 8\n#define TOTAL_CALIBRATION_SIZE (CALIBRATION_BLOCK_SIZE * NUM_CALIBRATION_BLOCKS)\n\nstatic uint8_t g_calibrationData[TOTAL_CALIBRATION_SIZE];\nstatic bool g_calibrationInitialized = false;\n\nvoid initCalibrationSystem() {\n    memset(g_calibrationData, 0, TOTAL_CALIBRATION_SIZE);\n    g_calibrationInitialized = true;\n}\n\nint processCalibrationFragment(const uint8_t* msg_payload, uint16_t payload_len) {\n    if (!g_calibrationInitialized || msg_payload == NULL || payload_len < 5) {\n        return -1;\n    }\n\n    uint8_t block_idx = msg_payload[0];\n    uint16_t block_offset = (msg_payload[1] << 8) | msg_payload[2];\n    uint16_t data_len = (msg_payload[3] << 8) | msg_payload[4];\n\n    if (payload_len < (5 + data_len)) {\n        return -2;\n    }\n\n    if (block_idx >= NUM_CALIBRATION_BLOCKS) {\n        return -3;\n    }\n    \n    if (block_offset >= CALIBRATION_BLOCK_SIZE) {\n        return -4;\n    }\n\n    const uint8_t* data_payload = msg_payload + 5;\n\n    uint16_t global_start_offset = (uint16_t)block_idx * CALIBRATION_BLOCK_SIZE + block_offset;\n\n    for (uint16_t i = 0; i < data_len; ++i) {\n        g_calibrationData[global_start_offset + i] = data_payload[i];\n    }\n    \n    return 0;\n}\n\nvoid handleCANCalibrationMessage(const uint8_t* can_data, uint16_t can_dlc) {\n    processCalibrationFragment(can_data, can_dlc);\n}\n\nuint8_t getCalibrationByte(uint16_t index) {\n    if (index < TOTAL_CALIBRATION_SIZE) {\n        return g_calibrationData[index];\n    }\n    return 0xFF;\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_VEHICLE_PARAMS 256\n#define CAN_PAYLOAD_MAX_SIZE 8\n\nstatic uint8_t g_vehicleParameters[MAX_VEHICLE_PARAMS];\n\nvoid initVehicleParameters() {\n    memset(g_vehicleParameters, 0, MAX_VEHICLE_PARAMS);\n}\n\nint processParameterUpdate(const uint8_t* can_payload, uint8_t payload_len) {\n    if (can_payload == NULL || payload_len < 3) {\n        return -1;\n    }\n\n    uint16_t param_index = (can_payload[0] << 8) | can_payload[1];\n    uint8_t param_value = can_payload[2];\n\n    if (param_index >= MAX_VEHICLE_PARAMS) {\n        return -2;\n    }\n    \n    g_vehicleParameters[param_index] = param_value;\n\n    return 0;\n}\n\nvoid receiveCANMessage(const uint8_t* data, uint8_t len) {\n    processParameterUpdate(data, len);\n}\n\nuint8_t getVehicleParameter(uint8_t index) {\n    if (index < MAX_VEHICLE_PARAMS) {\n        return g_vehicleParameters[index];\n    }\n    return 0xFF;\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define CRITICAL_CALIBRATION_VALUES_COUNT 10 \n#define CALIBRATION_BUFFER_SIZE (CRITICAL_CALIBRATION_VALUES_COUNT * sizeof(uint16_t))\n\nstatic uint16_t g_criticalCalibrationValues[CRITICAL_CALIBRATION_VALUES_COUNT];\n\nvoid initCalibrationValues() {\n    memset(g_criticalCalibrationValues, 0, CALIBRATION_BUFFER_SIZE);\n    for (uint8_t i = 0; i < CRITICAL_CALIBRATION_VALUES_COUNT; ++i) {\n        g_criticalCalibrationValues[i] = (i + 1) * 100;\n    }\n}\n\ntypedef struct {\n    uint8_t  group_id;\n    uint8_t  item_offset;\n    uint16_t new_value;\n} CalibrationUpdateCommand;\n\nint applyCalibrationUpdate(const CalibrationUpdateCommand* command) {\n    if (command == NULL) {\n        return -1;\n    }\n\n    uint8_t group_id = command->group_id;\n    uint8_t item_offset = command->item_offset;\n    uint16_t new_value = command->new_value;\n\n    uint16_t effective_index_base; \n\n    switch (group_id) {\n        case 0:\n            effective_index_base = 0;\n            break;\n        case 1:\n            effective_index_base = 5;\n            break;\n        case 2:\n            effective_index_base = 250;\n            break;\n        default:\n            return -2;\n    }\n\n    uint16_t final_index = effective_index_base + item_offset;\n\n    if (final_index >= CRITICAL_CALIBRATION_VALUES_COUNT) {\n        return -3;\n    }\n\n    g_criticalCalibrationValues[final_index] = new_value;\n\n    return 0;\n}\n\nvoid simulateExternalCalibrationUpdate(uint8_t group, uint8_t offset, uint16_t value) {\n    CalibrationUpdateCommand cmd = { .group_id = group, .item_offset = offset, .new_value = value };\n    applyCalibrationUpdate(&cmd);\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_DTC_METADATA_PROTO_MAX 60\n#define MAX_INTERNAL_DTC_METADATA_SIZE 30\n\n#define MAX_LOGGED_DTC_RECORDS 20\n#define DTC_RECORD_FIXED_SIZE (sizeof(uint16_t) + sizeof(uint8_t) + sizeof(uint8_t))\n#define SINGLE_DTC_RECORD_STORAGE_SIZE (DTC_RECORD_FIXED_SIZE + MAX_INTERNAL_DTC_METADATA_SIZE)\n#define DTC_LOG_BUFFER_TOTAL_SIZE (MAX_LOGGED_DTC_RECORDS * SINGLE_DTC_RECORD_STORAGE_SIZE)\n\ntypedef struct {\n    uint16_t dtc_id;\n    uint8_t status_byte;\n    uint8_t metadata_len;\n    uint8_t metadata[MAX_INTERNAL_DTC_METADATA_SIZE];\n} DTCRecord;\n\nstatic uint8_t g_dtc_log_buffer[DTC_LOG_BUFFER_TOTAL_SIZE];\nstatic uint16_t g_current_log_pos = 0;\n\nvoid initDTCLoggingSystem() {\n    memset(g_dtc_log_buffer, 0, DTC_LOG_BUFFER_TOTAL_SIZE);\n    g_current_log_pos = 0;\n}\n\nint addDTCRecord(uint16_t dtc_code, uint8_t status_byte, const uint8_t* metadata, uint8_t metadata_len) {\n    if (metadata == NULL && metadata_len > 0) {\n        return -1;\n    }\n\n    if (metadata_len > MAX_DTC_METADATA_PROTO_MAX) {\n        return -2;\n    }\n\n    DTCRecord temp_record;\n    temp_record.dtc_id = dtc_code;\n    temp_record.status_byte = status_byte;\n\n    uint8_t actual_copy_len = metadata_len;\n    if (actual_copy_len > MAX_INTERNAL_DTC_METADATA_SIZE) {\n        actual_copy_len = MAX_INTERNAL_DTC_METADATA_SIZE;\n    }\n    temp_record.metadata_len = actual_copy_len;\n    \n    memcpy(temp_record.metadata, metadata, actual_copy_len);\n\n    uint16_t record_effective_size = DTC_RECORD_FIXED_SIZE + temp_record.metadata_len;\n\n    if (g_current_log_pos + record_effective_size > DTC_LOG_BUFFER_TOTAL_SIZE) {\n        return -3;\n    }\n\n    memcpy(g_dtc_log_buffer + g_current_log_pos, &temp_record, record_effective_size);\n    g_current_log_pos += record_effective_size;\n\n    return 0;\n}\n\nuint16_t getDTCLogCount() {\n    if (SINGLE_DTC_RECORD_STORAGE_SIZE == 0) return 0;\n    return g_current_log_pos / SINGLE_DTC_RECORD_STORAGE_SIZE;\n}\n\nvoid simulateExternalDTCReport(uint16_t dtc, uint8_t status, const uint8_t* data, uint8_t data_len) {\n    addDTCRecord(dtc, status, data, data_len);\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_ENGINE_CALIBRATION_POINTS 100\n#define MAX_PAYLOAD_FOR_CALIBRATION 512\n\ntypedef struct {\n    uint16_t rpm_target;\n    uint16_t fuel_injection_pulse;\n} EngineCalibrationPoint;\n\nstatic EngineCalibrationPoint g_engineCalibrationTable[MAX_ENGINE_CALIBRATION_POINTS];\n\nvoid initEngineCalibration() {\n    memset(g_engineCalibrationTable, 0, sizeof(g_engineCalibrationTable));\n    for (int i = 0; i < MAX_ENGINE_CALIBRATION_POINTS; ++i) {\n        g_engineCalibrationTable[i].rpm_target = 800 + i * 10;\n        g_engineCalibrationTable[i].fuel_injection_pulse = 100 + i * 2;\n    }\n}\n\nint updateEngineCalibration(const uint8_t* payload, uint16_t payload_len) {\n    if (payload == NULL || payload_len < 4) {\n        return -1;\n    }\n\n    uint16_t start_index = (payload[0] << 8) | payload[1];\n    uint16_t num_points = (payload[2] << 8) | payload[3];\n\n    uint16_t data_offset = 4;\n    uint16_t expected_data_len = num_points * sizeof(EngineCalibrationPoint);\n\n    if (data_offset + expected_data_len > payload_len) {\n        return -2;\n    }\n    \n    if (start_index >= MAX_ENGINE_CALIBRATION_POINTS) {\n        return -3;\n    }\n\n    for (uint16_t i = 0; i < num_points; ++i) {\n        uint16_t current_data_ptr_offset = data_offset + (i * sizeof(EngineCalibrationPoint));\n        \n        g_engineCalibrationTable[start_index + i].rpm_target = \n            (payload[current_data_ptr_offset] << 8) | payload[current_data_ptr_offset + 1];\n        g_engineCalibrationTable[start_index + i].fuel_injection_pulse = \n            (payload[current_data_ptr_offset + 2] << 8) | payload[current_data_ptr_offset + 3];\n    }\n\n    return 0;\n}\n\nvoid simulateCanMessage(const uint8_t* data, uint16_t len) {\n    updateEngineCalibration(data, len);\n}\n\nEngineCalibrationPoint getCalibrationPoint(uint16_t index) {\n    if (index < MAX_ENGINE_CALIBRATION_POINTS) {\n        return g_engineCalibrationTable[index];\n    }\n    EngineCalibrationPoint invalid = {0,0};\n    return invalid;\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define VEHICLE_FIRMWARE_SIZE 0x10000 \n#define FRAGMENT_MAX_PAYLOAD_SIZE 256 \n\nstatic uint8_t g_firmwareBuffer[VEHICLE_FIRMWARE_SIZE];\n\nvoid initFirmwareBuffer() {\n    memset(g_firmwareBuffer, 0, VEHICLE_FIRMWARE_SIZE);\n}\n\nstatic int processFirmwareFragment(uint16_t fragment_offset, uint8_t fragment_len, const uint8_t* fragment_data) {\n    if (fragment_data == NULL || fragment_len == 0) {\n        return -1;\n    }\n\n    if ((uint32_t)fragment_offset + fragment_len > VEHICLE_FIRMWARE_SIZE) {\n        return -2;\n    }\n\n    for (uint8_t i = 0; i < fragment_len; ++i) {\n        g_firmwareBuffer[fragment_offset + i] = fragment_data[i];\n    }\n\n    return 0;\n}\n\nint handleFirmwareUpdateMessage(const uint8_t* message, uint16_t message_len) {\n    if (message == NULL || message_len < (1 + sizeof(uint16_t) + sizeof(uint8_t))) {\n        return -1;\n    }\n\n    uint8_t service_id = message[0];\n    if (service_id != 0x34) {\n        return -2;\n    }\n\n    uint16_t offset_idx = 1;\n    uint16_t fragment_offset = (message[offset_idx] << 8) | message[offset_idx+1];\n    \n    uint16_t len_idx = offset_idx + sizeof(uint16_t);\n    uint8_t fragment_len = message[len_idx];\n\n    const uint8_t* fragment_data = message + len_idx + sizeof(uint8_t);\n    uint16_t actual_data_in_msg_len = message_len - (len_idx + sizeof(uint8_t));\n\n    if (fragment_len > FRAGMENT_MAX_PAYLOAD_SIZE) {\n        return -3;\n    }\n    \n    return processFirmwareFragment(fragment_offset, fragment_len, fragment_data);\n}\n\nuint8_t getFirmwareByte(uint32_t index) {\n    if (index < VEHICLE_FIRMWARE_SIZE) {\n        return g_firmwareBuffer[index];\n    }\n    return 0xFF;\n}", "is_vuln": 1, "cvss": 7.5}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define DIAG_RESPONSE_BUFFER_SIZE 256\n#define MAX_DIAG_ITEMS 10\n#define DIAG_ITEM_DATA_MAX_LEN 30 \n\nstatic uint8_t g_unpackedDiagData[DIAG_RESPONSE_BUFFER_SIZE];\nstatic uint16_t g_currentUnpackedOffset = 0;\n\ntypedef struct {\n    uint16_t item_id;\n    uint8_t  item_len; \n} DiagnosticItemHeader;\n\nvoid initDiagnosticSystem() {\n    memset(g_unpackedDiagData, 0, DIAG_RESPONSE_BUFFER_SIZE);\n    g_currentUnpackedOffset = 0;\n}\n\nint processDiagResponse(const uint8_t* response_msg, uint16_t msg_len) {\n    if (response_msg == NULL || msg_len < (sizeof(uint8_t) + sizeof(uint8_t))) {\n        return -1; \n    }\n\n    uint16_t current_msg_offset = 0;\n\n    uint8_t num_items = response_msg[current_msg_offset++];\n\n    uint8_t status_flag = response_msg[current_msg_offset++];\n\n    if (num_items == 0) {\n        g_currentUnpackedOffset = 0; \n        return 0;\n    }\n\n    if (num_items > MAX_DIAG_ITEMS) {\n        return -2; \n    }\n\n    g_currentUnpackedOffset = 0;\n\n    for (uint8_t i = 0; i < num_items; ++i) {\n        if (current_msg_offset + sizeof(DiagnosticItemHeader) > msg_len) {\n            return -3; \n        }\n\n        DiagnosticItemHeader header;\n        header.item_id = (response_msg[current_msg_offset] << 8) | response_msg[current_msg_offset + 1];\n        current_msg_offset += 2; \n\n        header.item_len = response_msg[current_msg_offset++]; \n        \n        if (header.item_len > DIAG_ITEM_DATA_MAX_LEN) {\n            return -6; \n        }\n\n        if (current_msg_offset + header.item_len > msg_len) {\n            return -4; \n        }\n\n        if ((uint32_t)g_currentUnpackedOffset + header.item_len > DIAG_RESPONSE_BUFFER_SIZE) {\n            current_msg_offset += header.item_len; \n            return -5; \n        }\n\n        for (uint8_t j = 0; j < header.item_len; ++j) {\n            g_unpackedDiagData[g_currentUnpackedOffset + j] = response_msg[current_msg_offset + j];\n        }\n        g_currentUnpackedOffset += header.item_len; \n        current_msg_offset += header.item_len;      \n    }\n\n    return 0;\n}\n\nvoid simulateDiagMessageReceive(const uint8_t* data, uint16_t len) {\n    initDiagnosticSystem();\n    processDiagResponse(data, len);\n}\n\nvoid triggerVulnerability() {\n    uint8_t malicious_msg[332]; \n    uint16_t offset = 0;\n\n    malicious_msg[offset++] = MAX_DIAG_ITEMS; \n    malicious_msg[offset++] = 0; \n\n    for (uint8_t i = 0; i < MAX_DIAG_ITEMS; ++i) {\n        malicious_msg[offset++] = (uint8_t)(0x0001 >> 8); \n        malicious_msg[offset++] = (uint8_t)(0x0001 & 0xFF); \n        malicious_msg[offset++] = DIAG_ITEM_DATA_MAX_LEN; \n\n        for (uint8_t j = 0; j < DIAG_ITEM_DATA_MAX_LEN; ++j) {\n            malicious_msg[offset++] = 'A'; \n        }\n    }\n\n    simulateDiagMessageReceive(malicious_msg, offset);\n}", "is_vuln": 0, "cvss": NaN}
{"Function before": "#include <stdint.h>\n#include <string.h>\n\n#define TELEMETRY_BUFFER_SIZE 256\n#define MAX_TELEMETRY_PAYLOAD_LEN 8 \n\nstatic uint8_t g_telemetryDataBuffer[TELEMETRY_BUFFER_SIZE];\nstatic uint16_t g_currentBufferWriteOffset = 0;\n\ntypedef enum {\n    TELEMETRY_TYPE_ENGINE_STATUS = 0,\n    TELEMETRY_TYPE_BATTERY_INFO,\n    TELEMETRY_TYPE_TIRE_PRESSURE,\n    TELEMETRY_TYPE_COUNT\n} TelemetryBlockType;\n\ntypedef struct {\n    uint8_t item_size;\n    uint8_t num_items;\n} TelemetryBlockMetadata;\n\nstatic const TelemetryBlockMetadata g_telemetryMetadata[TELEMETRY_TYPE_COUNT] = {\n    {10, 10}, \n    {5, 5},   \n    {8, 10}   \n};\n\nstatic uint16_t g_telemetryTypeBaseOffsets[TELEMETRY_TYPE_COUNT];\n\nvoid initTelemetrySystem() {\n    memset(g_telemetryDataBuffer, 0, TELEMETRY_BUFFER_SIZE);\n    g_currentBufferWriteOffset = 0;\n\n    uint16_t current_offset = 0;\n    for (int i = 0; i < TELEMETRY_TYPE_COUNT; ++i) {\n        g_telemetryTypeBaseOffsets[i] = current_offset;\n        current_offset += (uint16_t)g_telemetryMetadata[i].item_size * g_telemetryMetadata[i].num_items;\n    }\n    g_currentBufferWriteOffset = current_offset; \n}\n\nint updateTelemetryDataItem(TelemetryBlockType telemetry_type, uint8_t item_index, \n                            uint8_t update_offset, uint8_t data_len, const uint8_t* data_payload) {\n    \n    if (telemetry_type >= TELEMETRY_TYPE_COUNT || data_payload == NULL || data_len == 0) {\n        return -1;\n    }\n\n    if (item_index >= g_telemetryMetadata[telemetry_type].num_items) {\n        return -2;\n    }\n\n    if (data_len > MAX_TELEMETRY_PAYLOAD_LEN) {\n        return -3;\n    }\n\n    uint16_t item_base_addr = g_telemetryTypeBaseOffsets[telemetry_type] + \n                              (uint16_t)item_index * g_telemetryMetadata[telemetry_type].item_size;\n\n    uint16_t dest_offset = item_base_addr + update_offset;\n\n    for (uint8_t i = 0; i < data_len; ++i) {\n        g_telemetryDataBuffer[dest_offset + i] = data_payload[i];\n    }\n\n    return 0;\n}\n\nvoid simulateCanTelemetryUpdate(TelemetryBlockType type, uint8_t index, uint8_t offset, uint8_t len, const uint8_t* data) {\n    updateTelemetryDataItem(type, index, offset, len, data);\n}\n\nuint8_t getTelemetryDataByte(uint16_t global_offset) {\n    if (global_offset < TELEMETRY_BUFFER_SIZE) {\n        return g_telemetryDataBuffer[global_offset];\n    }\n    return 0xFF;\n}", "is_vuln": 1, "cvss": 7.5}
